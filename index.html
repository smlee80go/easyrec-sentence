<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>EasyRec</title>
    <!-- ✅ 기존 JSZip CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- MP3 인코딩용 lamejs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.min.js"></script>
    <style>
    body {
      visibility: hidden;
    }

    body.ready {
      visibility: visible;
    }

    :root {
      --bg: #f6f6f6;
      --card: #fff;
      --text: #111;
      --muted: #777;
      --line: #e9e9e9;
      --active-bg: #e6f7ff;
      --active-border: #1890ff;
      --ctl-h: 40px;
      --r: 18px;
      --seg-bg: rgba(40, 167, 69, 0.2);
      --seg-border: rgba(40, 167, 69, 0.6);
      --hover: #f0f0f0;
    }

    :root.dark-mode {
      --bg: #1a1a1a;
      --card: #2d2d2d;
      --text: #e0e0e0;
      --muted: #999;
      --line: #404040;
      --active-bg: #1e3a5f;
      --active-border: #4a9eff;
      --seg-bg: rgba(100, 200, 120, 0.2);
      --seg-border: rgba(100, 200, 120, 0.6);
      --hover: #3a3a3a;
    }

    /* Dark Mode - Additional Overrides */
    :root.dark-mode .btn {
      background: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    :root.dark-mode .btn:hover:not(:disabled) {
      background: #4a4a4a;
    }

    :root.dark-mode .btn:disabled {
      background: #2a2a2a;
      color: #666;
    }

    :root.dark-mode .btn.primary {
      background: #3a3a3a;
      border-color: #555;
    }

    :root.dark-mode .btn.primary:hover:not(:disabled) {
      background: #4a4a4a;
    }

    :root.dark-mode .btn.danger {
      background: #3a3a3a;
      color: #ff6b6b;
      border-color: #8b3a3a;
    }

    :root.dark-mode .btn.danger:hover:not(:disabled) {
      background: #4a2a2a;
    }

    /* Dark Mode - Time Info Panel */
    :root.dark-mode .timeInfoPanel {
      background: none;
      border: none;
    }

    :root.dark-mode .timeInfoLabel {
      color: #999;
    }

    :root.dark-mode .timeInfoValue {
      color: #e0e0e0;
    }

    :root.dark-mode .timeInfoSeparator {
      background: #555;
    }

    /* Dark Mode - Waveform Area */
    :root.dark-mode .waveWrapper {
      background: #1e1e1e;
      border-color: #404040;
    }

    :root.dark-mode .waveformArea {
      background: #252525;
    }

    /* Dark Mode - Minimap */
    :root.dark-mode .minimapWrapper {
      background: #2a2a2a;
      border-color: #404040;
    }

    /* Dark Mode - Timeline */
    :root.dark-mode .timelineScroll {
      background: #2a2a2a;
      border-color: #404040;
    }

    :root.dark-mode .timelineScroll::-webkit-scrollbar-thumb {
      background: #555;
    }

    /* Dark Mode - Segment List */
    :root.dark-mode .segmentList {
      background: #252525;
      border-color: #404040;
    }

    :root.dark-mode .segTable th {
      background: #2a2a2a;
      color: #999;
      border-color: #404040;
    }

    :root.dark-mode .segTable th:hover {
      background: #353535;
      color: #e0e0e0;
    }

    :root.dark-mode .segTable td {
      border-color: #333;
      color: #e0e0e0;
    }

    :root.dark-mode .segTable tr:hover {
      background: #2a2a2a;
    }

    :root.dark-mode .segNameCell:hover {
      background: #2d2d2d;
    }

    :root.dark-mode .segNameInput {
      background: #2d2d2d;
      color: #e0e0e0;
      border-color: #4a9eff;
    }

    /* Dark Mode - Chip */
    :root.dark-mode .chip {
      background: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    /* Dark Mode - Login Card */
    :root.dark-mode .loginCard {
      background: var(--card);
    }

    :root.dark-mode .loginTitle {
      color: var(--text);
    }

    :root.dark-mode .loginSub {
      color: var(--muted);
    }

    /* Dark Mode - Modal */
    :root.dark-mode .modal-box {
      background: #2d2d2d;
      border-color: #404040;
    }

    :root.dark-mode .modal-title {
      color: #e0e0e0;
    }

    :root.dark-mode .modal-desc {
      color: #aaa;
    }

    /* Shortcut Modal Styles */
    .modal-box.wide {
      width: 500px;
      max-width: 90vw;
    }

    .shortcut-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
    }

    .shortcut-table th {
      text-align: left;
      padding: 8px 12px;
      background: #f5f5f5;
      border-bottom: 2px solid #ddd;
      font-weight: 600;
      font-size: 12px;
      color: #555;
    }

    .shortcut-table td {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      font-size: 13px;
    }

    .shortcut-table td:first-child {
      font-family: 'Courier New', monospace;
      background: #f9f9f9;
      font-weight: 600;
      color: #333;
      white-space: nowrap;
    }

    .shortcut-table tr:hover {
      background: #fafafa;
    }

    /* Dark Mode - Shortcut Table */
    :root.dark-mode .shortcut-table th {
      background: #2a2a2a;
      color: #999;
      border-color: #404040;
    }

    :root.dark-mode .shortcut-table td {
      border-color: #333;
      color: #e0e0e0;
    }

    :root.dark-mode .shortcut-table td:first-child {
      background: #2d2d2d;
      color: #4a9eff;
    }

    :root.dark-mode .shortcut-table tr:hover {
      background: #2a2a2a;
    }

    /* Dark Mode - Region Info Box */
    :root.dark-mode #regionInfoBox {
      background: linear-gradient(135deg, #1e3a5f 0%, #2c5282 100%) !important;
      border-color: #4a9eff !important;
    }

    :root.dark-mode #regionInfoBox div {
      color: #bbdefb !important;
    }

    /* 세그먼트 리스트 - 선택된 행 */
    .segTable tr.selected {
      background: #e3f2fd !important;
      outline: 2px solid #1890ff;
      outline-offset: -2px;
    }

    :root.dark-mode .segTable tr.selected {
      background: #1e3a5f !important;
      outline-color: #4a9eff;
    }

    /* 반복 재생 버튼 활성화 */
    #btnLoop.active {
      background: #e3f2fd;
      border-color: #1890ff;
      color: #1890ff;
    }

    :root.dark-mode #btnLoop.active {
      background: #1e3a5f;
      border-color: #4a9eff;
      color: #4a9eff;
    }

    /* 마커 테이블 */
    .markerTable {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .markerTable th {
      text-align: left;
      background: #fff3e0;
      padding: 6px 10px;
      position: sticky;
      top: 0;
      font-weight: 600;
      color: #e65100;
      border-bottom: 1px solid #ffcc80;
    }

    .markerTable td {
      padding: 6px 10px;
      border-bottom: 1px solid #eee;
    }

    .markerTable tr:hover {
      background: #fff8e1;
      cursor: pointer;
    }

    .markerTable tr.selected {
      background: #ffe0b2 !important;
      outline: 2px solid #ff9800;
      outline-offset: -2px;
    }

    /* Dark Mode */
    :root.dark-mode .markerTable th {
      background: #3d2c1f;
      color: #ffb74d;
      border-color: #5d4037;
    }

    :root.dark-mode .markerTable td {
      border-color: #333;
    }

    :root.dark-mode .markerTable tr:hover {
      background: #3d2c1f;
    }

    :root.dark-mode .markerTable tr.selected {
      background: #5d4037 !important;
      outline-color: #ff9800;
    }

    /* 리스트 리사이저 */
    .listResizer {
      width: 6px;
      background: #e0e0e0;
      cursor: col-resize;
      flex-shrink: 0;
      border-radius: 3px;
      transition: background 0.2s;
    }

    .listResizer:hover {
      background: #1890ff;
    }

    .listResizer.dragging {
      background: #1890ff;
    }

    :root.dark-mode .listResizer {
      background: #404040;
    }

    :root.dark-mode .listResizer:hover,
    :root.dark-mode .listResizer.dragging {
      background: #4a9eff;
    }

    /* 리사이저 래퍼 */
    .listResizerWrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
    }

    /* 리사이저 (세로로 길게) */
    .listResizerWrapper .listResizer {
      flex: 1;
      width: 6px;
      min-height: 40px;
    }


    /* 웨이브/리스트 수평 리사이저 */
    .waveResizer {
      height: 6px;
      background: #e0e0e0;
      cursor: row-resize;
      flex-shrink: 0;
      border-radius: 3px;
      transition: background 0.2s;
      margin: 2px 0;
    }

    .waveResizer:hover {
      background: #1890ff;
    }

    .waveResizer.dragging {
      background: #1890ff;
    }

    :root.dark-mode .waveResizer {
      background: #404040;
    }

    :root.dark-mode .waveResizer:hover,
    :root.dark-mode .waveResizer.dragging {
      background: #4a9eff;
    }

    /* 전사 패널 */
    .transcriptPanel {
      display: none;
      flex-direction: column;
      min-width: 0;
      overflow-y: auto;
      flex: 1;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: var(--card);
    }

    .transcriptPanel.show {
      display: flex;
    }

    .transcriptPanel .listHeader {
      font-size: 11px;
      font-weight: 600;
      color: #4caf50;
      padding: 6px 10px;
      background: #f5f5f5;
      border-bottom: 1px solid #e0e0e0;
      flex-shrink: 0;
      position: sticky;
      top: 0;
      z-index: 1;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    :root.dark-mode .transcriptPanel .listHeader {
      background: #2a2a2a;
      color: #81c784;
      border-color: #404040;
    }

    .transcriptItem {
      display: flex;
      gap: 4px;
      padding: 8px 10px;
      font-size: 11px;
      border-bottom: 1px solid var(--line);
      cursor: pointer;
      transition: background 0.15s;
      align-items: flex-start;
      font-size: 13px;
    }

    .transcriptItem:hover {
      background: #f5f5f5;
    }

    .transcriptItem.active {
      background: #e3f2fd;
    }

    .transcriptItem.selected {
      background: #1a3a5c;
      outline: 1px solid #4caf50;
    }

    :root:not(.dark-mode) .transcriptItem.selected {
      background: #e8f5e9;
      outline: 1px solid #4caf50;
    }

    :root.dark-mode .transcriptItem {
      border-color: #333;
    }

    :root.dark-mode .transcriptItem:hover {
      background: #3a3a3a;
    }

    :root.dark-mode .transcriptItem.active {
      background: #1a3a5c;
    }

    .transcriptTime {
      color: #52c41a;
      font-family: monospace;
      font-size: 11px;
      min-width: 48px;
      flex-shrink: 0;
      padding-top: 1px;
      font-weight: 500;
    }

    .transcriptText {
      flex: 1;
      line-height: 1.4;
      word-break: break-word;
    }

    .transcriptText[contenteditable="true"] {
      outline: 1px solid #1890ff;
      border-radius: 3px;
      padding: 1px 3px;
      background: #fff;
    }
    .transcriptPlaceholder {
      padding: 20px;
      text-align: center;
      color: #999;
      font-size: 11px;
    }

    .transcriptTextInput {
      width: 100%;
      padding: 4px 6px;
      font-size: 11px;
      border: 1px solid #1890ff;
      border-radius: 4px;
      outline: none;
      box-sizing: border-box;
      background: var(--card);
      color: var(--text);
    }

    .transcriptTextInput:focus {
      box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
    }

    :root.dark-mode .transcriptText[contenteditable="true"] {
      background: #2a2a2a;
    }

    .sttStatus {
      font-size: 10px;
      padding: 6px 10px;
      color: #888;
      text-align: center;
    }

    .sttStatus.recording {
      color: #f44336;
      animation: recordingPulse 1s ease-in-out infinite;
    }

    /* 교환 버튼 */
    .listSwapBtn {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #ccc;
      background: #f5f5f5;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .listSwapBtn:hover {
      background: #1890ff;
      border-color: #1890ff;
      color: white;
    }

    /* Dark Mode */
    :root.dark-mode .listSwapBtn {
      background: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    :root.dark-mode .listSwapBtn:hover {
      background: #4a9eff;
      border-color: #4a9eff;
      color: white;
    }

    /* 슬라이더 한줄 레이아웃 */
    .sliderRow {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
    }

    .sliderRowLabel {
      font-size: 11px;
      color: var(--muted);
      font-weight: 600;
      white-space: nowrap;
      min-width: 70px;
    }

    .sliderRow input[type="range"] {
      flex: 1;
      min-width: 60px;
      margin: 0;
    }

    .sliderRowValue {
      font-size: 11px;
      font-weight: 600;
      color: #4a9eff;
      min-width: 45px;
      text-align: right;
    }

    /* 사이드바 토글 버튼 - 열림 상태 */
    .sidebarToggle {
      width: 22px;
      height: 22px;
      border: none;
      border-radius: 4px;
      background: transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      color: var(--muted);
      flex-shrink: 0;
      transition: all 0.15s ease;
    }

    .sidebarToggle:hover {
      background: var(--active-bg);
      color: var(--active-border);
      border-color: var(--active-border);
    }

    /* 사이드바 바깥 열기 버튼 (absolute, 접힘 시만 표시) */
    .sidebarToggleOpen {
      position: absolute;
      left: 2px;
      top: 47px;
      width: 22px;
      height: 22px;
      border: none;
      border-radius: 4px;
      background: transparent;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 0;
      color: var(--muted);
      z-index: 10;
      transition: all 0.15s ease;
      box-shadow: none;
    }

    .sidebarToggleOpen:hover {
      background: var(--active-bg);
      color: var(--active-border);
      border-color: var(--active-border);
    }

    /* 접힘 시: 열기 버튼 표시 */
    .editorWrap.sidebar-collapsed .sidebarToggleOpen {
      display: flex;
    }

    /* ✅ 핵심: 사이드바 접힘 시 그리드 레이아웃 변경 */
    .editorWrap.sidebar-collapsed {
      grid-template-columns: 0 minmax(0, 1fr);
    }

    /* 사이드바 접힘 상태 - 사이드바 숨김 */
    .editorWrap.sidebar-collapsed .sidebar {
      width: 0;
      min-width: 0;
      padding: 0;
      overflow: hidden;
      border: none;
      opacity: 0;
      pointer-events: none;
    }

    /* 사이드바 트랜지션 */
    .sidebar {
      transition: width 0.3s ease, padding 0.3s ease, opacity 0.3s ease, min-width 0.3s ease;
    }

    /* Dark Mode */
    :root.dark-mode .sidebarToggle {
      background: transparent;
      border: none;
    }

    :root.dark-mode .sidebarToggle:hover {
      background: var(--active-bg);
      color: var(--active-border);
    }

    :root.dark-mode .sidebarToggleOpen {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    :root.dark-mode .sidebarToggleOpen:hover {
      background: var(--active-bg);
      color: var(--active-border);
      border-color: var(--active-border);
    }

    .sidebar .btn {
      height: 24px;
      font-size: 10px;
      padding: 0 8px;
      border-radius: 6px;
    }

    .sidebar .btn-check {
      font-size: 10px;
    }

    .sidebar .btn-check input {
      width: 12px;
      height: 12px;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
    }

    .wrap {
      max-width: none;
      margin: 0 auto;
      padding: 4px 18px;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 4px;
      flex-shrink: 0;
      padding: 0;
      height: 24px;
    }

    .brand {
      font-weight: 800;
      letter-spacing: -0.2px;
      font-size: 13px;
    }

    .topright {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #fff;
      border: 1px solid var(--line);
      font-size: 12px;
      color: #333
    }

    .btn {
      height: 32px;
      padding: 0 14px;
      border-radius: 12px;
      border: 1px solid #d9d9d9;
      background: #fff;
      color: var(--text);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.15s;
      user-select: none;
      white-space: nowrap;
    }

    .btn:hover:not(:disabled) {
      background: #f5f5f5;
    }

    .btn.primary {
      background: #fff;
      color: var(--text);
      border-color: #d9d9d9;
    }

    .btn.primary:hover:not(:disabled) {
      background: #f5f5f5;
    }

    .btn:disabled {
      opacity: .5;
      cursor: not-allowed;
      background: #f9f9f9;
      color: #aaa;
    }

    .btn.danger {
      color: #d32f2f;
      border-color: #ffcdd2;
      background: #fff;
    }

    .btn.danger:hover:not(:disabled) {
      background: #ffcdd2;
    }

    .sidebar .btn {
      height: 24px;
      font-size: 10px;
      padding: 0 8px;
      border-radius: 6px;
    }

    .sidebar .btn-check {
      font-size: 12px;
    }

    .sidebar .btn-check input {
      width: 14px;
      height: 14px;
    }

    .btnGroup {
      display: flex;
      gap: 6px;
    }

    .btnGroup.small {
      margin-top: 8px;
    }

    .btnGroup.small .btn {
      flex: 1;
      font-size: 10px;
      height: 24px;
      padding: 0 4px;
    }

    .btnGroup.toolbar-group {
      margin-right: 8px;
      border-right: 1px solid #eee;
      padding-right: 8px;
    }

    .btnGroup.toolbar-group .btn {
      padding: 0 8px;
      font-weight: 600;
      font-size: 11px;
      color: #555;
      width: 48px;
    }

    .btn-check {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 500;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
    }

    .btn-check input {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: #111;
      margin: 0;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 14px;
    }

    .center {
      min-height: calc(100vh - 80px);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 40px
    }

    .loginCard {
      width: min(420px, 92vw)
    }

    .loginTitle {
      font-weight: 800;
      font-size: 18px;
      margin-bottom: 4px;
      text-align: center
    }

    .loginSub {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      margin-bottom: 12px
    }

    .stack {
      display: flex;
      flex-direction: column;
      gap: 10px
    }

    label.small {
      font-size: 12px;
      color: #333;
      margin-bottom: 6px;
      display: block
    }

    /* Dark Mode - Labels */
    :root.dark-mode label.small {
      color: #e0e0e0;
    }

    input[type="text"],
    input[type="password"] {
      width: 100%;
      height: var(--ctl-h);
      border-radius: 12px;
      border: 1px solid #d9d9d9;
      padding: 0 12px;
      outline: none;
      background: #fff;
      color: #111;
    }

    /* Dark Mode - Input Fields */
    :root.dark-mode input[type="text"],
    :root.dark-mode input[type="password"] {
      background: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    :root.dark-mode input[type="text"]::placeholder,
    :root.dark-mode input[type="password"]::placeholder {
      color: #999;
    }

    .loginActions {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      margin-top: 10px
    }

    .divider {
      height: 1px;
      background: var(--line);
      margin: 12px 0
    }

    .text-xs-muted {
      font-size: 11px;
      color: #999;
      line-height: 1.4;
      margin-top: 4px;
      min-height: 32px;
    }

    /* Custom Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.4);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(2px);
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal-box {
      background: #fff;
      padding: 20px;
      width: 420px;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      border: 1px solid #eee;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 80vh;
      overflow-y: auto;
      max-width: 90vw;
      /* ✅ 추가: 모바일 대응 */
    }

    .modal-title {
      font-weight: 700;
      font-size: 16px;
    }

    .modal-desc {
      font-size: 13px;
      color: #555;
      line-height: 1.5;
      flex: 1;
      /* ✅ 추가: 남은 공간 차지 */
      overflow-y: auto;
      /* ✅ 추가: 스크롤 가능 */
    }

    .modal-actions {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      /* ✅ 추가: 공간 부족 시 줄바꿈 */
      gap: 8px;
      margin-top: 8px;
      flex-shrink: 0;
    }

    .modal-actions .btn {
      flex: 1 1 auto;
      /* ✅ 수정: 최소 너비 보장하면서 유연하게 */
      min-width: 120px;
      /* ✅ 추가: 최소 너비 */
      justify-content: center;
      white-space: nowrap;
      /* ✅ 추가: 텍스트 줄바꿈 방지 */
    }

    /* Toast Message */
    #toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 13px;
      z-index: 2000;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    #toast.show {
      opacity: 1;
    }

    /* 센터 토스트 (모달처럼) */
    #centerToast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 20px 32px;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 500;
      z-index: 10000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s, transform 0.3s;
      text-align: center;
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #centerToast.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .editorWrap {
      display: grid;
      grid-template-columns: 260px minmax(0, 1fr);
      gap: 14px;
      height: 100%;
      overflow: hidden;
    }

    @media (max-width: 860px) {
      .editorWrap {
        grid-template-columns: 1fr;
      }
    }

    .sidebar {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow-y: auto;
    }

    .sidebar h2 {
      font-size: 12px;
      font-weight: 700;
      margin: 0 0 4px 0;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--line);
    }

    .sideSection {
      padding: 4px 0 8px 0;
      border-bottom: 1px solid var(--line);
    }

    .sideSection:last-child {
      border-bottom: none
    }

    .sideLabel {
      font-size: 13px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 6px;
      letter-spacing: 0.3px
    }

    .trackList {
      display: flex;
      flex-direction: column;
      gap: 3px;
      margin-top: 6px;
      height: 100px;
      min-height: 60px;
      resize: vertical;
      overflow: auto;
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 3px;
    }

    .trackItem {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 6px;
      border: 2px solid transparent;
      transition: all 0.15s;
      user-select: none;
      background: #f9f9f9;
      font-size: 11px;
      flex-shrink: 0;
    }

    .trackItem:hover {
      background: #eee;
    }

    .trackItem.active {
      background: var(--active-bg);
      border-color: var(--active-border);
    }

    /* Dark Mode - Track List */
    :root.dark-mode .trackItem {
      background: #3a3a3a;
      color: #e0e0e0;
    }

    :root.dark-mode .trackItem:hover {
      background: #4a4a4a;
    }

    .trackInfo {
      flex: 1;
      overflow: hidden;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .trackName {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 500;
      max-width: 120px;
    }

    .trackDur {
      font-size: 10px;
      color: var(--muted);
      margin-left: 4px;
    }

    .workspace {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow: hidden;
      min-width: 0;
      min-height: 0;
    }

    .workspace > .waveWrapper {
      margin-bottom: -4px;
    }

    .workspace > .listWrapper {
      margin-top: -4px;
    }

    .workspaceHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-shrink: 0;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--line);
      margin-bottom: -8px;
      min-height: 22px;
    }

    .workspaceHeader h1 {
      font-size: 12px;
      font-weight: 700;
      margin: 0;
    }

    .workspaceHeader .chip {
      font-size: 11px;
      padding: 2px 8px;
      height: 18px;
      line-height: 14px;
    }

    .minimapWrapper {
      height: 22px;
      width: 100%;
      background: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 6px;
      position: relative;
      overflow: hidden;
      margin-bottom: 0;
      cursor: pointer;
    }

    #minimapCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .waveWrapper {
      display: flex;
      flex-direction: column;
      gap: 0;
      border: 1px dashed var(--line);
      border-radius: 14px;
      background: #fafafa;
      padding: 2px;
      overflow: hidden;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      margin-top: 4px;
      flex: 3 1 0;
      min-height: 50px;
    }

    .waveformArea {
      flex: 1;
      min-height: 100px;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 13px;
      position: relative;
      overflow: hidden;
      cursor: text;
      transition: height 0.2s;
    }

    #waveCanvas {
      width: 100% !important;
      height: 100% !important;
      display: none;
    }

    .timelineScroll {
      height: 14px;
      background: #eee;
      border-top: 1px solid #e0e0e0;
      overflow-x: auto;
      overflow-y: hidden;
      border-radius: 0 0 12px 12px;
      width: 100%;
    }

    .timelineSpacer {
      height: 1px;
    }

    .timelineScroll::-webkit-scrollbar {
      height: 10px;
    }

    .timelineScroll::-webkit-scrollbar-thumb {
      background: #bbb;
      border-radius: 5px;
    }

    .segmentList {
      background: #fafafa;
      border: 1px solid var(--line);
      border-radius: 14px;
      min-height: 100px;
      padding: 0;
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .segmentList .placeholder {
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      padding: 40px 0;
      margin: auto;
    }

    .segTable {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .segTable th {
      text-align: left;
      background: #eee;
      padding: 8px 12px;
      position: sticky;
      top: 0;
      font-weight: 600;
      color: #555;
      border-bottom: 1px solid #ddd;
      cursor: pointer;
      user-select: none;
      transition: background 0.1s;
    }

    .segTable th:hover {
      background: #e0e0e0;
      color: #111;
    }

    .segTable td {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
    }

    .segTable tr:hover {
      background: #f0f0f0;
      cursor: pointer;
    }

    .segAction {
      text-align: right;
    }

    .segNameCell {
      cursor: text;
      position: relative;
    }

    .segNameCell:hover {
      background: #fff;
      box-shadow: inset 0 0 0 1px #1890ff;
    }

    .segNameInput {
      width: 100%;
      font-family: inherit;
      font-size: inherit;
      font-weight: bold;
      border: 1px solid #1890ff;
      border-radius: 3px;
      padding: 2px 4px;
      outline: none;
      box-sizing: border-box;
      background: #fff;
    }

    .btn-xs {
      padding: 2px 8px;
      height: 24px;
      font-size: 11px;
      border-radius: 4px;
    }

    .toolbar {
      display: flex;
      gap: 3px;
      align-items: center;
      flex-wrap: wrap;
      padding: 0 0 6px 0;
      border-bottom: 1px solid var(--line);
      flex-shrink: 0;
      margin-top: -4px;
    }

    .toolbar .btn {
      width: 26px;
      height: 26px;
      padding: 0;
      font-size: 12px;
      border-radius: 6px;
    }

    .timeInfoPanel {
      display: flex;
      gap: 0;
      align-items: stretch;
      flex-wrap: nowrap;
      padding: 0;
      background: none;
      border: none;
      font-size: 10px;
      margin: 0;
    }

    .timeInfoGroup {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0 5px;
      line-height: 1.1;
    }

    .timeInfoLabel {
      color: #999;
      font-weight: 600;
      font-size: 8px;
      letter-spacing: 0.2px;
    }

    .timeInfoValue {
      font-family: monospace;
      font-weight: 700;
      color: #333;
      font-size: 10px;
    }

    .timeInfoSeparator {
      width: 1px;
      align-self: stretch;
      background: #ddd;
      margin: 0 3px;
    }

    /* Range Slider Styling */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #e0e0e0;
      outline: none;
      margin: 4px 0;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #333;
      cursor: pointer;
      transition: background 0.15s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #111;
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #333;
      cursor: pointer;
      border: none;
      transition: background 0.15s;
    }

    input[type="range"]::-moz-range-thumb:hover {
      background: #111;
    }

    .sliderGroup {
      margin-top: 4px;
    }

    .sliderLabel {
      font-size: 10px;
      color: #999;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .sliderValue {
      font-size: 9px;
      color: #bbb;
      text-align: center;
      margin-top: 1px;
      margin-bottom: 2px;
    }

    /* Collapsible Section */
    .sideSection.collapsible .sideLabel {
      cursor: pointer;
      user-select: none;
      position: relative;
      padding-right: 20px;
      transition: color 0.2s;
    }

    .sideSection.collapsible .sideLabel:hover {
      color: #333;
    }

    /* Dark Mode - Collapsible Label */
    :root.dark-mode .sideSection.collapsible .sideLabel:hover {
      color: #4a9eff;
    }

    :root.dark-mode .sideSection.collapsible .sideLabel::after {
      color: #999;
    }

    .sideSection.collapsible .sideLabel::after {
      content: '▼';
      position: absolute;
      right: 0;
      font-size: 10px;
      transition: transform 0.2s;
    }

    .sideSection.collapsible.collapsed .sideLabel::after {
      transform: rotate(-90deg);
    }

    .collapsibleContent {
      max-height: 1000px;
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
      opacity: 1;
    }

    .collapsibleContent.collapsed {
      max-height: 0;
      opacity: 0;
    }

    /* Dark Mode - Track List */
    :root.dark-mode .trackItem {
      background: #3a3a3a;
      color: #e0e0e0;
    }

    :root.dark-mode .trackItem:hover {
      background: #4a4a4a;
    }

    /* Dark Mode - Collapsible Label */
    :root.dark-mode .sideSection.collapsible .sideLabel:hover {
      color: #4a9eff;
    }

    :root.dark-mode .sideSection.collapsible .sideLabel::after {
      color: #999;
    }

    /* Dark Mode - Range Slider */
    :root.dark-mode input[type="range"] {
      background: #4a4a4a;
    }

    :root.dark-mode input[type="range"]::-webkit-slider-thumb {
      background: #4a9eff;
    }

    :root.dark-mode input[type="range"]::-webkit-slider-thumb:hover {
      background: #6bb6ff;
      transform: scale(1.1);
    }

    :root.dark-mode input[type="range"]::-moz-range-thumb {
      background: #4a9eff;
    }

    :root.dark-mode input[type="range"]::-moz-range-thumb:hover {
      background: #6bb6ff;
      transform: scale(1.1);
    }

    :root.dark-mode #deleteSegmentsList {
      background: linear-gradient(135deg, #3a2020 0%, #4a2525 100%);
      border-color: #8b3a3a;
      color: #ff6b6b;
    }

    /* Dark Mode - Auto Segment Confirm Modal */
    :root.dark-mode #autoSegmentConfirmDesc {
      color: #aaa;
    }

    /* Dark Mode - Auto Segment Confirm Modal Segment List */
    :root.dark-mode #autoSegmentConfirmDesc>div {
      background: linear-gradient(135deg, #3a2020 0%, #4a2525 100%) !important;
      border-color: #8b3a3a !important;
      color: #ff6b6b !important;
    }

    /* Segment Index Column */
    .segTable th:first-child,
    .segTable td:first-child {
      width: 50px;
      text-align: center;
      font-size: 11px;
    }

    .segTable th:first-child {
      cursor: default !important;
      user-select: none;
    }

    .segTable th:first-child:hover {
      background: #eee !important;
      /* 호버 시에도 색상 변하지 않음 */
      color: #555 !important;
    }

    /* Dark Mode */
    :root.dark-mode .segTable th:first-child:hover {
      background: #2a2a2a !important;
      color: #999 !important;
    }

    :root.dark-mode .segTable td:first-child {
      color: #666;
    }

    /* 자동 세그먼트 모달 슬라이더 너비 조절 */
    #autoSegmentModal input[type="range"] {
      width: 85%;
    }

    /* 자동 세그먼트 모달 - 슬라이더와 값 가로 배치 */
    #autoSegmentModal .sliderGroup {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }

    #autoSegmentModal .sliderGroup .sliderLabel {
      width: 100%;
      margin-bottom: 0;
    }

    #autoSegmentModal .sliderGroup input[type="range"] {
      flex: 1;
      min-width: 0;
    }

    #autoSegmentModal .sliderGroup .sliderValue {
      min-width: 50px;
      text-align: right;
      margin: 0;
      font-size: 12px;
      font-weight: 600;
      color: #4a9eff;
    }

    /* 세그먼트/마커 리스트 래퍼 - 좌우 배치 */
    .listWrapper {
      display: flex;
      gap: 8px;
      flex: 1;
      min-height: 60px;
      overflow: hidden;
    }

    .listWrapper .segmentList {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      transition: flex 0.3s ease;
      overflow-y: auto;
      /* ✅ 여기에 스크롤 추가 */
    }

    /* 리스트 헤더는 고정 */
    .listHeader {
      font-size: 11px;
      font-weight: 600;
      color: #555;
      padding: 6px 10px;
      background: #f5f5f5;
      border-bottom: 1px solid #e0e0e0;
      flex-shrink: 0;
      position: sticky;
      /* ✅ 헤더 고정 */
      top: 0;
      z-index: 1;
    }

    :root.dark-mode .listHeader {
      background: #2a2a2a;
      color: #999;
      border-color: #404040;
    }

    /* 내용이 있을 때 더 많은 공간 차지 */
    .listWrapper .segmentList.has-content {
      flex: 2;
    }

    /* 내용이 없을 때 적은 공간 차지 */
    .listWrapper .segmentList.no-content {
      flex: 1;
    }

    /* 둘 다 내용이 있거나 없으면 동일 */
    .listWrapper .segmentList.equal {
      flex: 1;
    }

    /* 상대방이 없을 때 전체 차지 */
    .listWrapper .segmentList.full {
      flex: 9;
    }

    /* 리스트 포커스 스타일 */
    .listWrapper .segmentList {
      outline-offset: -2px;
      transition: outline 0.2s ease;
    }

    /* placeholder도 위쪽 정렬 */
    .segmentList .placeholder {
      padding: 20px;
      text-align: center;
      /* flex: 1 제거, align-items/justify-content 제거 */
    }

    /* 테이블 영역 스크롤 */
    .segmentList .segTable,
    .segmentList .markerTable {
      /* flex: 1 제거! */
      width: 100%;
    }

    /* 드래그 앤 드롭 스타일 */
    .trackList.drag-over {
      background: var(--active-bg);
      border: 2px dashed var(--active-border);
      border-radius: 8px;
    }

    .trackList.drag-over::after {
      content: '여기에 파일을 놓으세요';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 13px;
      font-weight: 600;
      color: var(--active-border);
      pointer-events: none;
    }

    .trackList {
      position: relative;
      /* drag-over::after를 위해 */
    }

    :root.dark-mode .trackList.drag-over {
      background: #1e3a5f;
      border-color: #4a9eff;
    }

    :root.dark-mode .trackList.drag-over::after {
      color: #4a9eff;
    }

    /* 트랙 이름 마퀴(흐르는 텍스트) 효과 */
    .trackName {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 500;
      max-width: 140px;
      position: relative;
    }

    /* 마퀴 애니메이션 컨테이너 */
    .trackName .marquee-inner {
      display: inline-block;
      white-space: nowrap;
      transition: transform 0.3s ease-out;
    }

    /* 호버 시 애니메이션 */
    .trackItem:hover .trackName .marquee-inner.scrolling {
      animation: marquee-scroll var(--scroll-duration, 3s) linear infinite;
      animation-delay: 0.5s;
      /* 호버 후 0.5초 뒤 시작 */
    }

    @keyframes marquee-scroll {
      0% {
        transform: translateX(0);
      }

      100% {
        transform: translateX(var(--scroll-distance, -50%));
      }
    }

    /* 커스텀 툴팁 스타일 */
    .track-tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      max-width: 300px;
      word-break: break-all;
      z-index: 10000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(5px);
      transition: opacity 0.2s, transform 0.2s;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .track-tooltip.show {
      opacity: 1;
      transform: translateY(0);
    }

    .track-tooltip::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 20px;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 6px solid rgba(0, 0, 0, 0.9);
    }

    /* 툴팁 내 파일 정보 */
    .track-tooltip .tooltip-name {
      font-weight: 600;
      margin-bottom: 4px;
      color: #4a9eff;
    }

    .track-tooltip .tooltip-info {
      font-size: 11px;
      color: #aaa;
    }

    /* 다크모드 툴팁 */
    :root.dark-mode .track-tooltip {
      background: rgba(50, 50, 50, 0.95);
      border: 1px solid #555;
    }

    /* 플레이리스트 포커스 스타일 */
    .trackList:focus {
      outline: 2px solid var(--active-border);
      outline-offset: -2px;
    }

    .trackList.focused {
      outline: 2px solid var(--active-border);
      outline-offset: -2px;
    }

    :root.dark-mode .trackList:focus,
    :root.dark-mode .trackList.focused {
      outline-color: #4a9eff;
    }

    /* 키보드로 선택된 트랙 하이라이트 */
    .trackItem.keyboard-selected {
      background: var(--active-bg) !important;
      box-shadow: inset 0 0 0 2px var(--active-border);
    }

    :root.dark-mode .trackItem.keyboard-selected {
      background: #1e3a5f !important;
      box-shadow: inset 0 0 0 2px #4a9eff;
    }

    /* 플레이리스트 검색창 */
    .playlistSearchWrapper {
      position: relative;
      margin-bottom: 6px;
    }

    .playlistSearchInput {
      width: 100%;
      height: 22px;
      padding: 0 24px 0 6px;
      border: 1px solid var(--line);
      border-radius: 5px;
      font-size: 10px;
      background: var(--card);
      color: var(--text);
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .playlistSearchInput:focus {
      border-color: var(--active-border);
      box-shadow: 0 0 0 3px rgba(24, 144, 255, 0.1);
    }

    .playlistSearchInput::placeholder {
      color: var(--muted);
    }

    .playlistSearchClear {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      border: none;
      background: #999;
      color: white;
      border-radius: 50%;
      font-size: 11px;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      line-height: 1;
      padding: 0;
    }

    .playlistSearchClear:hover {
      background: #666;
    }

    .playlistSearchWrapper.has-value .playlistSearchClear {
      display: flex;
    }

    /* 검색 결과 카운트 */
    .playlistSearchCount {
      font-size: 10px;
      color: var(--muted);
      text-align: right;
      margin-top: 2px;
      min-height: 14px;
    }

    /* 검색 하이라이트 */
    .trackName .highlight {
      background: #fff3cd;
      color: #856404;
      border-radius: 2px;
      padding: 0 2px;
    }

    :root.dark-mode .trackName .highlight {
      background: #5d4e37;
      color: #ffc107;
    }

    /* 검색 결과 없음 */
    .playlistNoResults {
      padding: 20px;
      text-align: center;
      color: var(--muted);
      font-size: 12px;
    }

    /* Dark Mode */
    :root.dark-mode .playlistSearchInput {
      background: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    :root.dark-mode .playlistSearchInput:focus {
      border-color: #4a9eff;
      box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.2);
    }

    :root.dark-mode .playlistSearchClear {
      background: #666;
    }

    :root.dark-mode .playlistSearchClear:hover {
      background: #888;
    }

    /* 트랙 아이템 선택 스타일 개선 */
    .trackItem .trackInfo {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    /* 선택된 트랙 (selected) */
    .trackItem.selected {
      background: var(--active-bg);
      border-color: var(--active-border);
    }

    .trackItem.selected .trackName {
      color: var(--active-border);
      font-weight: 600;
    }

    /* 활성 트랙 (현재 재생/편집 중) */
    .trackItem.active {
      background: linear-gradient(135deg, var(--active-bg) 0%, rgba(24, 144, 255, 0.15) 100%);
      border-color: var(--active-border);
    }

    .trackItem.active::before {
      content: '▶';
      font-size: 10px;
      color: var(--active-border);
      margin-right: -4px;
    }

    /* 선택 + 활성 둘 다인 경우 */
    .trackItem.active.selected {
      background: linear-gradient(135deg, rgba(24, 144, 255, 0.25) 0%, rgba(24, 144, 255, 0.35) 100%);
      border-color: var(--active-border);
      box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
    }

    /* 호버 시 */
    .trackItem:hover:not(.active):not(.selected) {
      background: var(--hover);
      border-color: var(--line);
    }

    .trackItem.selected:hover {
      background: rgba(24, 144, 255, 0.2);
    }

    /* 다크 모드 */
    :root.dark-mode .trackItem.selected {
      background: #1e3a5f;
      border-color: #4a9eff;
    }

    :root.dark-mode .trackItem.selected .trackName {
      color: #4a9eff;
    }

    :root.dark-mode .trackItem.active {
      background: linear-gradient(135deg, #1e3a5f 0%, #2a4a6f 100%);
    }

    :root.dark-mode .trackItem.active.selected {
      background: linear-gradient(135deg, #2a4a7f 0%, #3a5a8f 100%);
      box-shadow: 0 0 0 2px rgba(74, 158, 255, 0.3);
    }

    /* 선택 카운트 배지 */
    .selectionBadge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      background: var(--active-border);
      color: white;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
    }

    :root.dark-mode .selectionBadge {
      background: #4a9eff;
    }

    /* 사이드바 제목과 작업영역 제목 통일 */
    .sidebar h2 {
      font-size: 14px;
      font-weight: 700;
      margin: 0 0 8px 0;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--line);
    }

    .workspaceHeader h1 {
      font-size: 14px;
      /* 16px → 14px로 변경 */
      font-weight: 700;
      margin: 0;
    }

    /* 작업영역 헤더 아래 구분선 추가 */
    .workspaceHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-shrink: 0;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--line);
      margin-bottom: 8px;
    }

    /* 서브섹션 라벨 */
    .subsectionLabel {
      font-size: 9px;
      font-weight: 500;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin: 2px 0 2px 0;
      padding-left: 8px;
      opacity: 0.7;
    }

    .subsectionLabel:first-child {
      margin-top: 4px;
    }

    /* 얇은 구분선 */
    .divider-thin {
      height: 1px;
      background: var(--line);
      margin: 3px 0;
      opacity: 0.5;
    }

    /* 다크모드 서브섹션 */
    :root.dark-mode .subsectionLabel {
      color: #4a9eff;
    }

    /* 사이드바 스크롤 개선 */
    .sidebar {
      scrollbar-width: thin;
    }

    .sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 3px;
    }

    .sidebar::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    :root.dark-mode .sidebar::-webkit-scrollbar-thumb {
      background: #555;
    }

    :root.dark-mode .sidebar::-webkit-scrollbar-thumb:hover {
      background: #777;
    }

    /* 녹음 레벨 미터 */
    #inputLevelBar {
      transition: width 0.1s ease-out;
    }

    /* 녹음 중 표시 */
    #recordingTimer {
      animation: recordingPulse 1s ease-in-out infinite;
    }

    @keyframes recordingPulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    #btnStopRecord {
      animation: recordingGlow 1s ease-in-out infinite;
    }

    @keyframes recordingGlow {
      0%, 100% { box-shadow: 0 0 5px rgba(244, 67, 54, 0.5); }
      50% { box-shadow: 0 0 15px rgba(244, 67, 54, 0.8); }
    }

    /* 하단 녹음 컨트롤 바 */
    #bottomRecBar {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 10px 16px;
      background: var(--card);
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }
    #bottomRecBar .rec-btn {
      height: 48px;
      min-width: 140px;
      font-size: 15px;
      font-weight: 600;
      border-radius: 8px;
      border: 2px solid var(--border);
      cursor: pointer;
      background: var(--card);
      color: var(--text);
      transition: all 0.15s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    #bottomRecBar .rec-btn:hover { background: var(--hover); }
    #bottomRecBar .rec-btn.primary {
      background: #1a73e8;
      color: #fff;
      border: 2px solid #1565c0;
    }
    #bottomRecBar .rec-btn.primary:hover { opacity: 0.9; }
    #bottomRecBar .rec-btn.danger {
      background: #f44336;
      color: #fff;
      border-color: #d32f2f;
      animation: recordingGlow 1s ease-in-out infinite;
    }
    #bottomRecBar .rec-btn.danger:hover { opacity: 0.9; }
    #bottomRecBar .rec-timer {
      font-size: 20px;
      font-weight: bold;
      color: #f44336;
      min-width: 80px;
      text-align: center;
      animation: recordingPulse 1s ease-in-out infinite;
    }

    /* Select 스타일 */
    .sideSection select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--line);
      font-size: 12px;
      background: var(--card);
      color: var(--text);
      cursor: pointer;
    }

    :root.dark-mode .sideSection select {
      background: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    /* 비활성 버튼 스타일 (미구현 기능) */
    .btn.not-impl {
      opacity: 0.6;
      cursor: not-allowed;
      position: relative;
    }

    .btn.not-impl::after {
      content: '준비중';
      position: absolute;
      top: -8px;
      right: -8px;
      font-size: 8px;
      background: #ff9800;
      color: white;
      padding: 1px 4px;
      border-radius: 4px;
    }

    /* 전사 패널 래퍼 (독립 영역) */
    .transcriptPanelWrapper {
      display: flex;
      flex-direction: column;
      min-height: 60px;
      height: 150px;
      border: 1px solid var(--line);
      border-radius: 6px;
      background: var(--card);
      margin-bottom: 6px;
    }

    .transcriptPanelWrapper .transcriptPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .transcriptPanelWrapper #transcriptList {
      flex: 1;
      overflow-y: auto;
      padding: 4px;
    }

    /* 세로 리사이저 */
    .verticalResizer {
      height: 6px;
      background: var(--line);
      cursor: ns-resize;
      flex-shrink: 0;
      transition: background 0.2s;
    }

    .verticalResizer:hover {
      background: #1890ff;
    }

    .verticalResizer.dragging {
      background: #1890ff;
    }

    :root.dark-mode .verticalResizer {
      background: #404040;
    }

    :root.dark-mode .verticalResizer:hover,
    :root.dark-mode .verticalResizer.dragging {
      background: #4a9eff;
    }

    /* 스크롤바 기본 스타일 (라이트모드) */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #f0f0f0;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }

    ::-webkit-scrollbar-corner {
      background: #f0f0f0;
    }

    /* 다크모드 스크롤바 - 전역 */
    :root.dark-mode *::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    :root.dark-mode *::-webkit-scrollbar-track {
      background: #2d2d2d;
      border-radius: 4px;
    }

    :root.dark-mode *::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }

    :root.dark-mode *::-webkit-scrollbar-thumb:hover {
      background: #666;
    }

    :root.dark-mode *::-webkit-scrollbar-corner {
      background: #2d2d2d;
    }

    .transcriptItem {
      padding: 6px 8px;
      border-bottom: 1px solid var(--line);
      cursor: pointer;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .transcriptItem .transcriptInfo {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .transcriptItem .transcriptDeleteBtn {
      flex-shrink: 0;
      width: 24px;
      height: 24px;
      padding: 0;
      font-size: 12px;
      line-height: 24px;
      text-align: center;
      opacity: 0.6;
    }

    .transcriptItem:hover .transcriptDeleteBtn {
      opacity: 1;
    }

    .transcriptItem .transcriptText {
      margin-left: 16px;
      display: block;
    }

    .speakerGroupSelect {
      width: 50px;
      padding: 2px 4px;
      font-size: 11px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }

    :root.dark-mode .speakerGroupSelect {
      background: #333;
    }

    #waveLevelMeter {
      background: #e0e0e0;
    }
    :root.dark-mode #waveLevelMeter {
      background: #2a2a2a;
    }

    /* ========== 문장별 녹음 패널 (Sentence Panel) ========== */
    #sentencePanel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 220px;
      border-top: 1px solid var(--line);
      background: var(--card);
    }
    .sr-panelHeader {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-bottom: 1px solid var(--line);
      flex-shrink: 0;
      background: var(--bg);
      flex-wrap: wrap;
    }
    .sr-panelHeader .btn { height: 24px; font-size: 10px; padding: 0 8px; }
    .sr-panelHeader select { height: 24px; font-size: 10px; padding: 0 4px; border: 1px solid var(--line); border-radius: 4px; background: var(--card); color: var(--text); }
    .sr-panelBody {
      flex: 1;
      display: flex;
      min-height: 0;
      overflow: hidden;
    }
    .sr-emptyGuide {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 20px;
      color: var(--muted);
    }
    .sr-emptyGuide .icon { font-size: 32px; }
    .sr-emptyGuide .label { font-size: 13px; }
    .sr-emptyGuide .sub { font-size: 11px; }
    .sr-dropZone {
      border: 2px dashed #d9d9d9;
      border-radius: 12px;
      padding: 16px 24px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      background: var(--card);
    }
    .sr-dropZone:hover, .sr-dropZone.dragover {
      border-color: #1890ff;
      background: #e6f7ff;
    }
    .sr-pasteRow {
      display: flex;
      gap: 6px;
      align-items: center;
      width: 100%;
      max-width: 500px;
    }
    .sr-pasteRow textarea {
      flex: 1;
      height: 50px;
      padding: 6px 8px;
      border: 1px solid #d9d9d9;
      border-radius: 6px;
      font-size: 11px;
      resize: none;
      font-family: inherit;
    }
    .sr-sentenceList {
      width: 260px;
      min-width: 160px;
      border-right: none;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .sr-listResizer {
      width: 5px;
      cursor: col-resize;
      background: var(--line);
      flex-shrink: 0;
      transition: background 0.15s;
    }
    .sr-listResizer:hover,
    .sr-listResizer.dragging {
      background: #1890ff;
    }
    .sr-listBody {
      flex: 1;
      overflow-y: auto;
      padding: 2px 0;
    }
    .sr-sentenceItem {
      padding: 4px 8px;
      font-size: 11px;
      line-height: 1.4;
      cursor: pointer;
      border-left: 3px solid transparent;
      display: flex;
      align-items: flex-start;
      gap: 6px;
      transition: background 0.1s;
    }
    .sr-sentenceItem:hover { background: var(--hover); }
    .sr-sentenceItem.active {
      background: var(--active-bg);
      border-left-color: var(--active-border);
    }
    .sr-sentenceItem.recorded { border-left-color: #52c41a; }
    .sr-sentenceItem.active.recorded { border-left-color: var(--active-border); }
    .sr-sentenceIdx {
      font-size: 9px;
      color: var(--muted);
      min-width: 20px;
      text-align: right;
      padding-top: 1px;
      flex-shrink: 0;
    }
    .sr-sentenceText { flex: 1; word-break: break-word; }
    .sr-sentenceMark {
      font-size: 9px;
      padding: 0 4px;
      border-radius: 6px;
      flex-shrink: 0;
    }
    .sr-mark-OK { background: #e6fffb; color: #13c2c2; }
    .sr-mark-REDO { background: #fff1f0; color: #f5222d; }
    .sr-mark-SKIP { background: #fffbe6; color: #faad14; }
    .sr-mark-STAR { background: #f9f0ff; color: #722ed1; }
    .sr-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 12px 20px;
      gap: 8px;
      overflow-y: auto;
      min-width: 0;
    }
    .sr-currentSentence {
      font-size: 20px;
      font-weight: 600;
      color: var(--text);
      text-align: center;
      line-height: 1.5;
      max-width: 600px;
      padding: 16px 24px;
      border-radius: 12px;
      background: var(--bg);
      border: 2px solid var(--line);
      word-break: break-word;
      width: 100%;
    }
    .sr-currentSentence.recording {
      border-color: #f5222d;
      box-shadow: 0 0 0 3px rgba(245,34,45,0.1);
      animation: sr-pulse 1.5s infinite;
    }
    @keyframes sr-pulse {
      0%, 100% { box-shadow: 0 0 0 3px rgba(245,34,45,0.1); }
      50% { box-shadow: 0 0 0 6px rgba(245,34,45,0.2); }
    }
    .sr-statusRow {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
    }
    .sr-recTime {
      font-size: 18px;
      font-weight: 700;
      font-family: 'Courier New', monospace;
      color: var(--text);
    }
    .sr-recTime.rec { color: #f5222d; }
    .sr-levelMeter {
      width: 120px;
      height: 6px;
      background: #e8e8e8;
      border-radius: 3px;
      overflow: hidden;
    }
    .sr-levelFill {
      height: 100%;
      background: linear-gradient(90deg, #52c41a 0%, #faad14 70%, #f5222d 100%);
      transition: width 0.05s;
      border-radius: 3px;
    }
    .sr-controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .sr-controls .btn {
      height: 30px;
      font-size: 11px;
      padding: 0 12px;
      border-radius: 8px;
      font-weight: 600;
    }
    .sr-controls .btn.rec-start {
      background: #f5222d; color: #fff; border-color: #cf1322;
    }
    .sr-controls .btn.rec-start:hover:not(:disabled) { background: #cf1322; }
    .sr-controls .btn.rec-next {
      background: #1890ff; color: #fff; border-color: #096dd9;
    }
    .sr-controls .btn.rec-next:hover:not(:disabled) { background: #096dd9; }
    .sr-shortcuts {
      font-size: 10px;
      color: var(--muted);
      text-align: center;
      line-height: 1.6;
    }
    .sr-shortcuts kbd {
      display: inline-block;
      padding: 0 4px;
      background: #f0f0f0;
      border: 1px solid #d9d9d9;
      border-radius: 3px;
      font-family: monospace;
      font-size: 10px;
    }
    .sr-progressBar {
      width: 80px;
      height: 4px;
      background: var(--line);
      border-radius: 2px;
      overflow: hidden;
      display: inline-block;
      vertical-align: middle;
    }
    .sr-progressFill {
      height: 100%;
      background: #1890ff;
      transition: width 0.3s;
      border-radius: 2px;
    }
    :root.dark-mode .sr-currentSentence { background: #252525; border-color: var(--line); }
    :root.dark-mode .sr-dropZone { border-color: #555; }
    :root.dark-mode .sr-dropZone:hover, :root.dark-mode .sr-dropZone.dragover {
      border-color: #4a9eff; background: #1e3a5f;
    }
    :root.dark-mode .sr-pasteRow textarea {
      background: #2d2d2d; color: #e0e0e0; border-color: #555;
    }
    :root.dark-mode .sr-shortcuts kbd {
      background: #3a3a3a; border-color: #555; color: #e0e0e0;
    }
    :root.dark-mode .sr-levelMeter { background: #3a3a3a; }


    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="topbar">
        <div>
          <div class="brand"> EasyRec-Sentence</div>
        </div>
        <div class="topright">
          <div class="muted" id="whoLine" style="font-size: 10px; display:none;"></div>
          <button class="btn" id="btnLogoutTop" style="display:none">로그아웃</button>
          <span style="font-size:10px; color:var(--muted); letter-spacing:0.5px; font-weight:600;">PREMAN</span>
        </div>
      </div>
      <div id="pageLogin" class="center">
        <div class="card loginCard">
          <div class="loginTitle">EasyRec-Sentence</div>
          <div class="loginSub" id="bootLine">System Ready</div>
          <div class="stack" style="margin-top:12px">
            <div>
              <label class="small">ID</label>
              <input id="loginId" type="text" autocomplete="username" />
              <label class="small" style="margin-top:10px">PW</label>
              <input id="loginPw" type="password" autocomplete="current-password" />
            </div>
          </div>
          <div class="loginActions">
            <button class="btn primary" id="btnLogin">로그인</button>
            <span class="pill" id="loginStatus">auth: -</span>
          </div>
        </div>
      </div>
      <div id="pageEditor" style="display:none; height: calc(100vh - 40px);">
        <div class="editorWrap" id="editorWrap">
          <!-- ✅ 사이드바 열기 버튼 (사이드바 바깥, 접힘 시만 보임) -->
          <button class="sidebarToggleOpen" id="btnToggleSidebarOpen" title="사이드바 열기">
            <svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
              <rect x="1" y="1" width="12" height="12" rx="2"/>
              <line x1="5" y1="1" x2="5" y2="13"/>
            </svg>
          </button>
          <div class="sidebar" id="sidebar">
            <!-- ========== 녹음 ========== -->
            <div class="sideSection" id="recordSection">
              <div class="stack" style="gap:4px">
                  <!-- 입력 장치 (최상단) -->
                  <div style="display:flex; align-items:center; justify-content:space-between;">
                    <div class="subsectionLabel" style="margin:0;">입력 장치</div>
                    <button class="sidebarToggle" id="btnToggleSidebar" title="사이드바 닫기">
                      <svg id="sidebarToggleIcon" width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                        <rect x="1" y="1" width="12" height="12" rx="2"/>
                        <line x1="5" y1="1" x2="5" y2="13"/>
                      </svg>
                    </button>
                  </div>
                  <div style="display:flex; gap:4px; margin-bottom:4px;">
                    <select id="selectAudioInput" style="flex:1; padding:4px; font-size:11px;">
                      <option value="default">기본 마이크</option>
                    </select>
                    <button class="btn" id="btnMicConnect" style="font-size:10px; padding:0 6px; white-space:nowrap;" title="마이크 권한 요청 및 장치 목록 갱신">🎤 연결</button>
                  </div>
                  <div id="recSettingSummary" style="font-size:10px; color:#aaa; text-align:right; margin-bottom:2px;">48kHz / 16bit / Mono</div>
                  <div class="divider-thin"></div>
                  <!-- 녹음 모드 -->
                  <div class="subsectionLabel">녹음 모드</div>
                  <div id="recordModeSelector" style="display:flex; flex-direction:column; gap:4px;">
                    <label class="record-mode-card active" id="cardRecordNew" style="display:flex; align-items:flex-start; gap:8px; padding:8px 10px; border:1px solid #4a90d9; border-radius:8px; cursor:pointer; background:#f0f7ff; color:#1a56db; transition:all 0.15s;">
                      <input type="radio" name="recordMode" id="chkRecordNewTrack" value="new" checked style="margin-top:2px;">
                      <div>
                        <div style="font-size:12px; font-weight:600;">새 트랙으로 녹음</div>
                        <div style="font-size:10px; color:#888; margin-top:2px;">별도의 새 트랙에 녹음합니다</div>
                      </div>
                    </label>
                    <label class="record-mode-card" id="cardRecordContinue" style="display:flex; align-items:flex-start; gap:8px; padding:8px 10px; border:1px solid #d9d9d9; border-radius:8px; cursor:pointer; transition:all 0.15s;">
                      <input type="radio" name="recordMode" id="chkRecordContinue" value="continue" style="margin-top:2px;">
                      <div>
                        <div style="font-size:12px; font-weight:600;">선택 음원에 이어서 녹음</div>
                        <div style="font-size:10px; color:#888; margin-top:2px;">선택된 음원 뒤에 이어서 녹음합니다</div>
                      </div>
                    </label>
                  </div>
                  <!-- 타이머 + 버튼 -->
                  <div id="recordingTimer" style="text-align:center; font-size:14px; font-weight:bold; color:#f44336; margin-top:10px; margin-bottom:10px; min-height:20px;">
                    <span id="recordingTime">00:00</span>
                    <span id="recordingStatus"></span>
                  </div>
                  <div id="recordingControls" style="display:none; gap:6px; margin-bottom:10px;">
                    <div style="display:flex; gap:6px;">
                      <button class="btn" id="btnPauseRecord" style="flex:1">⏸ 일시정지 (R)</button>
                      <button class="btn danger" id="btnStopRecord" style="flex:1; background:#f44336; color:#fff; border-color:#d32f2f;">⬛ 정지 (P)</button>
                    </div>
                  </div>
                  <button class="btn primary" id="btnStartRecord" style="width:100%; height:36px; font-size:13px; font-weight:600; background:#1a73e8; color:#fff; border:2px solid #1565c0;">🔴 녹음 시작 (R)</button>
                  <!-- 플러시/백업 상태 표시 -->
                  <div id="backupStatusBar" style="font-size:10px; color:#888; text-align:center; padding:2px 0; min-height:16px;">
                    <span id="backupStatusText"></span>
                  </div>
                  </div>
            </div>
            <!-- ========== 파일 관리 ========== -->
            <div class="sideSection" id="trackManageSection">
              <div class="stack" style="gap:4px">
                <div class="sideLabel" style="cursor:pointer; user-select:none; margin-bottom:4px;" onclick="toggleTrackManage()">
                  파일 관리 <span id="trackManageArrow" style="float:right; font-size:10px;">▶</span>
                </div>
                <div id="trackManageContent" style="display:none">
                  <input type="file" id="fileInput" accept="audio/*" multiple style="display:none" />
                  <div style="display:flex; align-items:center; gap:6px;">
                    <button class="btn" id="btnImport" style="height:24px; font-size:11px; padding:0 10px;">📂 추가</button>
                    <div id="playlistSearchCount" class="playlistSearchCount" style="font-size:10px; color:var(--muted); flex:1;"></div>
                  </div>
                  <div id="playlist" class="trackList"></div>
                  <div id="selectionActions" class="btnGroup small" style="display:none;">
                    <button class="btn" id="btnSelectAll" title="Ctrl+A">전체</button>
                    <button class="btn" id="btnDeselectAll" disabled title="ESC">해제</button>
                    <button class="btn danger" id="btnDeleteTracks" disabled title="Delete">제외</button>
                  </div>
                  <button class="btn primary" id="btnSaveSelected" style="width:100%; margin-top: 6px; height:24px; font-size:10px;">💾 선택된 데이터 저장</button>
                  <div id="saveStatus" class="text-xs-muted">
                    ※ 1개 선택 시 WAV, 2개 이상 선택 시 ZIP으로 저장됩니다.
                  </div>
                  <div class="divider-thin"></div>
                  <label class="btn-check">
                    <input type="checkbox" id="chkAutoSave"> 녹음 정지 시 자동 저장 (WAV)
                  </label>
                </div>
              </div>
            </div>
            <!-- ========== 녹음 설정 ========== -->
            <div class="sideSection" id="recSettingsSection">
              <div class="sideLabel" id="recSettingsToggle" style="cursor:pointer; user-select:none; margin-bottom:4px;" onclick="toggleRecSettings()">
                녹음 설정 <span id="recSettingsArrow" style="float:right; font-size:10px;">▶</span>
              </div>
              <div id="recSettingsContent" style="display:none">
                  <div style="display:flex; align-items:center; gap:6px;">
                    <label class="btn-check" style="margin:0; white-space:nowrap;" title="녹음 중 자신의 목소리를 실시간으로 들을 수 있습니다">
                    <input type="checkbox" id="chkInputMonitor"> 모니터링
                    </label>
                    <div id="inputLevelMeter" style="flex:1; height:8px; background:#eee; border-radius:3px; overflow:hidden;">
                      <div id="inputLevelBar" style="width:0%; height:100%; background:linear-gradient(to right, #4caf50, #ffeb3b, #f44336);"></div>
                    </div>
                    <span id="inputLevelValue" style="font-size:9px; color:#999; min-width:40px; text-align:right;">-∞ dB</span>
                  </div>
                  <div id="monitorVolumeWrap" style="display:none; margin-top:6px;">
                    <div style="display:flex; align-items:center; gap:6px;">
                      <label style="font-size:10px; color:#888; min-width:32px;">🔊</label>
                      <input type="range" id="monitorVolume" min="0" max="150" value="100" style="flex:1; height:4px;">
                      <span id="monitorVolumeValue" style="font-size:10px; color:#888; min-width:32px; text-align:right;">100%</span>
                    </div>
                  </div>
                  <div style="display:flex; align-items:center; gap:6px; font-size:11px; margin-top:4px;">
                    <label class="btn-check" style="white-space:nowrap;">
                      <input type="checkbox" id="chkTargetDb" checked> 적정볼륨
                    </label>
                    <input type="range" id="sliderTargetDb" min="-24" max="-1" step="1" value="-7" style="flex:1; height:4px;">
                    <span id="labelTargetDb" style="min-width:36px; text-align:right; color:#4caf50; font-weight:600;">-7 dB</span>
                  </div>
                  <div class="divider-thin"></div>
                  <div style="display:flex; align-items:center; gap:6px; margin-bottom:2px;">
                    <label style="font-size:11px; color:#888; min-width:56px;">샘플레이트</label>
                    <select id="selectSampleRate" style="flex:1; padding:4px; font-size:11px;">
                    <option value="8000">8 kHz</option>
                    <option value="11025">11.025 kHz</option>
                    <option value="16000">16 kHz</option>
                    <option value="22050">22.05 kHz</option>
                    <option value="32000">32 kHz</option>
                    <option value="44100">44.1 kHz</option>
                    <option value="48000" selected>48 kHz</option>
                    <option value="88200">88.2 kHz</option>
                    <option value="96000">96 kHz</option>
                    <option value="176400">176.4 kHz</option>
                    <option value="192000">192 kHz</option>
                    </select>
                  </div>
                  <div style="display:flex; align-items:center; gap:6px; margin-bottom:2px;">
                    <label style="font-size:11px; color:#888; min-width:56px;">비트</label>
                    <select id="selectBitDepth" style="flex:1; padding:4px; font-size:11px;">
                    <option value="16" selected>16-bit</option>
                    <option value="24">24-bit</option>
                    <option value="32">32-bit float</option>
                    </select>
                  </div>
                  <div style="display:flex; align-items:center; gap:6px; margin-bottom:2px;">
                    <label style="font-size:11px; color:#888; min-width:56px;">채널</label>
                    <select id="selectChannels" style="flex:1; padding:4px; font-size:11px;">
                    <option value="1" selected>모노 (1ch)</option>
                    <option value="2">스테레오 (2ch)</option>
                    </select>
                  </div>
              </div>
            </div>
            <!-- ========== 내보내기 ========== -->
            <div class="sideSection collapsible collapsed" id="exportSection">
              <div class="sideLabel" onclick="toggleSection('exportSection')">내보내기</div>
              <div class="collapsibleContent collapsed" id="exportContent">
                <div class="stack" style="gap:2px">
                  <button class="btn" id="btnExportWAV" style="width:100%">WAV로 내보내기</button>
                  <button class="btn" id="btnExportMP3" style="width:100%">MP3로 내보내기</button>
                </div>
              </div>
            </div>
            <!-- ========== 편집 ========== -->
            <div class="sideSection collapsible collapsed" id="editSection">
              <div class="sideLabel" onclick="toggleSection('editSection')">음원 편집</div>
              <div class="collapsibleContent collapsed" id="editContent">
                <div class="stack" style="gap:2px">
                  <div class="subsectionLabel">히스토리</div>
                  <div class="btnGroup" style="width:100%">
                    <button class="btn" id="btnUndo" disabled style="flex:1" title="Ctrl+Z">실행취소</button>
                    <button class="btn" id="btnRedo" disabled style="flex:1" title="Ctrl+Y">다시실행</button>
                  </div>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">클립보드</div>
                  <div class="btnGroup" style="width:100%">
                    <button class="btn" id="btnCut" style="flex:1" title="Ctrl+X">잘라내기</button>
                    <button class="btn" id="btnCopy" style="flex:1" title="Ctrl+C">복사</button>
                    <button class="btn" id="btnPaste" style="flex:1" title="Ctrl+V">붙여넣기</button>
                  </div>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">구간 편집</div>
                  <button class="btn" id="btnDeleteRegion" style="width:100%" title="Delete">선택 구간 삭제</button>
                  <button class="btn" id="btnSilenceRegion" style="width:100%">선택 구간 무음화</button>
                  <button class="btn" id="btnReverseRegion" style="width:100%">선택 구간 반전</button>
                  <button class="btn" id="btnRepeatRegion" style="width:100%">선택 구간 반복</button>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">고급 편집</div>
                  <button class="btn" id="btnTrimToSelection" style="width:100%">선택 구간만 남기기</button>
                  <button class="btn" id="btnSplitAtCursor" style="width:100%">커서 위치에서 분할</button>
                  <button class="btn" id="btnDuplicate" style="width:100%" title="Ctrl+D">선택 구간 복제</button>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">스냅 옵션</div>
                  <label class="btn-check">
                  <input type="checkbox" id="chkSnapToZero"> 제로 크로싱에 스냅
                  </label>
                  <label class="btn-check">
                  <input type="checkbox" id="chkRippleEdit" checked> 리플 편집 모드
                  </label>
                </div>
              </div>
            </div>
            <!-- ========== 13. 설정 (확장) ========== -->
            <div class="sideSection collapsible collapsed" id="settingsSection">
              <div class="sideLabel" onclick="toggleSection('settingsSection')">화면 설정</div>
              <div class="collapsibleContent collapsed" id="settingsContent">
                <div class="stack" style="gap:2px">
                  <div class="subsectionLabel">표시 옵션</div>
                  <label class="btn-check">
                  <input type="checkbox" id="chkAutoScroll"> 오토스크롤
                  </label>
                  <label class="btn-check">
                  <input type="checkbox" id="chkDarkMode"> 다크모드
                  </label>
                  <div class="sliderRow">
                    <span class="sliderRowLabel">파형 크기</span>
                    <input type="range" id="sliderWaveScale" min="10" max="200" step="5" value="90">
                    <span class="sliderRowValue" id="labelWaveScale">0.90x</span>
                  </div>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">파형 색상</div>
                  <div class="sliderRow">
                    <span class="sliderRowLabel">파형 색상</span>
                    <select id="selectWaveColor" style="flex:1; padding:4px; border-radius:4px; border:1px solid var(--line); background:var(--card); color:var(--text);">
                    <option value="#4a90d9">파랑 (기본)</option>
                    <option value="#28a745">초록</option>
                    <option value="#9b59b6">보라</option>
                    <option value="#e67e22">주황</option>
                    <option value="#e74c3c">빨강</option>
                    <option value="#1abc9c">청록</option>
                    <option value="#95a5a6">회색</option>
                    </select>
                  </div>
                  <div class="sliderRow">
                    <span class="sliderRowLabel">선택 영역 색상</span>
                    <select id="selectSelectionColor" style="flex:1; padding:4px; border-radius:4px; border:1px solid var(--line); background:var(--card); color:var(--text);">
                    <option value="rgba(0,123,255,0.25)">파랑 (기본)</option>
                    <option value="rgba(40,167,69,0.25)">초록</option>
                    <option value="rgba(155,89,182,0.25)">보라</option>
                    <option value="rgba(230,126,34,0.25)">주황</option>
                    <option value="rgba(231,76,60,0.25)">빨강</option>
                    <option value="rgba(241,196,15,0.25)">노랑</option>
                    </select>
                  </div>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">재생 옵션</div>
                  <div class="sliderRow">
                    <span class="sliderRowLabel">기본 재생 속도</span>
                    <input type="range" id="sliderDefaultSpeed" min="0.5" max="2" step="0.1" value="1">
                    <span class="sliderRowValue" id="labelDefaultSpeed">1.0x</span>
                  </div>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">데이터 관리</div>
                  <button class="btn" id="btnShowShortcuts" style="width:100%;">⌨️ 단축키 보기</button>
                  <button class="btn" id="btnResetSettings" style="width:100%">🔄 설정 초기화</button>
                  <button class="btn danger" id="btnClearCache" style="width:100%">🗑️ 캐시 삭제</button>
                </div>
              </div>
            </div>
            <!-- ========== 14. 도움 ========== -->
            <div class="sideSection collapsible collapsed" id="helpSection">
              <div class="sideLabel" onclick="toggleSection('helpSection')">도움</div>
              <div class="collapsibleContent collapsed" id="helpContent">
                <div class="stack" style="gap:10px; font-size:12px; line-height:1.7; color:var(--text);">
                  <div style="padding:12px; background:linear-gradient(135deg, #e3f2fd, #bbdefb); border-radius:8px;">
                    <div style="font-weight:700; font-size:14px; margin-bottom:6px;">🎧 EasyRec-Sentence</div>
                    <div style="color:#555; line-height:1.6;">
                      웹 기반 한국어 오디오 녹음/편집기입니다.<br>
                      설치 없이 브라우저에서 오디오 녹음, 편집,
                      다양한 포맷 내보내기를 수행할 수 있습니다.
                    </div>
                  </div>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">주요 기능</div>
                  <div style="padding:0 4px; color:var(--muted); line-height:1.8;">
                    🎙️ 실시간 녹음 (다양한 설정)<br>
                    💾 내보내기 (WAV, MP3)<br>
                    ✂️ 오디오 편집 (잘라내기/복사/붙이기 등)
                  </div>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">프리먼 소개</div>
                  <div style="padding:10px; background:var(--hover); border-radius:8px; line-height:1.7;">
                    <strong>PremanData</strong>는 데이터 기반 솔루션을 제공하는
                    기업으로, AI 오디오 처리, 데이터 관리, 자동화 도구를 개발하고 있습니다.
                    EasyRec-Sentence는 Preman의 오디오 녹음/편집 솔루션입니다.
                  </div>
                  <div class="divider-thin"></div>
                  <div class="subsectionLabel">연락처</div>
                  <div style="padding:10px; background:var(--hover); border-radius:8px;">
                    <div style="margin-bottom:6px;">
                      🌐 <a href="https://www.premandata.com" target="_blank"
                        style="color:var(--active-border); text-decoration:none;">www.premandata.com</a>
                    </div>
                    <div>
                      ✉️ <a href="/cdn-cgi/l/email-protection#6f0c00011b0e0c1b2f1f1d0a020e010b0e1b0e410c0002" style="color:var(--active-border); text-decoration:none;"><span class="__cf_email__" data-cfemail="c0a3afaeb4a1a3b480b0b2a5ada1aea4a1b4a1eea3afad">[email&#160;protected]</span></a>
                    </div>
                  </div>
                  <div class="divider-thin"></div>
                  <div style="text-align:center; padding:8px 0;">
                    <span class="chip" style="background:linear-gradient(135deg, #1e3a5f, #2d5a8e); color:#7ec8ff; border:1px solid #3a7bd5; font-size:10px; padding:4px 12px;">
                      EasyRec-Sentence v1.0.0
                    </span>
                    <div style="margin-top:6px; font-size:10px; color:var(--muted);">
                      © 2026 Preman Data. All rights reserved.
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="workspace">
            <div id="fileChip" style="display:none;"></div>
            <div class="toolbar">
              <button class="btn primary" id="btnPlay" title="재생">▶️</button>
              <button class="btn" id="btnPause" style="display:none" title="일시정지">⏸️</button>
              <button class="btn" id="btnStop" title="정지">⏹️</button>
              <button class="btn" id="btnLoop" title="반복 재생">🔁</button>
              <button class="btn" id="btnZoomIn" title="확대"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="7" cy="7" r="5"/><line x1="11" y1="11" x2="14" y2="14"/><line x1="5" y1="7" x2="9" y2="7"/><line x1="7" y1="5" x2="7" y2="9"/></svg></button>
              <button class="btn" id="btnZoomOut" title="축소"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="7" cy="7" r="5"/><line x1="11" y1="11" x2="14" y2="14"/><line x1="5" y1="7" x2="9" y2="7"/></svg></button>
              <button class="btn" id="btnZoomFit" title="전체 보기">↔️</button>
              <div style="width:1px; height:18px; background:var(--line); margin:0 1px;"></div>
              <button class="btn" id="btnUndoTop" disabled title="실행취소 (Ctrl+Z)">↩️</button>
              <button class="btn" id="btnRedoTop" disabled title="다시실행 (Ctrl+Y)">↪️</button>
              <div style="width:1px; height:18px; background:var(--line); margin:0 1px;"></div>
              <div class="timeInfoPanel" id="timeInfoPanel">
                <div class="timeInfoGroup">
                  <div class="timeInfoLabel">재생</div>
                  <div class="timeInfoValue" id="timeInfoCurrent">00:00.0</div>
                </div>
                <div class="timeInfoSeparator"></div>
                <div class="timeInfoGroup">
                  <div class="timeInfoLabel">시작</div>
                  <div class="timeInfoValue" id="timeInfoViewStart">00:00.0</div>
                </div>
                <div class="timeInfoGroup">
                  <div class="timeInfoLabel">끝</div>
                  <div class="timeInfoValue" id="timeInfoViewEnd">00:00.0</div>
                </div>
                <div class="timeInfoGroup">
                  <div class="timeInfoLabel">간격</div>
                  <div class="timeInfoValue" id="timeInfoViewDur">00:00.0</div>
                </div>
                <div class="timeInfoSeparator"></div>
                <div class="timeInfoGroup">
                  <div class="timeInfoLabel">구간</div>
                  <div class="timeInfoValue" id="timeInfoSelStart">-</div>
                </div>
                <div class="timeInfoGroup">
                  <div class="timeInfoLabel">끝</div>
                  <div class="timeInfoValue" id="timeInfoSelEnd">-</div>
                </div>
                <div class="timeInfoGroup">
                  <div class="timeInfoLabel">간격</div>
                  <div class="timeInfoValue" id="timeInfoSelDur">-</div>
                </div>
              </div>
              <div class="toolbarSpacer" style="flex:1;"></div>
            </div>
            <div class="minimapWrapper" id="minimapWrapper">
              <canvas id="minimapCanvas"></canvas>
            </div>
            <div class="waveWrapper" id="waveWrapper">
              <div style="display:flex; flex:1; min-height:0;">
                <div class="waveformArea" id="waveContainer" style="flex:1; min-width:0;">
                  <canvas id="waveCanvas"></canvas>
                  <span id="wavePlaceholder">왼쪽 목록에서 파일을 선택하거나 추가하세요</span>
                </div>
                <div id="waveLevelMeter" style="width:6px; background:#2a2a2a; border-radius:3px; margin-left:2px; display:flex; flex-direction:column; justify-content:flex-end; overflow:hidden; position:relative;">
                  <div id="waveLevelBar" style="width:100%; background:linear-gradient(to top, #4caf50, #ffeb3b, #f44336); height:0%;"></div>
                  <div id="wavePeakLine" style="position:absolute; left:0; right:0; height:2px; background:#ff5252; bottom:0%; display:none;"></div>
                  <div id="waveTargetLine" style="position:absolute; left:0; right:0; height:2px; background:#4caf50; bottom:88.3%;"></div>
                </div>
                <div style="width:18px; display:flex; flex-direction:column; justify-content:space-between; padding:2px 0; margin-left:1px;">
                  <span style="font-size:7px; color:#888; line-height:1;">0</span>
                  <span style="font-size:7px; color:#888; line-height:1;">-6</span>
                  <span style="font-size:7px; color:#888; line-height:1;">-12</span>
                  <span style="font-size:7px; color:#888; line-height:1;">-24</span>
                  <span style="font-size:7px; color:#888; line-height:1;">-48</span>
                  <span style="font-size:7px; color:#888; line-height:1;">-∞</span>
                </div>
              </div>
              <div class="timelineScroll" id="timelineScroll">
                <div class="timelineSpacer" id="timelineSpacer"></div>
              </div>
            </div>
            <div class="waveResizer" id="waveResizer"></div>
            <!-- 하단 녹음 컨트롤 바 -->
            <div id="bottomRecBar">
              <span class="rec-timer" id="bottomRecTimer" style="display:none; width:100%;"></span>
              <div id="bottomRecButtons" style="display:flex; align-items:center; justify-content:center; gap:12px;">
                <button class="rec-btn primary" id="bottomBtnStart">🔴 녹음 시작 (R)</button>
                <button class="rec-btn" id="bottomBtnPause" style="display:none; border:2px solid #888;">⏸ 일시정지 (R)</button>
                <button class="rec-btn danger" id="bottomBtnStop" style="display:none;">⬛ 정지 (P)</button>
              </div>
            </div>
            <!-- ========== 문장별 녹음 패널 ========== -->
            <div id="sentencePanel">
              <div class="sr-panelHeader">
                <button class="btn" id="srBtnLoadFile" title="텍스트 파일 불러오기">📄 불러오기</button>
                <input type="file" id="srFileInput" accept=".txt,.text" style="display:none">
                <select id="srSplitMode" title="문장 분리 기준">
                  <option value="newline">줄바꿈</option>
                  <option value="sentence">문장부호</option>
                  <option value="both">둘 다</option>
                </select>
                <span style="width:1px; height:16px; background:var(--line);"></span>
                <span id="srProgressLabel" style="font-size:10px; color:var(--muted);">문서를 불러오세요</span>
                <div class="sr-progressBar" id="srProgressBarWrap" style="display:none;">
                  <div class="sr-progressFill" id="srProgressFill"></div>
                </div>
                <span style="flex:1"></span>
                <button class="btn" id="srBtnDownloadAll" disabled title="WAV + 마커JSON ZIP">💾 통째로</button>
                <button class="btn" id="srBtnDownloadSplit" disabled title="문장별 WAV ZIP">📦 분할</button>
                <span style="width:1px; height:16px; background:var(--line);"></span>
                <div class="sr-controls" id="srControls">
                  <button class="btn rec-start" id="srBtnStartRec" disabled>🔴 녹음</button>
                </div>
              </div>
              <div class="sr-panelBody">
                <div class="sr-emptyGuide" id="srEmptyGuide">
                  <div class="sr-dropZone" id="srDropZone">
                    <div class="icon">📄</div>
                    <div class="label">텍스트 파일을 드래그하거나 클릭하여 불러오기</div>
                    <div class="sub">또는 상단 [📄 불러오기] 버튼 사용</div>
                  </div>
                  <div class="sr-pasteRow">
                    <textarea id="srPasteText" placeholder="텍스트를 붙여넣고 →"></textarea>
                    <button class="btn primary" id="srBtnLoadPaste" style="height:50px; font-size:11px; white-space:nowrap;">적용</button>
                  </div>
                </div>
                <div id="srRecordArea" style="display:none; flex:1;">
                  <div class="sr-sentenceList" id="srSentenceList">
                    <div class="sr-listBody" id="srListBody"></div>
                  </div>
                  <div class="sr-listResizer" id="srListResizer"></div>
                  <!-- 오른쪽: 현재 문장 + 상태 -->
                  <div class="sr-main">
                    <div class="sr-currentSentence" id="srCurrentSentence">문서를 불러와주세요</div>
                    <div class="sr-statusRow">
                      <span id="srRecStatus" style="font-weight:600;">대기</span>
                      <span class="sr-recTime" id="srRecTime">00:00.0</span>
                      <div class="sr-levelMeter"><div class="sr-levelFill" id="srLevelFill" style="width:0%"></div></div>
                    </div>
                    <div class="sr-shortcuts">
                      <kbd>R</kbd> 녹음/재녹음 <kbd>P</kbd> 정지 <kbd>↓</kbd> 다음문장 <kbd>↑</kbd> 이전문장 <kbd>1</kbd>OK <kbd>2</kbd>REDO <kbd>3</kbd>SKIP <kbd>4</kbd>STAR
                    </div>
                  </div>
                </div>
              </div>
            </div>

          </div>
        </div>
      </div>
    </div>
    <div id="customModal" class="modal-overlay">
      <div class="modal-box">
        <div class="modal-title">변경 사항 확인</div>
        <div class="modal-desc" id="modalDesc">선택된 파일 중 변경된 내용이 있습니다.<br>저장하지 않고 제외하면 변경 사항이 손실됩니다.</div>
        <div class="modal-actions">
          <button class="btn primary" id="btnModalSave">저장 후 리스트에서 제외</button>
          <button class="btn danger" id="btnModalRemove">저장하지 않고 리스트에서 제외</button>
          <button class="btn" id="btnModalCancel">닫기(취소)</button>
        </div>
      </div>
    </div>
    <div id="shortcutModal" class="modal-overlay">
      <div class="modal-box" style="max-width:1100px; width:95vw; max-height:85vh; overflow-y:auto;">
        <div class="modal-title">⌨️ 단축키 목록</div>
        <div style="display:grid; grid-template-columns:repeat(2, 1fr); gap:10px; font-size:11px;">
          <!-- 1행: 재생, 녹음 -->
          <div style="background:var(--bg); padding:10px; border-radius:8px;">
            <div style="font-weight:700; margin-bottom:6px; color:var(--text);">▶️ 재생</div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">Space</span>
              <span style="white-space:nowrap;">재생 / 일시정지</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0;">
              <span style="color:var(--muted); white-space:nowrap;">Esc</span>
              <span style="white-space:nowrap;">정지 및 처음으로</span>
            </div>
          </div>
          <div style="background:var(--bg); padding:10px; border-radius:8px;">
            <div style="font-weight:700; margin-bottom:6px; color:var(--text);">🎙️ 녹음</div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">R</span>
              <span style="white-space:nowrap;">녹음 시작 / 일시정지</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0;">
              <span style="color:var(--muted); white-space:nowrap;">P</span>
              <span style="white-space:nowrap;">녹음 정지</span>
            </div>
          </div>
          <div style="background:var(--bg); padding:10px; border-radius:8px;">
            <div style="font-weight:700; margin-bottom:6px; color:var(--text);">✂️ 편집</div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">Ctrl+Z / Y</span>
              <span style="white-space:nowrap;">취소 / 다시실행</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">Ctrl+C / X / V</span>
              <span style="white-space:nowrap;">복사 / 잘라내기 / 붙여넣기</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">Ctrl+D</span>
              <span style="white-space:nowrap;">구간 복제</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">Delete</span>
              <span style="white-space:nowrap;">구간 삭제</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0;">
              <span style="color:var(--muted); white-space:nowrap;">Ctrl+S</span>
              <span style="white-space:nowrap;">파일 저장</span>
            </div>
          </div>
          </div>
          <!-- 2행: 선택/탐색, 확대/축소 -->
          <div style="background:var(--bg); padding:10px; border-radius:8px;">
            <div style="font-weight:700; margin-bottom:6px; color:var(--text);">🖱️ 선택 / 탐색</div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">클릭</span>
              <span style="white-space:nowrap;">커서 위치 지정</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">드래그</span>
              <span style="white-space:nowrap;">구간 선택</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">Shift+클릭</span>
              <span style="white-space:nowrap;">구간 확장</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">← / →</span>
              <span style="white-space:nowrap;">좌우 이동</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0;">
              <span style="color:var(--muted); white-space:nowrap;">↑ / ↓</span>
              <span style="white-space:nowrap;">리스트 항목 이동</span>
            </div>
          </div>
          <div style="background:var(--bg); padding:10px; border-radius:8px;">
            <div style="font-weight:700; margin-bottom:6px; color:var(--text);">🔍 확대 / 축소</div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">+ / -</span>
              <span style="white-space:nowrap;">확대 / 축소</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0; border-bottom:1px solid var(--line);">
              <span style="color:var(--muted); white-space:nowrap;">마우스 휠</span>
              <span style="white-space:nowrap;">확대 / 축소</span>
            </div>
            <div style="display:flex; justify-content:space-between; gap:12px; padding:3px 0;">
              <span style="color:var(--muted); white-space:nowrap;">Shift+휠</span>
              <span style="white-space:nowrap;">좌우 스크롤</span>
            </div>
          </div>
        </div>
        <div style="margin-top:10px; font-size:10px; color:var(--muted); text-align:center;">
          ※ Mac에서는 Ctrl 대신 Cmd를 사용합니다.
        </div>
        <div class="modal-actions" style="margin-top:12px;">
          <button class="btn primary" id="btnCloseShortcuts">닫기</button>
        </div>
      </div>
    </div>
    <div id="toast">메시지</div>
    <div id="centerToast"></div>
    <!-- 트랙 이름 툴팁 -->
    <div id="trackTooltip" class="track-tooltip">
      <div class="tooltip-name"></div>
      <div class="tooltip-info"></div>
    </div>
    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
    document.body.classList.add('ready');
    // ========== EasyRec-Sentence: Stub functions (removed features) ==========
    function renderSegmentList() {}
    function renderMarkerList() {}
    function addSegment() {}
    function addMarker() {}
    function deleteSegment() {}
    function deleteMarker() {}
    function jumpToSegment() {}
    function jumpToMarker() {}
    function findSegmentAtTime() { return null; }
    function selectSegmentAtTime() {}
    function changeSegmentGroup() {}
    function sortSegments() {}
    function sortMarkers() {}
    function moveSegmentSelection() {}
    function moveMarkerSelection() {}
    function moveTranscriptSelection() {}
    function selectTranscriptByIndex() {}
    function updateTranscriptSelectedRow() {}
    function selectSegmentByIndex() {}
    function selectMarkerByIndex() {}
    function updateSelectedMarkerRow() {}
    function makeSegmentEditable() {}
    function makeSegmentEditableAndJump() {}
    function jumpToSegmentAndScroll() {}
    function makeMarkerEditable() {}
    function deleteSegmentsInSelection() {}
    function deleteAllSegments() {}
    function deleteMarkersInSelection() {}
    function deleteAllMarkers() {}
    function saveJSON() {}
    function exportCSV() {}
    function saveMarkerJSON() {}
    function exportMarkerCSV() {}
    function initAutoSegmentModal() {}
    function addTranscriptToSelection() {}
    function addAllTranscripts() {}
    function renderTranscriptPanel() {}
    function clearAllTranscripts() {}
    function exportSRT() {}
    function exportVTT() {}
    function exportTranscriptTXT() {}
    function initListResizer() {}
    function initVerticalResizers() {}
    function swapListContainers() {}
    function updateListLayout() {}
    function resetListLayout() {}
    function updateListFocus() {}
    function toggleTranscriptPanel() {}
    function initVolumeGainModals() {}
    function initGenerateModals() {}
    function initEffectsModals() {}
    function showSpeedModal() {}
    function showPitchModal() {}
    function showDeleteSegmentsModal() {}
    function showDeleteAllSegmentsModal() {}
    function showDeleteMarkersModal() {}
    function showDeleteAllMarkersModal() {}
    function encodeMetadataChunks() { return new Uint8Array(0); }
    function getSpeakerColorIndex() { return 0; }
    function executeSegmentDeletion() {}
    function executeAllSegmentDeletion() {}
    function executeMarkerDeletion() {}
    function executeAllMarkerDeletion() {}
    function startInlineEdit() {}
    function parseWavMetadata() { return {}; }
    // ========== EasyRec-Sentence: Stubs end ==========

    function renderPlaylist() {
      const listEl = $('playlist');
      if (!listEl) return;
      listEl.innerHTML = '';
      // ✅ 플레이리스트를 포커스 가능하게 설정
      listEl.setAttribute('tabindex', '0');
      if ($('selectionActions')) $('selectionActions').style.display = tracks.length > 0 ? 'flex' : 'none';
      const selectedCount = tracks.filter(t => t.selected).length;
      if ($('btnDeselectAll')) $('btnDeselectAll').disabled = selectedCount === 0;
      if ($('btnDeleteTracks')) $('btnDeleteTracks').disabled = selectedCount === 0;
      // ✅ 검색 필터 적용
      const query = playlistSearchQuery.toLowerCase().trim();
      const filteredTracks = query ?
        tracks.map((track, index) => ({
          track,
          index
        })).filter(item =>
          item.track.name.toLowerCase().includes(query)
        ) :
        tracks.map((track, index) => ({
          track,
          index
        }));
      // ✅ 검색 결과 카운트 + 선택 개수 표시
      const countEl = $('playlistSearchCount');
      if (countEl) {
        const selectedCount = tracks.filter(t => t.selected).length;
        if (query) {
          // 검색 중
          if (selectedCount > 0) {
            countEl.textContent = `${selectedCount}개 선택, ${filteredTracks.length}/${tracks.length}개 표시`;
          } else {
            countEl.textContent = `${filteredTracks.length}/${tracks.length}개 표시`;
          }
        } else {
          // 일반 상태
          if (selectedCount > 0) {
            countEl.textContent = `${selectedCount}개 선택, 총 ${tracks.length}개`;
          } else {
            countEl.textContent = tracks.length > 0 ? `총 ${tracks.length}개` : '';
          }
        }
      }
      // ✅ 검색 결과 없음
      if (filteredTracks.length === 0 && tracks.length > 0) {
        listEl.innerHTML = `<div class="playlistNoResults">🔍 "${playlistSearchQuery}"에 대한 검색 결과가 없습니다</div>`;
        return;
      }
      filteredTracks.forEach(({
        track,
        index
      }) => {
        const div = document.createElement('div');
        div.className = 'trackItem';
        div.dataset.index = index; // 원본 인덱스 저장
        if (index === activeTrackIndex) div.classList.add('active');
        if (track.selected) div.classList.add('selected');
        const dirtyMark = track.isDirty ? '* ' : '';
        const displayName = dirtyMark + track.name;
        // ✅ 검색어 하이라이트
        const highlightedName = query ?
          highlightSearchMatch(displayName, query) :
          displayName;
        div.innerHTML = `
    <div class="trackInfo">
      <div class="trackName" data-fullname="${track.name}" data-duration="${track.duration.toFixed(1)}">
        <span class="marquee-inner">${highlightedName}</span>
      </div>
      <div class="trackDur">${track.duration.toFixed(1)}s</div>
    </div>`;
        // ✅ 전체 trackItem 클릭 이벤트 (체크박스 대신)
        div.addEventListener('click', (e) => {
          handleTrackClick(e, index);
        });
        // 마퀴 및 툴팁 이벤트 등록
        const trackNameEl = div.querySelector('.trackName');
        const marqueeInner = div.querySelector('.marquee-inner');
        div.addEventListener('mouseenter', (e) => {
          setupMarquee(trackNameEl, marqueeInner);
          showTrackTooltip(e, track);
        });
        div.addEventListener('mousemove', (e) => {
          updateTooltipPosition(e);
        });
        div.addEventListener('mouseleave', () => {
          resetMarquee(marqueeInner);
          hideTrackTooltip();
        });
        listEl.appendChild(div);
      });
    }
    // ✅ 검색어 하이라이트 함수
    function highlightSearchMatch(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
      return text.replace(regex, '<span class="highlight">$1</span>');
    }
    // ✅ 정규식 특수문자 이스케이프
    function escapeRegex(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    // ✅ 트랙 클릭 핸들러 (Shift/Ctrl 다중 선택 지원)
    function handleTrackClick(event, index) {
      event.stopPropagation();
      if (event.shiftKey && activeTrackIndex >= 0) {
        // ✅ Shift+클릭: 범위 선택
        selectTrackRange(multiSelectAnchor >= 0 ? multiSelectAnchor : activeTrackIndex, index);
      } else if (event.ctrlKey || event.metaKey) {
        // ✅ Ctrl+클릭: 토글 선택
        tracks[index].selected = !tracks[index].selected;
        // 앵커 업데이트 (선택된 경우)
        if (tracks[index].selected) {
          multiSelectAnchor = index;
        }
        // 활성 트랙도 변경
        activeTrackIndex = index;
        loadTrackToEditor(index);
        renderPlaylist();
        updateInfoChip();
      } else {
        // ✅ 일반 클릭: 기존 선택 해제 + 단일 선택
        tracks.forEach(t => t.selected = false);
        tracks[index].selected = true;
        multiSelectAnchor = index;
        selectTrack(index);
      }
    }
    // ✅ 범위 선택 함수
    function selectTrackRange(startIndex, endIndex) {
      const minIdx = Math.min(startIndex, endIndex);
      const maxIdx = Math.max(startIndex, endIndex);
      // 기존 선택 해제 (Ctrl 안 누르면)
      tracks.forEach(t => t.selected = false);
      // 범위 내 트랙 선택
      for (let i = minIdx; i <= maxIdx; i++) {
        tracks[i].selected = true;
      }
      // 활성 트랙 변경
      selectTrack(endIndex);
      showCenterToast(`${maxIdx - minIdx + 1}개 트랙 선택됨`);
    }
    // ✅ 마퀴 설정 함수
    function setupMarquee(container, inner) {
      const containerWidth = container.offsetWidth;
      const textWidth = inner.scrollWidth;
      // 텍스트가 컨테이너보다 길 때만 스크롤
      if (textWidth > containerWidth) {
        const scrollDistance = textWidth - containerWidth + 20; // 여유 20px
        const duration = Math.max(2, scrollDistance / 50); // 속도 조절 (50px/초)
        inner.style.setProperty('--scroll-distance', `-${scrollDistance}px`);
        inner.style.setProperty('--scroll-duration', `${duration}s`);
        inner.classList.add('scrolling');
      }
    }
    // ✅ 마퀴 리셋 함수
    function resetMarquee(inner) {
      inner.classList.remove('scrolling');
      inner.style.transform = 'translateX(0)';
    }
    // ✅ 툴팁 표시 함수
    function showTrackTooltip(e, track) {
      const tooltip = $('trackTooltip');
      if (!tooltip) return;
      // 파일 정보 구성
      const fileName = track.name;
      const duration = formatTime(track.duration);
      const sampleRate = track.buffer ? `${track.buffer.sampleRate}Hz` : '';
      const channels = track.buffer ? (track.buffer.numberOfChannels >= 2 ? '🔊 Stereo' : '🔈 Mono') : '';
      const segments = track.segments ? track.segments.length : 0;
      const markers = track.markers ? track.markers.length : 0;
      tooltip.querySelector('.tooltip-name').textContent = fileName;
      tooltip.querySelector('.tooltip-info').innerHTML = `
    ⏱️ ${duration}  |  🎵 ${sampleRate} ${channels}<br>
    📋 세그먼트: ${segments}개  |  📍 마커: ${markers}개
    ${track.isDirty ? '<br><span style="color: #ff9800;">⚠️ 변경사항 있음</span>' : ''}
    `;
      updateTooltipPosition(e);
      tooltip.classList.add('show');
    }
    // ✅ 툴팁 위치 업데이트 함수
    function updateTooltipPosition(e) {
      const tooltip = $('trackTooltip');
      if (!tooltip) return;
      const padding = 15;
      let x = e.clientX - 20;
      let y = e.clientY + padding;
      // 화면 밖으로 나가지 않도록 조정
      const tooltipRect = tooltip.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      if (x + tooltipRect.width > viewportWidth - padding) {
        x = viewportWidth - tooltipRect.width - padding;
      }
      if (x < padding) {
        x = padding;
      }
      if (y + tooltipRect.height > viewportHeight - padding) {
        y = e.clientY - tooltipRect.height - padding; // 위로 표시
      }
      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;
    }
    // ✅ 툴팁 숨김 함수
    function hideTrackTooltip() {
      const tooltip = $('trackTooltip');
      if (tooltip) {
        tooltip.classList.remove('show');
      }
    }

    function initDragAndDrop() {
      const playlist = $('playlist');
      const workspace = $('waveWrapper'); // 작업 영역에도 드롭 가능
      // 드래그 오버 시 스타일 변경
      function handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'copy';
        playlist.classList.add('drag-over');
      }
      // 드래그 떠날 때 스타일 복원
      function handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        // 자식 요소로 이동할 때는 무시
        if (e.target === playlist || !playlist.contains(e.relatedTarget)) {
          playlist.classList.remove('drag-over');
        }
      }
      // 드롭 처리
      async function handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        playlist.classList.remove('drag-over');
        const files = e.dataTransfer.files;
        if (files.length === 0) return;
        // 오디오 파일만 필터링
        const audioFiles = Array.from(files).filter(file =>
          file.type.startsWith('audio/') ||
          /\.(wav|mp3|ogg|flac|m4a|aac|wma)$/i.test(file.name)
        );
        if (audioFiles.length === 0) {
          showCenterToast('오디오 파일만 추가할 수 있습니다');
          return;
        }
        // 파일 처리 (기존 handleFileSelect 로직 재사용)
        const fakeEvent = {
          target: {
            files: audioFiles
          }
        };
        await handleFileSelect(fakeEvent);
        showCenterToast(`${audioFiles.length}개 파일이 추가되었습니다`);
      }
      // 플레이리스트에 이벤트 등록
      playlist.addEventListener('dragover', handleDragOver);
      playlist.addEventListener('dragleave', handleDragLeave);
      playlist.addEventListener('drop', handleDrop);
      // 작업 영역(파형)에도 드롭 가능하게
      workspace.addEventListener('dragover', handleDragOver);
      workspace.addEventListener('dragleave', handleDragLeave);
      workspace.addEventListener('drop', handleDrop);
      // 전체 문서에서 기본 드래그 동작 방지 (브라우저가 파일 열기 방지)
      document.addEventListener('dragover', (e) => {
        e.preventDefault();
      });
      document.addEventListener('drop', (e) => {
        e.preventDefault();
      });
      console.log('✅ 드래그 앤 드롭 초기화 완료');
    }
    function initPlaylistKeyboardNav() {
      const playlist = $('playlist');
      if (!playlist) return;
      // 플레이리스트 클릭 시 포커스
      playlist.addEventListener('click', (e) => {
        // 체크박스 클릭은 제외
        if (e.target.classList.contains('trackCheck')) return;
        setFocusedPanel('playlist');
      });
      // 포커스 받았을 때
      playlist.addEventListener('focus', () => {
        setFocusedPanel('playlist');
      });
      // 포커스 잃었을 때
      playlist.addEventListener('blur', () => {
        if (focusedPanel === 'playlist') {
          playlist.classList.remove('focused');
        }
      });
      $('segmentListContainer')?.addEventListener('click', () => {
        setFocusedPanel('segment');
      });
      // 마커 리스트 클릭 시
      $('markerListContainer')?.addEventListener('click', () => {
        setFocusedPanel('marker');
      });
      console.log('✅ 플레이리스트 키보드 네비게이션 초기화 완료');
    }
    function initPlaylistSearch() {
      const searchInput = $('playlistSearch');
      const searchWrapper = $('playlistSearchWrapper');
      const clearBtn = $('playlistSearchClear');
      if (!searchInput) return;
      // 검색어 입력 시
      searchInput.addEventListener('input', (e) => {
        playlistSearchQuery = e.target.value;
        // 클리어 버튼 표시/숨김
        if (playlistSearchQuery) {
          searchWrapper.classList.add('has-value');
        } else {
          searchWrapper.classList.remove('has-value');
        }
        renderPlaylist();
      });
      // 클리어 버튼 클릭
      clearBtn.addEventListener('click', () => {
        searchInput.value = '';
        playlistSearchQuery = '';
        searchWrapper.classList.remove('has-value');
        searchInput.focus();
        renderPlaylist();
      });
      // ESC 키로 검색 초기화
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (playlistSearchQuery) {
            e.stopPropagation();
            searchInput.value = '';
            playlistSearchQuery = '';
            searchWrapper.classList.remove('has-value');
            renderPlaylist();
          } else {
            // 검색어 없으면 포커스 해제
            searchInput.blur();
            setFocusedPanel('playlist');
          }
        }
        // Enter 키로 첫 번째 결과 선택
        if (e.key === 'Enter') {
          e.preventDefault();
          const firstItem = $('playlist').querySelector('.trackItem');
          if (firstItem) {
            const index = parseInt(firstItem.dataset.index);
            selectTrack(index);
            searchInput.blur();
            setFocusedPanel('playlist');
          }
        }
        // 아래 화살표로 리스트로 이동
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          searchInput.blur();
          setFocusedPanel('playlist');
        }
      });
      // Ctrl+F로 검색창 포커스
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
          // 검색창에 이미 포커스가 있거나, 다른 입력창에 있으면 무시
          if (document.activeElement === searchInput) return;
          if (document.activeElement.tagName === 'INPUT') return;
          e.preventDefault();
          searchInput.focus();
          searchInput.select();
        }
      });
      console.log('✅ 플레이리스트 검색 초기화 완료');
    }
    // ✅ 포커스된 패널 설정
    function setFocusedPanel(panel) {
      focusedPanel = panel;
      const playlist = $('playlist');
      const segContainer = $('segmentListContainer');
      const markerContainer = $('markerListContainer');
      // 모든 패널 포커스 스타일 제거
      playlist.classList.remove('focused');
      segContainer.style.outline = 'none';
      markerContainer.style.outline = 'none';
      // 선택된 패널에 포커스 스타일 적용
      if (panel === 'playlist') {
        playlist.classList.add('focused');
        playlist.focus();
        focusedList = null; // 세그먼트/마커 리스트 포커스 해제
      } else if (panel === 'segment') {
        segContainer.style.outline = '2px solid #1890ff';
        focusedList = 'segment';
      } else if (panel === 'marker') {
        markerContainer.style.outline = '2px solid #ff9800';
        focusedList = 'marker';
      }
    }
    // ✅ 플레이리스트에서 트랙 선택 이동 (Shift 다중 선택 지원)
    function movePlaylistSelection(direction, withShift = false) {
      if (tracks.length === 0) return;
      // 검색 필터 적용된 인덱스 목록
      const query = playlistSearchQuery.toLowerCase().trim();
      const visibleIndices = query ?
        tracks.map((t, i) => ({
          index: i,
          name: t.name
        }))
        .filter(item => item.name.toLowerCase().includes(query))
        .map(item => item.index) :
        tracks.map((_, i) => i);
      if (visibleIndices.length === 0) return;
      // 현재 위치 찾기
      let currentPos = visibleIndices.indexOf(activeTrackIndex);
      if (currentPos === -1) currentPos = 0;
      // 새 위치 계산
      let newPos;
      if (direction === 'up') {
        newPos = currentPos <= 0 ? visibleIndices.length - 1 : currentPos - 1;
      } else {
        newPos = currentPos >= visibleIndices.length - 1 ? 0 : currentPos + 1;
      }
      const newIndex = visibleIndices[newPos];
      if (withShift) {
        // ✅ Shift+방향키: 범위 선택 확장
        if (multiSelectAnchor === -1) {
          multiSelectAnchor = activeTrackIndex;
        }
        // 앵커부터 새 위치까지 선택
        const minIdx = Math.min(multiSelectAnchor, newIndex);
        const maxIdx = Math.max(multiSelectAnchor, newIndex);
        tracks.forEach((t, i) => {
          t.selected = (i >= minIdx && i <= maxIdx);
        });
        // 활성 트랙 변경 (선택 상태 유지)
        activeTrackIndex = newIndex;
        renderPlaylist();
        scrollPlaylistToIndex(newIndex);
        updateInfoChip();
      } else {
        // ✅ 일반 방향키: 단일 선택
        multiSelectAnchor = newIndex;
        // 기존 선택 해제
        tracks.forEach(t => t.selected = false);
        selectTrack(newIndex);
        scrollPlaylistToIndex(newIndex);
      }
    }
    // ✅ 플레이리스트 스크롤 (선택된 항목이 보이도록) - 검색 필터 고려
    // ✅ 플레이리스트 스크롤 (선택된 항목이 보이도록)
    function scrollPlaylistToIndex(index) {
      const playlist = $('playlist');
      const items = playlist.querySelectorAll('.trackItem');
      if (items[index]) {
        items[index].scrollIntoView({
          block: 'nearest',
          behavior: 'smooth'
        });
      }
    }
    /* ================= 런처 자동 로그인 리스너 ================= */


    // 편집 옵션 상태 저장/불러오기
    function saveEditOptions() {
      const options = {
        snapToZero: $('chkSnapToZero')?.checked || false,
        rippleEdit: $('chkRippleEdit')?.checked || false
      };
      localStorage.setItem('audioEditorEditOptions', JSON.stringify(options));
    }

    function loadEditOptions() {
      try {
        const saved = localStorage.getItem('audioEditorEditOptions');
        if (saved) {
          const options = JSON.parse(saved);
          if ($('chkSnapToZero')) $('chkSnapToZero').checked = options.snapToZero ?? false;
          if ($('chkRippleEdit')) $('chkRippleEdit').checked = options.rippleEdit ?? true;
        }
      } catch (e) {
        console.log('편집 옵션 불러오기 실패:', e);
      }
    }
    const $ = (id) => document.getElementById(id);
    const App = {
      token: '',
      user: null,
      clipboard: null
    };
    // [NEW] Throttle utility for performance
    function throttle(func, limit) {
      let inThrottle;
      return function(...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }
    let audioCtx = null;
    let tracks = [];
    let activeTrackIndex = -1;
    let sourceNode = null;
    let isPlaying = false;
    let playbackStartTime = 0;
    let playbackOffset = 0;
    let animationFrameId = null;
    let anchorTime = 0;
    let selStartTime = null;
    let selEndTime = null;
    let isDragging = false;
    let dragStartX = 0;
    let edgeScrollSpeed = 0;
    let lastMouseX = 0;
    let lastDragDraw = 0; // 드래그 시 렌더링 제한용
    let waveScale = 0.90;
    let containerHeight = 500;
    let zoomLevel = 1.0;
    let resizeObserver = null;
    let isMinimapDragging = false;
    let segmentSort = {
      col: 'start',
      asc: true
    };
    let markerSort = {
      col: 'time',
      asc: true
    };
    // Variables for Segment Resize
    let resizeState = {
      id: null,
      side: null
    };
    const RESIZE_THRESHOLD = 5;
    let markerDragState = { id: null }; // ✅ 마커 드래그 상태
    // [NEW] Rendering State
    let isRendering = false;
    // [NEW] Shift Click State
    let shiftClickStart = null;
    // 파형과 스펙트로그램 동기화를 위한 전역 변수
    let waveViewParams = {
      startTime: 0,
      endTime: 0,
      displayWidth: 0,
      viewDuration: 0,
      currentTime: 0
    };
    // [NEW] Silero VAD 관련 변수
    let vadModel = null;
    let vadSession = null;
    let isVADLoaded = false;
    // ✅ 전역 변수 추가 (Line 60 근처)
    let lastPreviewOptions = null; // ⬅️ 추가!
    let lastPreviewPhase = null;
    let lastPreviewMode = null;
    let selectedSegmentIndex = -1; // 현재 선택된 세그먼트 인덱스
    let isLoopEnabled = false; // 반복 재생 활성화
    let selectedMarkerIndex = -1; // 현재 선택된 마커 인덱스
    let focusedList = 'segment'; // 'segment', 'marker', 'transcript'
    let selectedTranscriptIndex = -1; // 현재 선택된 전사 인덱스
    let isVerticalResizing = false;
    let verticalResizeStartY = 0;
    let verticalResizeStartHeights = { top: 0, bottom: 0 };
    let focusedPanel = null; // 'playlist', 'segment', 'marker' 중 하나
    let playlistSearchQuery = ''; // 플레이리스트 검색어
    let multiSelectAnchor = -1; // 다중 선택 시작점
    let isListResizing = false;
    let listResizerStartX = 0;
    let listStartWidths = {
      seg: 0,
      marker: 0
    };
    let isListSwapped = false; // 리스트 위치 교환 상태
    let savedListRatio = null; // ✅ 전역으로 이동 (비율 유지용)
    // ✅ 전역 변수 추가 (파일 상단, 다른 전역 변수들 근처에)
    let lastWaveContainerWidth = 0;
    // ========== 녹음 관련 전역 변수 ==========
    let mediaStream = null; // 마이크 스트림
    let mediaRecorder = null; // MediaRecorder 인스턴스
    // recordedChunks 불필요 (AudioWorklet 데이터만 사용)
    let isRecording = false; // 녹음 중 여부
    let inputAnalyser = null; // 입력 분석기 (레벨 미터용)
    let levelAnimationId = null; // 레벨 미터 애니메이션 ID
    let inputMonitorGain = null; // 입력 모니터링 게인 노드
    let recordingStartTime = 0; // 녹음 시작 시간
    let selectedInputDeviceId = 'default'; // 선택된 입력 장치 ID
    let liveRecordingData = []; // 실시간 녹음 데이터 L채널 (Float32Array 청크들)
    let liveRecordingDataR = []; // 실시간 녹음 데이터 R채널 (스테레오용)
    // liveRecordingData에서 직접 샘플 읽기 (AudioBuffer 생성 없이)
    function getLiveRecSample(idx, ch) {
      // 플러시된 영역이면 flushedChunks에서 읽기
      if (idx < flushedLength) {
        const arr = ch === 0 ? flushedChunksL : flushedChunksR;
        const chunkIdx = (idx / LIVE_CHUNK_SIZE) | 0;
        const offset = idx % LIVE_CHUNK_SIZE;
        return (chunkIdx < arr.length && arr[chunkIdx]) ? (arr[chunkIdx][offset] || 0) : 0;
      }
      // 플러시 이후 영역은 liveRecordingData에서 읽기
      const liveIdx = idx - flushedLength;
      const chunkIdx = (liveIdx / LIVE_CHUNK_SIZE) | 0;
      const offset = liveIdx % LIVE_CHUNK_SIZE;
      const arr = ch === 0 ? liveRecordingData : liveRecordingDataR;
      return (chunkIdx < arr.length && arr[chunkIdx]) ? (arr[chunkIdx][offset] || 0) : 0;
    }
    const LIVE_CHUNK_SIZE = 8192; // 청크 묶음 단위
    let workletNode = null; // AudioWorklet 노드
    let workletRegistered = false; // AudioWorklet 프로세서 등록 여부
    let workletBatchL = null; // L채널 배치 버퍼
    let workletBatchR = null; // R채널 배치 버퍼
    let workletBatchPos = 0; // 배치 버퍼 위치
    let flushedChunksL = []; // 플러시된 L채널 청크 배열 (Float32Array[])
    let flushedChunksR = []; // 플러시된 R채널 청크 배열 (Float32Array[])
    let flushedLength = 0; // 플러시된 샘플 수
    let liveViewStart = 0; // 녹음 중 뷰 시작 시간
    let liveViewEnd = 0; // 녹음 중 뷰 끝 시간
    let isPaused = false; // 녹음 일시정지 상태
    let pausedDuration = 0; // 일시정지된 누적 시간
    let pauseStartTime = 0; // 일시정지 시작 시간
    let liveViewStartTime = 0; // 실시간 파형 뷰 시작 시간
    let liveViewLocked = true; // 실시간 뷰가 최신 녹음에 고정되어 있는지
    let liveZoomLevel = 1.0; // 실시간 녹음 시 줌 레벨
    let isLiveMinimapDragging = false; // 미니맵 드래그 중 여부
    let liveBufferUpdateInterval = null; // 실시간 버퍼 업데이트 인터벌
    let keepCurrentView = false; // 재개 시 현재 뷰 유지 플래그
    let userManualZoom = false; // 사용자가 직접 줌 변경했는지
    let recordingViewDuration = 30; // 녹음 중 화면에 보이는 시간(초)
    let insertTargetTrackIndex = -1; // 삽입 대상 트랙 인덱스
    let insertTargetBuffer = null; // 삽입 대상 트랙의 원본 버퍼
    let insertTime = 0; // 삽입 위치 (초)
    let appendOriginalBuffer = null; // 이어서 녹음 모드: 원본 버퍼
    let recordSampleRate = 48000; // 녹음 샘플레이트
    let targetDbLevel = -7; // 적정 볼륨 dB 기준선
    let showTargetDb = true; // 적정 볼륨 표시 여부
    let recordBitDepth = 16; // 녹음 비트 깊이
    let recordChannels = 1; // 녹음 채널 수 (1: 모노, 2: 스테레오)
    // 설정 관련 전역 변수
    let waveColor = localStorage.getItem('waveColor') || '#4a90d9';
    let selectionColor = localStorage.getItem('selectionColor') || 'rgba(0,123,255,0.25)';
    let defaultPlaybackSpeed = parseFloat(localStorage.getItem('defaultPlaybackSpeed')) || 1.0;
    let defaultSilenceDuration = 2.0;

    // 수동 전사용 변수
    let transcriptMarkStart = null; // [ 키로 시작점 임시 저장

    // ========== 자동 백업 (IndexedDB) ==========
    const BACKUP_DB_NAME = 'EasyRec-SentenceBackup';
    const BACKUP_DB_VERSION = 1;
    let backupChunkIndex = 0; // 마지막으로 백업한 청크 인덱스
    let backupInterval = null; // 백업 저장 인터벌


    function openBackupDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(BACKUP_DB_NAME, BACKUP_DB_VERSION);
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('meta')) {
            db.createObjectStore('meta', { keyPath: 'id' });
          }
          if (!db.objectStoreNames.contains('chunks')) {
            db.createObjectStore('chunks', { keyPath: 'idx' });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function saveBackupMeta(meta) {
      try {
        const db = await openBackupDB();
        const tx = db.transaction('meta', 'readwrite');
        tx.objectStore('meta').put({ id: 'session', ...meta });
        await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = rej; });
        db.close();
      } catch (e) { console.warn('백업 메타 저장 실패:', e); }
    }

    async function saveBackupChunks(newChunksL, newChunksR, startIdx) {
      try {
        const db = await openBackupDB();
        const tx = db.transaction('chunks', 'readwrite');
        const store = tx.objectStore('chunks');
        for (let i = 0; i < newChunksL.length; i++) {
          const idx = startIdx + i;
          const entry = { idx, left: newChunksL[i] };
          if (newChunksR[i]) entry.right = newChunksR[i];
          store.put(entry);
        }
        await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = rej; });
        db.close();
        console.log('💾 백업 청크 저장 완료: ' + newChunksL.length + '개 (시작: ' + startIdx + ')');
      } catch (e) { console.error('❌ 백업 청크 저장 실패:', e); }
    }

    async function loadBackup() {
      try {
        console.log('💾 백업 로드 시도...');
        const db = await openBackupDB();
        // 메타 읽기
        const metaTx = db.transaction('meta', 'readonly');
        const metaReq = metaTx.objectStore('meta').get('session');
        const meta = await new Promise((res) => { metaReq.onsuccess = () => res(metaReq.result); metaReq.onerror = () => res(null); });
        console.log('💾 백업 메타:', meta ? JSON.stringify({duration: meta.duration, totalChunks: meta.totalChunks}) : 'null');
        if (!meta) { db.close(); return null; }
        // 청크 읽기
        const chunkTx = db.transaction('chunks', 'readonly');
        const chunkReq = chunkTx.objectStore('chunks').getAll();
        const chunks = await new Promise((res) => { chunkReq.onsuccess = () => res(chunkReq.result); chunkReq.onerror = () => res([]); });
        db.close();
        console.log('💾 백업 청크 수:', chunks.length);
        if (chunks.length === 0) return null;
        // 인덱스 순 정렬
        chunks.sort((a, b) => a.idx - b.idx);
        return { meta, chunks };
      } catch (e) { console.error('❌ 백업 로드 실패:', e); return null; }
    }

    async function clearBackup() {
      try {
        const db = await openBackupDB();
        const tx = db.transaction(['meta', 'chunks'], 'readwrite');
        tx.objectStore('meta').clear();
        tx.objectStore('chunks').clear();
        await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = rej; });
        db.close();
        backupChunkIndex = 0;
      } catch (e) { console.warn('백업 삭제 실패:', e); }
    }

    async function checkBackupRecovery() {
      try {
        console.log('💾 백업 복구 확인 시작...');
        const backup = await loadBackup();
        if (!backup || !backup.meta || backup.chunks.length === 0) {
          console.log('💾 복구할 백업 없음');
          return;
        }
        console.log('💾 복구 가능한 백업 발견! 청크:', backup.chunks.length);
        const meta = backup.meta;
        const durationStr = meta.duration ? meta.duration.toFixed(1) + '초' : backup.chunks.length + '청크';
        const dateStr = new Date(meta.startTime).toLocaleString('ko-KR');
        // 복구 모달 표시
        const modalEl = document.createElement('div');
        modalEl.className = 'modal-overlay';
        modalEl.style.cssText = 'display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:10000;align-items:center;justify-content:center;';
        modalEl.innerHTML = `
          <div style="background:#fff;border-radius:12px;padding:24px;max-width:420px;width:90%;box-shadow:0 4px 20px rgba(0,0,0,0.3);">
            <div style="font-size:18px;font-weight:700;margin-bottom:12px;">💾 미완성 녹음 발견</div>
            <div style="font-size:14px;color:#555;line-height:1.6;margin-bottom:16px;">
              이전에 저장되지 않은 녹음이 있습니다.<br><br>
              📅 녹음 시작: ${dateStr}<br>
              ⏱️ 길이: 약 ${durationStr}<br>
              🎤 ${meta.channels >= 2 ? '스테레오' : '모노'} / ${meta.sampleRate}Hz
            </div>
            <div style="display:flex;gap:8px;justify-content:flex-end;">
              <button id="btnBackupDiscard" style="padding:8px 16px;border:1px solid #ddd;border-radius:8px;background:#fff;cursor:pointer;">삭제</button>
              <button id="btnBackupRecover" style="padding:8px 16px;border:none;border-radius:8px;background:#1890ff;color:#fff;cursor:pointer;font-weight:600;">복구</button>
            </div>
          </div>`;
        document.body.appendChild(modalEl);
        modalEl.querySelector('#btnBackupDiscard').onclick = async () => {
          await clearBackup();
          modalEl.remove();
          showCenterToast('🗑️ 백업이 삭제되었습니다');
        };
        modalEl.querySelector('#btnBackupRecover').onclick = async () => {
          modalEl.remove();
          await recoverFromBackup(backup);
        };
      } catch (e) {
        console.warn('백업 확인 실패:', e);
      }
    }

    async function recoverFromBackup(backup) {
      try {
        const meta = backup.meta;
        const sr = meta.sampleRate || 48000;
        const numCh = meta.channels >= 2 ? 2 : 1;
        const totalLength = backup.chunks.length * LIVE_CHUNK_SIZE;
        if (!audioCtx) initAudioContext();
        // AudioBuffer 생성
        const audioBuffer = audioCtx.createBuffer(numCh, totalLength, sr);
        const chL = audioBuffer.getChannelData(0);
        for (let i = 0; i < backup.chunks.length; i++) {
          chL.set(backup.chunks[i].left, i * LIVE_CHUNK_SIZE);
        }
        if (numCh >= 2) {
          const chR = audioBuffer.getChannelData(1);
          for (let i = 0; i < backup.chunks.length; i++) {
            if (backup.chunks[i].right) {
              chR.set(backup.chunks[i].right, i * LIVE_CHUNK_SIZE);
            }
          }
        }
        // 트랙에 추가
        const recTime = new Date(meta.startTime);
        const timeStr = String(recTime.getHours()).padStart(2,'0') + String(recTime.getMinutes()).padStart(2,'0') + String(recTime.getSeconds()).padStart(2,'0');
        const recoveredTrack = {
          name: `EasyRec_${timeStr}`,
          buffer: audioBuffer,
          duration: audioBuffer.duration,
          segments: [],
          markers: [],
          undoStack: [],
          redoStack: [],
          selected: true,
          isDirty: true
        };
        tracks.forEach(t => t.selected = false);
        tracks.push(recoveredTrack);
        activeTrackIndex = tracks.length - 1;
        renderPlaylist();
        zoomLevel = 1.0;
        isRendering = false;
        // 웨이브 캔버스 표시
        if ($('wavePlaceholder')) $('wavePlaceholder').style.display = 'none';
        if ($('waveCanvas')) $('waveCanvas').style.display = 'block';
        setTimeout(() => {
          forceRedrawWaveform();
          updateMinimap();
        }, 100);
        // 녹음 모드를 "이어서 녹음"으로 전환
        if ($('chkRecordContinue')) {
          $('chkRecordContinue').checked = true;
          if (typeof updateRecordModeCards === 'function') updateRecordModeCards();
        }
        // 백업 삭제
        await clearBackup();
        showCenterToast(`✅ 녹음 복구 완료 (${audioBuffer.duration.toFixed(1)}초) — "이어서 녹음" 모드로 전환됨`, 3000);
      } catch (e) {
        console.error('복구 실패:', e);
        showCenterToast('⚠️ 복구에 실패했습니다: ' + e.message);
      }
    }

    // 색상 밝기 조절 (다크모드용)
    function adjustColorBrightness(hex, percent) {
      // hex를 RGB로 변환
      let r = parseInt(hex.slice(1, 3), 16);
      let g = parseInt(hex.slice(3, 5), 16);
      let b = parseInt(hex.slice(5, 7), 16);
      // 밝기 증가
      r = Math.min(255, r + percent);
      g = Math.min(255, g + percent);
      b = Math.min(255, b + percent);
      // 다시 hex로 변환
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function showToast(msg) {
      const t = $('toast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 1500);
    }

    function showCenterToast(msg, duration = 2000) {
      let el = $('centerToast');
      if (!el) {
        el = document.createElement('div');
        el.id = 'centerToast';
        document.body.appendChild(el);
      }
      el.textContent = msg;
      el.classList.add('show');
      clearTimeout(el._timer);
      el._timer = setTimeout(() => {
        el.classList.remove('show');
      }, duration);
    }
    // Core Stop Function
    function stopAudio() {
      if (sourceNode) {
        sourceNode.onended = null;
        try {
          sourceNode.stop();
        } catch (e) {}
        sourceNode = null;
      }
      isPlaying = false;
      playbackOffset = anchorTime;
      if ($('btnPlay')) $('btnPlay').style.display = 'inline-flex';
      if ($('btnPause')) $('btnPause').style.display = 'none';
      cancelAnimationFrame(animationFrameId);
      drawWaveform();
    }
    // --- UI RENDER FUNCTIONS ---
    function selectTrackRange(startIndex, endIndex) {
      const minIdx = Math.min(startIndex, endIndex);
      const maxIdx = Math.max(startIndex, endIndex);
      // 기존 선택 해제 (Ctrl 안 누르면)
      tracks.forEach(t => t.selected = false);
      // 범위 내 트랙 선택
      for (let i = minIdx; i <= maxIdx; i++) {
        tracks[i].selected = true;
      }
      // 활성 트랙 변경
      selectTrack(endIndex);
      showCenterToast(`${maxIdx - minIdx + 1}개 트랙 선택됨`);
    }
    // ✅ 마퀴 설정 함수
    function setupMarquee(container, inner) {
      const containerWidth = container.offsetWidth;
      const textWidth = inner.scrollWidth;
      // 텍스트가 컨테이너보다 길 때만 스크롤
      if (textWidth > containerWidth) {
        const scrollDistance = textWidth - containerWidth + 20; // 여유 20px
        const duration = Math.max(2, scrollDistance / 50); // 속도 조절 (50px/초)
        inner.style.setProperty('--scroll-distance', `-${scrollDistance}px`);
        inner.style.setProperty('--scroll-duration', `${duration}s`);
        inner.classList.add('scrolling');
      }
    }
    // ✅ 마퀴 리셋 함수
    function resetMarquee(inner) {
      inner.classList.remove('scrolling');
      inner.style.transform = 'translateX(0)';
    }
    // ✅ 툴팁 표시 함수
    function showTrackTooltip(e, track) {
      const tooltip = $('trackTooltip');
      if (!tooltip) return;
      // 파일 정보 구성
      const fileName = track.name;
      const duration = formatTime(track.duration);
      const sampleRate = track.buffer ? `${track.buffer.sampleRate}Hz` : '';
      const channels = track.buffer ? (track.buffer.numberOfChannels >= 2 ? '🔊 Stereo' : '🔈 Mono') : '';
      const segments = track.segments ? track.segments.length : 0;
      const markers = track.markers ? track.markers.length : 0;
      tooltip.querySelector('.tooltip-name').textContent = fileName;
      tooltip.querySelector('.tooltip-info').innerHTML = `
    ⏱️ ${duration}  |  🎵 ${sampleRate} ${channels}<br>
    📋 세그먼트: ${segments}개  |  📍 마커: ${markers}개
    ${track.isDirty ? '<br><span style="color: #ff9800;">⚠️ 변경사항 있음</span>' : ''}
    `;
      updateTooltipPosition(e);
      tooltip.classList.add('show');
    }
    // ✅ 툴팁 위치 업데이트 함수
    function updateTooltipPosition(e) {
      const tooltip = $('trackTooltip');
      if (!tooltip) return;
      const padding = 15;
      let x = e.clientX - 20;
      let y = e.clientY + padding;
      // 화면 밖으로 나가지 않도록 조정
      const tooltipRect = tooltip.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      if (x + tooltipRect.width > viewportWidth - padding) {
        x = viewportWidth - tooltipRect.width - padding;
      }
      if (x < padding) {
        x = padding;
      }
      if (y + tooltipRect.height > viewportHeight - padding) {
        y = e.clientY - tooltipRect.height - padding; // 위로 표시
      }
      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;
    }
    // ✅ 툴팁 숨김 함수
    function hideTrackTooltip() {
      const tooltip = $('trackTooltip');
      if (tooltip) {
        tooltip.classList.remove('show');
      }
    }

    // --- AUDIO LOGIC ---
    function initAudioContext() {
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
      }
    }

    function getUniqueName(fileName) {
      let name = fileName;
      let count = 1;
      const exists = (n) => tracks.some(t => t.name === n);
      if (!exists(name)) return name;
      let base = name;
      let ext = '';
      const dotIdx = name.lastIndexOf('.');
      if (dotIdx !== -1) {
        base = name.substring(0, dotIdx);
        ext = name.substring(dotIdx);
      }
      while (exists(name)) {
        name = `${base} (${count})${ext}`;
        count++;
      }
      return name;
    }
    // --- Buffer Utils ---
    function createBuffer(channels, length, rate) {
      if (length < 1) length = 1;
      return audioCtx.createBuffer(channels, length, rate);
    }

    function concatBuffers(buf1, buf2) {
      if (!buf1) return buf2;
      if (!buf2) return buf1;
      const len = buf1.length + buf2.length;
      const newBuf = createBuffer(buf1.numberOfChannels, len, buf1.sampleRate);
      for (let i = 0; i < buf1.numberOfChannels; i++) {
        const ch = newBuf.getChannelData(i);
        ch.set(buf1.getChannelData(i), 0);
        ch.set(buf2.getChannelData(i), buf1.length);
      }
      return newBuf;
    }

    function sliceBuffer(buf, start, end) {
      console.log(`✂️ sliceBuffer 호출: start=${start}, end=${end}, 총샘플=${buf.length}`);
      if (start >= end) {
        console.warn('⚠️ start >= end, 빈 버퍼 반환');
        return createBuffer(buf.numberOfChannels, 1, buf.sampleRate);
      }
      if (start < 0) start = 0;
      if (end > buf.length) end = buf.length;
      const len = end - start;
      console.log(`✂️ 실제 슬라이스 길이: ${len} 샘플 (${(len / buf.sampleRate).toFixed(2)}초)`);
      const newBuf = createBuffer(buf.numberOfChannels, len, buf.sampleRate);
      // ✅ 수동 복사 방식 (copyToChannel 대신)
      for (let ch = 0; ch < buf.numberOfChannels; ch++) {
        const sourceData = buf.getChannelData(ch);
        const targetData = newBuf.getChannelData(ch);
        // ✅ 샘플 하나씩 복사
        for (let i = 0; i < len; i++) {
          targetData[i] = sourceData[start + i];
        }
        // ✅ 데이터 검증 (채널 0만)
        if (ch === 0) {
          let maxAbs = 0;
          let nonZeroCount = 0;
          for (let i = 0; i < Math.min(1000, len); i++) {
            const abs = Math.abs(targetData[i]);
            if (abs > maxAbs) maxAbs = abs;
            if (abs > 0.0001) nonZeroCount++;
          }
          console.log(`✂️ 채널 ${ch} 검증:`);
          console.log(`• 첫 1000샘플 최대진폭: ${maxAbs.toFixed(6)}`);
          console.log(`• 비제로 샘플: ${nonZeroCount}개`);
          console.log(`• 첫 10샘플: [${Array.from(targetData.slice(0, 10)).map(v => v.toFixed(3)).join(', ')}]`);
          console.log(`• 100~110번째: [${Array.from(targetData.slice(100, 110)).map(v => v.toFixed(3)).join(', ')}]`);
          // ✅ 원본과 비교
          console.log(`• 원본 첫 10샘플: [${Array.from(sourceData.slice(start, start + 10)).map(v => v.toFixed(3)).join(', ')}]`);
        }
      }
      return newBuf;
    }
    // WAV Encoder Helper
    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const bufferArr = new ArrayBuffer(length);
      const view = new DataView(bufferArr);
      const channels = [];
      let i, sample, offset = 0,
        pos = 0;
      setUint32(0x46464952); // "RIFF"
      setUint32(length - 8); // file length - 8
      setUint32(0x45564157); // "WAVE"
      setUint32(0x20746d66); // "fmt " chunk
      setUint32(16); // length = 16
      setUint16(1); // PCM (uncompressed)
      setUint16(numOfChan);
      setUint32(buffer.sampleRate);
      setUint32(buffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
      setUint16(numOfChan * 2); // block-align
      setUint16(16); // 16-bit
      setUint32(0x61746164); // "data" - chunk
      setUint32(length - pos - 4); // chunk length
      for (i = 0; i < buffer.numberOfChannels; i++) channels.push(buffer.getChannelData(i));
      while (pos < buffer.length) {
        for (i = 0; i < numOfChan; i++) {
          sample = Math.max(-1, Math.min(1, channels[i][pos]));
          sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
          view.setInt16(44 + offset, sample, true);
          offset += 2;
        }
        pos++;
      }

      function setUint16(data) {
        view.setUint16(pos, data, true);
        pos += 2;
      }

      function setUint32(data) {
        view.setUint32(pos, data, true);
        pos += 4;
      }
      return new Blob([bufferArr], {
        type: 'audio/wav'
      });
    }
    // AudioBuffer 깊은 복사
    function cloneBuffer(buffer) {
      if (!buffer) return null;
      const ctx = new(window.AudioContext || window.webkitAudioContext)();
      const clone = ctx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
      for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
        clone.getChannelData(ch).set(buffer.getChannelData(ch));
      }
      return clone;
    }
    // --- Undo Manager ---
    const UndoManager = {
      undoStack: [],
      redoStack: [],
      MAX: 20,
      push(state) {
        this.undoStack.push(state);
        if (this.undoStack.length > this.MAX) this.undoStack.shift();
        this.redoStack = [];
        this.ui();
      },
      ui() {
        if($('btnUndo')) $('btnUndo').disabled = this.undoStack.length === 0;
        if($('btnRedo')) $('btnRedo').disabled = this.redoStack.length === 0;
        if($('btnUndoTop')) $('btnUndoTop').disabled = this.undoStack.length === 0;
        if($('btnRedoTop')) $('btnRedoTop').disabled = this.redoStack.length === 0;
      }
    };
    // --- Edit Actions ---
    function saveState() {
      if (activeTrackIndex === -1) return;
      const track = tracks[activeTrackIndex];
      UndoManager.push({
        trackId: track.id,
        buffer: cloneBuffer(track.buffer),
        duration: track.duration,
        segments: JSON.parse(JSON.stringify(track.segments)),
        markers: track.markers ? JSON.parse(JSON.stringify(track.markers)) : [],
        isDirty: track.isDirty
      });
    }

    function restoreState(s) {
      const track = tracks.find(t => t.id === s.trackId);
      if (!track) return;
      stopAudio();
      track.buffer = s.buffer;
      track.duration = s.duration;
      track.segments = JSON.parse(JSON.stringify(s.segments));
      track.markers = s.markers ? JSON.parse(JSON.stringify(s.markers)) : [];
      track.isDirty = s.isDirty;
      minimapNeedsRedraw = true;
      drawWaveform();
      renderSegmentList();
      renderMarkerList();
      renderPlaylist();
    }

    function performUndo() {
      if (isRecordingActive()) return;
      if (UndoManager.undoStack.length === 0) return;
      const track = tracks[activeTrackIndex];
      UndoManager.redoStack.push({
        trackId: track.id,
        buffer: cloneBuffer(track.buffer),
        duration: track.duration,
        segments: JSON.parse(JSON.stringify(track.segments)),
        markers: track.markers ? JSON.parse(JSON.stringify(track.markers)) : [],
        isDirty: track.isDirty
      });
      restoreState(UndoManager.undoStack.pop());
      UndoManager.ui();
    }

    function performRedo() {
      if (isRecordingActive()) return;
      if (UndoManager.redoStack.length === 0) return;
      const track = tracks[activeTrackIndex];
      UndoManager.undoStack.push({
        trackId: track.id,
        buffer: cloneBuffer(track.buffer),
        duration: track.duration,
        segments: JSON.parse(JSON.stringify(track.segments)),
        markers: track.markers ? JSON.parse(JSON.stringify(track.markers)) : [],
        isDirty: track.isDirty
      });
      restoreState(UndoManager.redoStack.pop());
      UndoManager.ui();
    }

    function doDeleteRegion() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1 || selStartTime === null || selEndTime === null) return;
      saveState();
      const track = tracks[activeTrackIndex];
      const sT = Math.min(selStartTime, selEndTime);
      const eT = Math.max(selStartTime, selEndTime);
      const sS = Math.floor(sT * track.buffer.sampleRate);
      const eS = Math.floor(eT * track.buffer.sampleRate);
      if (sS >= eS) return;
      const newBuf = concatBuffers(sliceBuffer(track.buffer, 0, sS), sliceBuffer(track.buffer, eS, track.buffer.length));
      const diff = eT - sT;
      const ripple = $('chkRippleEdit')?.checked;
      track.segments = track.segments.filter(s => !(s.start >= sT && s.end <= eT)).map(s => {
        if (ripple && s.start >= eT) {
          s.start -= diff;
          s.end -= diff;
        } else if (s.end > sT && s.start < sT) {
          s.end = sT;
        }
        return s;
      });
      track.buffer = newBuf;
      track.duration = newBuf.duration;
      track.isDirty = true;
      selStartTime = null;
      selEndTime = null;
      minimapNeedsRedraw = true; // [NEW]
      drawWaveform();
      renderSegmentList();
      renderPlaylist();
    }

    // 녹음 설정 접기/펼치기
    function toggleRecSettings() {
      const content = $('recSettingsContent');
      const arrow = $('recSettingsArrow');
      if (!content) return;
      if (content.style.display === 'none') {
        content.style.display = '';
        arrow.textContent = '▼';
      } else {
        content.style.display = 'none';
        arrow.textContent = '▶';
      }
    }
    
    // 트랙 관리 접기/펼치기
    function toggleTrackManage() {
      const content = $('trackManageContent');
      const arrow = $('trackManageArrow');
      if (!content) return;
      if (content.style.display === 'none') {
        content.style.display = '';
        arrow.textContent = '▼';
      } else {
        content.style.display = 'none';
        arrow.textContent = '▶';
      }
    }

    // 백업 상태 표시 (UI)
    function showBackupStatus(msg) {
      const bar = $('backupStatusBar');
      const text = $('backupStatusText');
      if (!bar || !text) return;
      text.textContent = msg;
      // 3초 후 텍스트만 지움 (공간은 유지)
      clearTimeout(bar._hideTimer);
      bar._hideTimer = setTimeout(() => { text.textContent = ''; }, 3000);
    }

    // 녹음 중 편집 차단 체크
    function isRecordingActive() {
      if (isRecording) {
        showCenterToast('⚠️ 녹음 중에는 편집할 수 없습니다.\n정지(P) 후 편집할 수 있습니다.', 3000);
        return true;
      }
      return false;
    }

    function doCopy() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1 || selStartTime === null || selEndTime === null) return;
      const track = tracks[activeTrackIndex];
      const sT = Math.min(selStartTime, selEndTime);
      const eT = Math.max(selStartTime, selEndTime);
      App.clipboard = sliceBuffer(track.buffer, Math.floor(sT * track.buffer.sampleRate), Math.floor(eT * track.buffer.sampleRate));
      showCenterToast("복사되었습니다");
    }

    function doCut() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1 || selStartTime === null || selEndTime === null) {
        return showCenterToast("선택 구간이 없습니다");
      }
      const track = tracks[activeTrackIndex];
      const sT = Math.min(selStartTime, selEndTime);
      const eT = Math.max(selStartTime, selEndTime);
      App.clipboard = sliceBuffer(track.buffer, Math.floor(sT * track.buffer.sampleRate), Math.floor(eT * track.buffer.sampleRate));
      doDeleteRegion();
      showCenterToast(`${(eT - sT).toFixed(2)}초 잘라내기 완료`);
    }

    function doPaste() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1) return;
      if (!App.clipboard) return showCenterToast("클립보드가 비어있습니다");
      const hasRange = (selStartTime !== null && selEndTime !== null && Math.abs(selEndTime - selStartTime) > 0.001);
      saveState();
      if (hasRange) {
        const track = tracks[activeTrackIndex];
        const sT = Math.min(selStartTime, selEndTime);
        const eT = Math.max(selStartTime, selEndTime);
        const sS = Math.floor(sT * track.buffer.sampleRate);
        const eS = Math.floor(eT * track.buffer.sampleRate);
        const part1 = sliceBuffer(track.buffer, 0, sS);
        const part2 = sliceBuffer(track.buffer, eS, track.buffer.length);
        const newBuf = concatBuffers(concatBuffers(part1, App.clipboard), part2);
        const delD = eT - sT;
        const addD = App.clipboard.duration;
        const net = addD - delD;
        const ripple = $('chkRippleEdit')?.checked;
        track.segments = track.segments.filter(s => !(s.start >= sT && s.end <= eT));
        if (ripple) {
          track.segments.forEach(s => {
            if (s.start >= eT) {
              s.start += net;
              s.end += net;
            }
          });
        }
        track.buffer = newBuf;
        track.duration = newBuf.duration;
        track.isDirty = true;
        selStartTime = sT;
        selEndTime = sT + addD;
      } else {
        const track = tracks[activeTrackIndex];
        const iT = (selStartTime !== null) ? Math.min(selStartTime, selEndTime) : anchorTime;
        const iS = Math.floor(iT * track.buffer.sampleRate);
        const part1 = sliceBuffer(track.buffer, 0, iS);
        const part2 = sliceBuffer(track.buffer, iS, track.buffer.length);
        const newBuf = concatBuffers(concatBuffers(part1, App.clipboard), part2);
        const add = App.clipboard.duration;
        const ripple = $('chkRippleEdit')?.checked;
        if (ripple) {
          track.segments.forEach(s => {
            if (s.start >= iT) {
              s.start += add;
              s.end += add;
            } else if (s.end > iT) s.end += add;
          });
        }
        track.buffer = newBuf;
        track.duration = newBuf.duration;
        track.isDirty = true;
        selStartTime = iT;
        selEndTime = iT + add;
      }
      minimapNeedsRedraw = true; // [NEW]
      drawWaveform();
      renderSegmentList();
      renderPlaylist();
      showCenterToast("붙여넣기 완료");
    }
    // 선택 구간 무음화
    function doSilenceRegion() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1 || selStartTime === null || selEndTime === null) {
        return showCenterToast("선택 구간이 없습니다");
      }
      saveState();
      const track = tracks[activeTrackIndex];
      const sT = Math.min(selStartTime, selEndTime);
      const eT = Math.max(selStartTime, selEndTime);
      const sS = Math.floor(sT * track.buffer.sampleRate);
      const eS = Math.floor(eT * track.buffer.sampleRate);
      if (sS >= eS) return;
      for (let ch = 0; ch < track.buffer.numberOfChannels; ch++) {
        const channelData = track.buffer.getChannelData(ch);
        for (let i = sS; i < eS; i++) {
          channelData[i] = 0;
        }
      }
      track.isDirty = true;
      minimapNeedsRedraw = true;
      drawWaveform();
      renderPlaylist();
      showCenterToast(`${(eT - sT).toFixed(2)}초 구간 무음화 완료`);
    }
    // 선택 구간 반전
    function doReverseRegion() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1 || selStartTime === null || selEndTime === null) {
        return showCenterToast("선택 구간이 없습니다");
      }
      saveState();
      const track = tracks[activeTrackIndex];
      const sT = Math.min(selStartTime, selEndTime);
      const eT = Math.max(selStartTime, selEndTime);
      const sS = Math.floor(sT * track.buffer.sampleRate);
      const eS = Math.floor(eT * track.buffer.sampleRate);
      if (sS >= eS) return;
      for (let ch = 0; ch < track.buffer.numberOfChannels; ch++) {
        const channelData = track.buffer.getChannelData(ch);
        const segment = [];
        for (let i = sS; i < eS; i++) {
          segment.push(channelData[i]);
        }
        segment.reverse();
        for (let i = 0; i < segment.length; i++) {
          channelData[sS + i] = segment[i];
        }
      }
      track.isDirty = true;
      minimapNeedsRedraw = true;
      drawWaveform();
      renderPlaylist();
      showCenterToast(`${(eT - sT).toFixed(2)}초 구간 반전 완료`);
    }
    // 선택 구간 반복 모달 표시
    function showRepeatModal() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1 || selStartTime === null || selEndTime === null) {
        return showCenterToast("선택 구간이 없습니다");
      }
      const sT = Math.min(selStartTime, selEndTime);
      const eT = Math.max(selStartTime, selEndTime);
      const duration = eT - sT;
      $('repeatModal').style.display = 'flex';
      $('sliderRepeatCount').value = 2;
      $('labelRepeatCount').textContent = '2회';
      updateRepeatPreview(duration);
      const slider = $('sliderRepeatCount');
      slider.oninput = () => {
        const count = parseInt(slider.value);
        $('labelRepeatCount').textContent = count + '회';
        updateRepeatPreview(duration);
      };
    }

    function updateRepeatPreview(originalDuration) {
      const count = parseInt($('sliderRepeatCount').value);
      const newDuration = originalDuration * count;
      $('repeatPreviewInfo').innerHTML = `
    <strong>원본:</strong> ${originalDuration.toFixed(2)}초<br>
    <strong>반복 후:</strong> ${newDuration.toFixed(2)}초 (${count}회)
    `;
    }
    // 선택 구간 반복 실행
    function doRepeatRegion() {
      if (activeTrackIndex === -1 || selStartTime === null || selEndTime === null) return;
      const count = parseInt($('sliderRepeatCount').value);
      if (count < 2) {
        $('repeatModal').style.display = 'none';
        return showCenterToast("반복 횟수는 2회 이상이어야 합니다");
      }
      saveState();
      const track = tracks[activeTrackIndex];
      const sT = Math.min(selStartTime, selEndTime);
      const eT = Math.max(selStartTime, selEndTime);
      const sS = Math.floor(sT * track.buffer.sampleRate);
      const eS = Math.floor(eT * track.buffer.sampleRate);
      const segmentLength = eS - sS;
      if (segmentLength <= 0) return;
      const segmentBuffer = sliceBuffer(track.buffer, sS, eS);
      let repeatedBuffer = segmentBuffer;
      for (let i = 1; i < count; i++) {
        repeatedBuffer = concatBuffers(repeatedBuffer, segmentBuffer);
      }
      const beforePart = sliceBuffer(track.buffer, 0, sS);
      const afterPart = sliceBuffer(track.buffer, eS, track.buffer.length);
      const newBuf = concatBuffers(concatBuffers(beforePart, repeatedBuffer), afterPart);
      const addedDuration = segmentBuffer.duration * (count - 1);
      const ripple = $('chkRippleEdit')?.checked;
      if (ripple) {
        track.segments.forEach(seg => {
          if (seg.start >= eT) {
            seg.start += addedDuration;
            seg.end += addedDuration;
          } else if (seg.end > eT) {
            seg.end += addedDuration;
          }
        });
      }
      track.buffer = newBuf;
      track.duration = newBuf.duration;
      track.isDirty = true;
      selEndTime = sT + segmentBuffer.duration * count;
      $('repeatModal').style.display = 'none';
      minimapNeedsRedraw = true;
      drawWaveform();
      renderSegmentList();
      renderPlaylist();
      showCenterToast(`구간을 ${count}회 반복 완료`);
    }
    // 선택 구간만 남기기 (Trim)
    function doTrimToSelection() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1 || selStartTime === null || selEndTime === null) {
        return showCenterToast("선택 구간이 없습니다");
      }
      saveState();
      const track = tracks[activeTrackIndex];
      const sT = Math.min(selStartTime, selEndTime);
      const eT = Math.max(selStartTime, selEndTime);
      const sS = Math.floor(sT * track.buffer.sampleRate);
      const eS = Math.floor(eT * track.buffer.sampleRate);
      if (sS >= eS) return;
      // 선택 구간만 추출
      const newBuf = sliceBuffer(track.buffer, sS, eS);
      // 세그먼트 조정 (선택 구간 내 세그먼트만 유지, 시간 이동)
      track.segments = track.segments
        .filter(seg => seg.start >= sT && seg.end <= eT)
        .map(seg => ({
          ...seg,
          start: seg.start - sT,
          end: seg.end - sT
        }));
      // 마커 조정
      if (track.markers) {
        track.markers = track.markers
          .filter(m => m.time >= sT && m.time <= eT)
          .map(m => ({
            ...m,
            time: m.time - sT
          }));
      }
      track.buffer = newBuf;
      track.duration = newBuf.duration;
      track.isDirty = true;
      selStartTime = 0;
      selEndTime = newBuf.duration;
      anchorTime = 0;
      minimapNeedsRedraw = true;
      drawWaveform();
      renderSegmentList();
      renderMarkerList();
      renderPlaylist();
      showCenterToast(`${newBuf.duration.toFixed(2)}초 구간만 남김`);
    }
    // 커서 위치에서 분할 (2개 트랙으로)
    function doSplitAtCursor() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1) {
        return showCenterToast("트랙을 선택해주세요");
      }
      const track = tracks[activeTrackIndex];
      // 커서 위치 결정: 선택 시작점 또는 anchorTime
      const splitTime = (selStartTime !== null) ? Math.min(selStartTime, selEndTime || selStartTime) : anchorTime;
      if (splitTime <= 0 || splitTime >= track.duration) {
        return showCenterToast("분할 위치가 올바르지 않습니다");
      }
      const splitSample = Math.floor(splitTime * track.buffer.sampleRate);
      // 앞부분 버퍼
      const buf1 = sliceBuffer(track.buffer, 0, splitSample);
      // 뒷부분 버퍼
      const buf2 = sliceBuffer(track.buffer, splitSample, track.buffer.length);
      // 원본 트랙명에서 확장자 분리
      const baseName = track.name.replace(/\.[^/.]+$/, "");
      const ext = track.name.match(/\.[^/.]+$/)?.[0] || "";
      // 원본 트랙을 앞부분으로 수정
      saveState();
      track.buffer = buf1;
      track.duration = buf1.duration;
      track.name = baseName + "_part1" + ext;
      track.isDirty = true;
      // 세그먼트 분할
      const seg1 = track.segments.filter(s => s.end <= splitTime);
      const seg2 = track.segments
        .filter(s => s.start >= splitTime)
        .map(s => ({
          ...s,
          start: s.start - splitTime,
          end: s.end - splitTime,
          id: Date.now() + Math.random()
        }));
      track.segments = seg1;
      // 새 트랙 추가 (뒷부분)
      const newTrack = {
        id: Date.now(),
        name: baseName + "_part2" + ext,
        buffer: buf2,
        duration: buf2.duration,
        segments: seg2,
        markers: [],
        isDirty: true
      };
      tracks.splice(activeTrackIndex + 1, 0, newTrack);
      selStartTime = null;
      selEndTime = null;
      minimapNeedsRedraw = true;
      renderPlaylist();
      drawWaveform();
      renderSegmentList();
      showCenterToast(`${splitTime.toFixed(2)}초 위치에서 분할 완료`);
    }
    // 선택 구간 복제 (선택 구간 뒤에 삽입)
    function doDuplicate() {
      if (isRecordingActive()) return;
      if (activeTrackIndex === -1 || selStartTime === null || selEndTime === null) {
        return showCenterToast("선택 구간이 없습니다");
      }
      saveState();
      const track = tracks[activeTrackIndex];
      const sT = Math.min(selStartTime, selEndTime);
      const eT = Math.max(selStartTime, selEndTime);
      const sS = Math.floor(sT * track.buffer.sampleRate);
      const eS = Math.floor(eT * track.buffer.sampleRate);
      if (sS >= eS) return;
      // 선택 구간 복사
      const dupBuffer = sliceBuffer(track.buffer, sS, eS);
      const dupDuration = dupBuffer.duration;
      // 새 버퍼: 앞부분 + 선택구간 + 복제구간 + 뒷부분
      const beforePart = sliceBuffer(track.buffer, 0, eS);
      const afterPart = sliceBuffer(track.buffer, eS, track.buffer.length);
      const newBuf = concatBuffers(concatBuffers(beforePart, dupBuffer), afterPart);
      // 세그먼트 위치 조정 (선택 구간 뒤의 세그먼트들)
      const ripple = $('chkRippleEdit')?.checked;
      if (ripple) {
        track.segments.forEach(seg => {
          if (seg.start >= eT) {
            seg.start += dupDuration;
            seg.end += dupDuration;
          } else if (seg.end > eT) {
            seg.end += dupDuration;
          }
        });
      }
      track.buffer = newBuf;
      track.duration = newBuf.duration;
      track.isDirty = true;
      // 선택 영역을 복제된 구간으로 이동
      selStartTime = eT;
      selEndTime = eT + dupDuration;
      minimapNeedsRedraw = true;
      drawWaveform();
      renderSegmentList();
      renderPlaylist();
      showCenterToast(`${dupDuration.toFixed(2)}초 구간 복제 완료`);
    }
    // 제로 크로싱 찾기 (가장 가까운 0 지점)
    function findZeroCrossing(buffer, sampleIndex, searchRange = 1000) {
      const data = buffer.getChannelData(0);
      const len = data.length;
      // 범위 제한
      const startSearch = Math.max(0, sampleIndex - searchRange);
      const endSearch = Math.min(len - 1, sampleIndex + searchRange);
      let bestIndex = sampleIndex;
      let minDistance = searchRange + 1;
      // 현재 위치에서 가까운 제로 크로싱 찾기
      for (let i = startSearch; i < endSearch; i++) {
        // 부호가 바뀌는 지점 (제로 크로싱)
        if ((data[i] >= 0 && data[i + 1] < 0) || (data[i] < 0 && data[i + 1] >= 0)) {
          const distance = Math.abs(i - sampleIndex);
          if (distance < minDistance) {
            minDistance = distance;
            bestIndex = i;
          }
        }
      }
      return bestIndex;
    }
    // 시간을 제로 크로싱 시간으로 변환
    function snapToZeroCrossing(time) {
      if (activeTrackIndex === -1) return time;
      if (!$('chkSnapToZero')?.checked) return time;
      const track = tracks[activeTrackIndex];
      const sampleIndex = Math.floor(time * track.buffer.sampleRate);
      const snappedSample = findZeroCrossing(track.buffer, sampleIndex);
      return snappedSample / track.buffer.sampleRate;
    }
    function downloadBlob(content, fileName, mimeType) {
      const blob = new Blob([content], {
        type: mimeType
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    }

    async function saveSelectedTracks() {
      const statusEl = $('saveStatus');
      let selectedTracks = tracks.filter(t => t.selected);
      // Case 1: No selection -> Use active track if available
      if (selectedTracks.length === 0) {
        if (activeTrackIndex === -1) {
          statusEl.textContent = "선택된 데이터가 없습니다.";
          statusEl.style.color = "#d32f2f";
          setTimeout(() => {
            statusEl.textContent = "※ 1개 선택 시 WAV, 2개 이상 선택 시 ZIP으로 저장됩니다.";
            statusEl.style.color = "";
          }, 2000);
          return;
        }
        // Use currently active track
        selectedTracks = [tracks[activeTrackIndex]];
      }
      // Case 2: Single file -> Save as WAV directly (no ZIP)
      if (selectedTracks.length === 1) {
        statusEl.textContent = "저장 중입니다...";
        try {
          const track = selectedTracks[0];
          let fileName = track.name;
          if (!fileName.toLowerCase().endsWith('.wav')) fileName += '.wav';
          const wavBlob = audioBufferToWav(track.buffer, {
            markers: track.markers,
            segments: track.segments
          });
          // Try native Save As dialog
          try {
            if (window.showSaveFilePicker) {
              const handle = await window.showSaveFilePicker({
                suggestedName: fileName,
                types: [{
                  description: 'WAV Audio',
                  accept: {
                    'audio/wav': ['.wav']
                  }
                }],
              });
              const writable = await handle.createWritable();
              await writable.write(wavBlob);
              await writable.close();
            } else {
              throw new Error("Native Save As not supported");
            }
          } catch (saveErr) {
            if (saveErr.name !== 'AbortError') {
              const url = URL.createObjectURL(wavBlob);
              const a = document.createElement("a");
              a.href = url;
              a.download = fileName;
              a.click();
              URL.revokeObjectURL(url);
            }
          }
          track.isDirty = false;
          renderPlaylist();
          updateInfoChip();
          statusEl.textContent = "저장이 완료되었습니다.";
          statusEl.style.color = "#28a745";
          setTimeout(() => {
            statusEl.textContent = "※ 1개 선택 시 WAV, 2개 이상 선택 시 ZIP으로 저장됩니다.";
            statusEl.style.color = "";
          }, 3000);
          return;
        } catch (err) {
          console.error(err);
          statusEl.textContent = "오류가 발생했습니다: " + err.message;
          statusEl.style.color = "#d32f2f";
          return;
        }
      }
      // Case 3: Multiple files -> Save as ZIP
      statusEl.textContent = "압축 중입니다... 잠시만 기다려주세요.";
      try {
        const zip = new JSZip();
        selectedTracks.forEach(track => {
          let fileName = track.name;
          if (!fileName.toLowerCase().endsWith('.wav')) fileName += '.wav';
          const wavBlob = audioBufferToWav(track.buffer, {
            markers: track.markers,
            segments: track.segments
          });
          zip.file(fileName, wavBlob);
        });
        // Generate ZIP blob
        const content = await zip.generateAsync({
          type: "blob"
        });
        const dateStr = new Date().toISOString().slice(0, 10).replace(/-/g, "");
        const zipName = `AudioExport_${dateStr}_${selectedTracks.length}files.zip`;
        // Try to trigger "Save As" window if browser supports it (Chrome 86+)
        try {
          if (window.showSaveFilePicker) {
            const handle = await window.showSaveFilePicker({
              suggestedName: zipName,
              types: [{
                description: 'ZIP Archive',
                accept: {
                  'application/zip': ['.zip']
                }
              }],
            });
            const writable = await handle.createWritable();
            await writable.write(content);
            await writable.close();
          } else {
            throw new Error("Native Save As not supported");
          }
        } catch (saveErr) {
          // Fallback to standard download if user cancels or API fails/not supported
          if (saveErr.name !== 'AbortError') {
            const url = URL.createObjectURL(content);
            const a = document.createElement("a");
            a.href = url;
            a.download = zipName;
            a.click();
            URL.revokeObjectURL(url);
          }
        }
        // Mark as clean
        selectedTracks.forEach(t => t.isDirty = false);
        renderPlaylist();
        updateInfoChip();
        statusEl.textContent = "저장이 완료되었습니다.";
        statusEl.style.color = "#28a745";
        setTimeout(() => {
          statusEl.textContent = "※ 1개 선택 시 WAV, 2개 이상 선택 시 ZIP으로 저장됩니다.";
          statusEl.style.color = "";
        }, 3000);
      } catch (err) {
        console.error(err);
        statusEl.textContent = "오류가 발생했습니다: " + err.message;
        statusEl.style.color = "#d32f2f";
      }
    }

    // 실제 삭제 실행
    function sortMarkers(col) {
      if (markerSort.col === col) {
        markerSort.asc = !markerSort.asc;
      } else {
        markerSort.col = col;
        markerSort.asc = true;
      }
      selectedMarkerIndex = -1;
      renderMarkerList();
    }

    

    function playAudio() {
      if (activeTrackIndex === -1 || !audioCtx) return;
      if (isPlaying) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const track = tracks[activeTrackIndex];
      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = track.buffer;
      sourceNode.connect(audioCtx.destination);
      let playDuration = undefined;
      let loopStart = 0;
      let loopEnd = track.duration;
      if (selStartTime !== null && selEndTime !== null) {
        const s = Math.min(selStartTime, selEndTime);
        const e = Math.max(selStartTime, selEndTime);
        loopStart = s;
        loopEnd = e;
        if (playbackOffset < e) {
          if (playbackOffset < s) playbackOffset = s;
          playDuration = e - playbackOffset;
          if (playDuration <= 0) playDuration = 0.001;
        }
      }
      sourceNode.playbackRate.value = defaultPlaybackSpeed;
      sourceNode.start(0, playbackOffset, playDuration);
      playbackStartTime = audioCtx.currentTime;
      isPlaying = true;
      $('btnPlay').style.display = 'none';
      $('btnPause').style.display = 'inline-flex';
      cancelAnimationFrame(animationFrameId);
      drawLoop();
      // ✅ 반복 재생 처리
      sourceNode.onended = () => {
        if (!isPlaying) return;
        if (isLoopEnabled && selStartTime !== null && selEndTime !== null) {
          // 반복 재생: 구간 시작으로 돌아가서 다시 재생
          const s = Math.min(selStartTime, selEndTime);
          playbackOffset = s;
          anchorTime = s;
          isPlaying = false; // playAudio가 다시 시작할 수 있도록
          playAudio();
        } else {
          stopAudio();
        }
      };
    }

    function pauseAudio() {
      if (!isPlaying || !sourceNode) return;
      playbackOffset += audioCtx.currentTime - playbackStartTime;
      sourceNode.onended = null;
      sourceNode.stop();
      sourceNode = null;
      isPlaying = false;
      $('btnPlay').style.display = 'inline-flex';
      $('btnPause').style.display = 'none';
      cancelAnimationFrame(animationFrameId);
      drawWaveform();
    }
    // 반복 재생 토글
    function toggleLoop() {
      isLoopEnabled = !isLoopEnabled;
      const btn = $('btnLoop');
      if (isLoopEnabled) {
        btn.classList.add('active');
        btn.textContent = '🔂';
        showCenterToast('반복 재생 ON');
      } else {
        btn.classList.remove('active');
        btn.textContent = '🔁';
        showCenterToast('반복 재생 OFF');
      }
    }
    // 재생 중 구간 변경 적용
    function updatePlaybackRegion() {
      if (!isPlaying) return;
      if (selStartTime === null || selEndTime === null) return;
      const currentTime = getCurrentTime();
      const s = Math.min(selStartTime, selEndTime);
      const e = Math.max(selStartTime, selEndTime);
      // 현재 재생 위치가 새 구간 밖이면 구간 시작으로 이동
      if (currentTime < s || currentTime > e) {
        // 재생 재시작
        if (sourceNode) {
          sourceNode.onended = null;
          try {
            sourceNode.stop();
          } catch (err) {}
          sourceNode = null;
        }
        playbackOffset = s;
        anchorTime = s;
        isPlaying = false;
        playAudio();
      }
    }

    function getCurrentTime() {
      if (isPlaying) return playbackOffset + (audioCtx.currentTime - playbackStartTime);
      else return playbackOffset;
    }

    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      const ms = Math.floor((sec % 1) * 1000);
      return `${m < 10 ? '0'+m : m}:${s < 10 ? '0'+s : s}.${ms.toString().padStart(3, '0')}`;
    }

    function drawLoop() {
      drawWaveform();
      if (isPlaying) animationFrameId = requestAnimationFrame(drawLoop);
    }
    // [OPTIMIZED] Minimap with reduced rendering
    let minimapNeedsRedraw = true;
    let lastMinimapDraw = 0;

    function drawMinimap() {
      const miniCanvas = $('minimapCanvas');
      if (!miniCanvas) return;
      const now = performance.now(); // ← 추가!
      // 트랙이 없거나 (버퍼도 없고 라이브 녹음도 아니면) 빈 미니맵
      if (activeTrackIndex < 0 || (!tracks[activeTrackIndex]?.buffer && !tracks[activeTrackIndex]?._isLiveRec)) {
        const ctx = miniCanvas.getContext('2d');
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card').trim() || '#fff';
        ctx.fillRect(0, 0, miniCanvas.width, miniCanvas.height);
        return;
      }
      // Skip if drawn too recently (within 16ms ~ 60fps) AND no redraw needed
      if (!minimapNeedsRedraw && (now - lastMinimapDraw) < 16) return;
      const canvas = $('minimapCanvas');
      const container = $('minimapWrapper');
      if (!canvas || !container) return;
      const dpr = window.devicePixelRatio || 1;
      const w = container.clientWidth;
      const h = container.clientHeight;
      if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        minimapNeedsRedraw = true;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, w, h);
      if (activeTrackIndex === -1) return;
      const track = tracks[activeTrackIndex];
      // 라이브 녹음 중이고 buffer 없으면 drawLiveMinimap으로 위임 (duration 체크보다 먼저!)
      if (track._isLiveRec && isRecording && !track.buffer) {
        // track.duration을 사용 (drawWaveformSync의 뷰포트 계산과 동일한 기준)
        const totalDuration = track.duration;
        if (totalDuration > 0) {
          drawLiveMinimap(totalDuration, liveViewStart, liveViewEnd);
        }
        minimapNeedsRedraw = false;
        return;
      }
      if (track.duration <= 0) return;
      // [NEW] Draw waveform in minimap only if duration < 5 minutes (300 seconds)
      if (track.duration < 300) {
        const _mIsLive = !!(track._isLiveRec && isRecording && !isPaused);
        let _mOrigBuf, _mOrigLen, _mRecBuf, _mRecLen, miniNumCh;
        if (_mIsLive) {
          _mRecLen = flushedLength + liveRecordingData.length * LIVE_CHUNK_SIZE;
          _mRecBuf = null;
          if (appendOriginalBuffer) {
            _mOrigBuf = appendOriginalBuffer;
            _mOrigLen = _mOrigBuf.getChannelData(0).length;
            miniNumCh = _mOrigBuf.numberOfChannels;
          } else {
            _mOrigBuf = null;
            _mOrigLen = 0;
            miniNumCh = recordChannels >= 2 ? 2 : 1;
          }
        } else {
          const _mHasLiveRec = !!(track._liveRecBuffer && appendOriginalBuffer);
          _mOrigBuf = _mHasLiveRec ? appendOriginalBuffer : track.buffer;
          if (!_mOrigBuf) return; // 버퍼 없으면 미니맵 스킵
          _mRecBuf = _mHasLiveRec ? track._liveRecBuffer : null;
          _mOrigLen = _mOrigBuf.getChannelData(0).length;
          _mRecLen = _mRecBuf ? _mRecBuf.getChannelData(0).length : 0;
          miniNumCh = _mOrigBuf.numberOfChannels;
        }
        const miniIsStereo = miniNumCh >= 2;
        const miniChH = miniIsStereo ? h / 2 : h;
        const totalSamples = _mOrigLen + _mRecLen;
        const step = Math.ceil(totalSamples / w);
        // 다크모드 체크하여 파형 색상 변경
        const isDarkMode = document.documentElement.classList.contains('dark-mode');
        ctx.fillStyle = isDarkMode ? adjustColorBrightness(waveColor, 30) : waveColor;
        ctx.globalAlpha = 0.3;
        const miniChCount = miniIsStereo ? 2 : 1;
        for (let ch = 0; ch < miniChCount; ch++) {
          const _mOrigCh = _mOrigBuf ? _mOrigBuf.getChannelData(ch) : null;
          const _mRecCh = _mRecBuf ? _mRecBuf.getChannelData(Math.min(ch, _mRecBuf.numberOfChannels - 1)) : null;
          const chOffsetY = ch * miniChH;
          const chCenterY = chOffsetY + miniChH / 2;
          const chMaxAmpPx = miniChH / 2;
          for (let i = 0; i < w; i++) {
            let min = 1.0;
            let max = -1.0;
            const chunkStart = i * step;
            for (let j = 0; j < step; j++) {
              const idx = chunkStart + j;
              if (idx < totalSamples) {
                const datum = idx < _mOrigLen
                  ? (_mOrigCh ? _mOrigCh[idx] : 0)
                  : (_mIsLive ? getLiveRecSample(idx - _mOrigLen, ch) : (_mRecCh ? _mRecCh[idx - _mOrigLen] : 0));
                if (datum < min) min = datum;
                if (datum > max) max = datum;
              }
            }
            if (min === 1.0 && max === -1.0) { min = 0; max = 0; }
            const topY = chCenterY - (max * chMaxAmpPx * 0.8);
            const bottomY = chCenterY - (min * chMaxAmpPx * 0.8);
            const barHeight = Math.max(1, bottomY - topY);
            ctx.fillRect(i, topY, 1, barHeight);
          }
        }
        ctx.globalAlpha = 1.0;
      } else {
        // [FIX] 5분 이상일 때는 막대기 형식으로 표시
        ctx.fillStyle = '#ddd';
        ctx.fillRect(0, h * 0.2, w, h * 0.6);
      }
      if (track.segments) {
        track.segments.forEach(seg => {
          // ✅ 화자별 색상 적용
          const speakerIdx = getSpeakerColorIndex(seg.label, seg.speakerGroup);
          if (speakerIdx >= 0) {
            ctx.fillStyle = SPEAKER_COLORS[speakerIdx].bg.replace('0.25', '0.5');
          } else {
            ctx.fillStyle = 'rgba(40, 167, 69, 0.5)';
          }
          const x = (seg.start / track.duration) * w;
          const sw = ((seg.end - seg.start) / track.duration) * w;
          ctx.fillRect(x, 0, sw, h);
        });
      }
      // ✅ 마커 그리기
      if (track.markers) {
        ctx.fillStyle = '#ff9800';
        track.markers.forEach(marker => {
          const x = (marker.time / track.duration) * w;
          ctx.fillRect(x - 1, 0, 2, h);
        });
      }
      if (selStartTime !== null && selEndTime !== null) {
        const s = Math.min(selStartTime, selEndTime);
        const e = Math.max(selStartTime, selEndTime);
        const selStartX = (s / track.duration) * w;
        const selW = ((e - s) / track.duration) * w;
        ctx.fillStyle = selectionColor;
        ctx.fillRect(selStartX, 0, selW, h);
      }
      // Always draw dynamic elements (viewport box, playhead)
      const waveContainer = $('waveContainer');
      const scrollLeft = $('timelineScroll').scrollLeft;
      const totalWidth = waveContainer.clientWidth * zoomLevel;
      const viewportStartRatio = scrollLeft / totalWidth;
      const viewportWidthRatio = waveContainer.clientWidth / totalWidth;
      const miniBoxX = viewportStartRatio * w;
      const miniBoxW = Math.max(2, viewportWidthRatio * w);
      // ✅ 뷰포트 박스 - 더 진하고 눈에 잘 띄게
      ctx.fillStyle = 'rgba(255, 140, 0, 0.3)'; // 주황색 배경
      ctx.fillRect(miniBoxX, 0, miniBoxW, h);
      ctx.strokeStyle = 'rgba(255, 100, 0, 0.9)'; // 진한 주황 테두리
      ctx.lineWidth = 2;
      ctx.strokeRect(miniBoxX, 0, miniBoxW, h);
      ctx.lineWidth = 1; // 복원
      const playheadX = (getCurrentTime() / track.duration) * w;
      ctx.fillStyle = '#f00';
      ctx.fillRect(playheadX, 0, 2, h);
      // 녹음 중이면 빨간 테두리 표시
      if (isRecording) {
        ctx.strokeStyle = '#f44336';
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, w - 2, h - 2);
      }
      minimapNeedsRedraw = false;
      lastMinimapDraw = now;
    }

    function drawWaveform() {
      if (isRendering) return; // 중복 호출 방지만
      isRendering = true;
      requestAnimationFrame(drawWaveformSync);
    }
    // 강제 파형 다시 그리기 (녹음 완료 후 등)
    function forceRedrawWaveform() {
      if (activeTrackIndex < 0 || !tracks[activeTrackIndex]?.buffer) return;
      const canvas = $('waveCanvas');
      const container = $('waveContainer');
      if (canvas && container) {
        // 캔버스 크기 재설정
        const displayWidth = Math.max(800, container.clientWidth);
        const displayHeight = Math.max(250, container.clientHeight);
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
        }
        // 캔버스 클리어
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      // 렌더링 플래그 리셋 후 그리기
      isRendering = false;
      drawWaveform();
      updateTimeInfoPanel();
      renderSegmentList();
      renderMarkerList();
    }

    function drawWaveformSync() {
      const canvas = $('waveCanvas');
      const container = $('waveContainer');
      const scrollContainer = $('timelineScroll');
      const spacer = $('timelineSpacer');
      const chkAutoScroll = $('chkAutoScroll');
      if (!canvas || !container) {
        isRendering = false;
        return;
      }
      const dpr = 1;
      let displayWidth = Math.floor(container.clientWidth) || 800;
      let displayHeight = Math.floor(container.clientHeight) || 250;
      if (displayHeight < 50) displayHeight = 250;
      if (displayWidth < 100) displayWidth = 800;
      // 캔버스 크기가 0이면 강제 설정
      if (canvas.width === 0 || canvas.height === 0) {
        canvas.width = displayWidth;
        canvas.height = displayHeight;
      }
      if (canvas.width !== displayWidth * dpr || canvas.height !== displayHeight * dpr) {
        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, displayWidth, displayHeight);
      // drawMinimap은 뷰포트 계산 이후로 이동 (아래에서 호출)
      if (activeTrackIndex === -1 || !tracks[activeTrackIndex]) {
        spacer.style.width = '0px';
        isRendering = false;
        return;
      }
      const track = tracks[activeTrackIndex];
      // 버퍼가 없고 라이브 녹음도 아니면 빈 화면
      if (!track || (!track.buffer && !track._isLiveRec)) {
        spacer.style.width = '0px';
        // 미니맵 초기화
        const miniCanvas = $('minimapCanvas');
        if (miniCanvas) {
          const mctx = miniCanvas.getContext('2d');
          mctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card').trim() || '#fff';
          mctx.fillRect(0, 0, miniCanvas.width, miniCanvas.height);
        }
        isRendering = false;
        return;
      }
      const totalWidth = displayWidth * zoomLevel;
      spacer.style.width = `${totalWidth}px`;
      const viewDuration = track.duration / zoomLevel;
      const currentTime = getCurrentTime();
      let startTime, endTime;
      if (isRecording && !isPaused && track._isLiveRec) {
        // 녹음 중: 시간 기반으로 뷰 고정 (scrollLeft 의존 제거)
        endTime = track.duration;
        startTime = Math.max(0, endTime - viewDuration);
        liveViewStart = startTime;
        liveViewEnd = endTime;
        // scrollLeft는 뷰에 맞춰서 동기화 (미니맵용)
        const targetScroll = track.duration > 0 ? (startTime / track.duration) * totalWidth : 0;
        scrollContainer.scrollLeft = targetScroll;;
      } else {
        const scrollLeft = scrollContainer.scrollLeft;
        if (isPlaying && chkAutoScroll && chkAutoScroll.checked) {
          const currentPosPx = (currentTime / track.duration) * totalWidth;
          const viewEndPx = scrollLeft + displayWidth;
          if (currentPosPx > viewEndPx - 50) {
            scrollContainer.scrollLeft = currentPosPx - (displayWidth - 50);
          }
        }
        startTime = (scrollContainer.scrollLeft / totalWidth) * track.duration;
        endTime = Math.min(track.duration, startTime + viewDuration);
      }
      
      waveViewParams = {
        startTime: startTime,
        endTime: endTime,
        displayWidth: displayWidth,
        viewDuration: viewDuration,
        currentTime: currentTime
      };
      // 뷰포트 계산 완료 후 미니맵 그리기 (liveViewStart/liveViewEnd 동기화)
      drawMinimap();
      // 라이브 녹음 직접 읽기 모드 (AudioBuffer 생성 없이 liveRecordingData에서 직접 읽기)
      const _isLiveRec = !!(track._isLiveRec && isRecording && !isPaused);
      let _origBuf, _origLen, _recBuf, _recLen, numChannels;
      if (_isLiveRec) {
        _recLen = flushedLength + liveRecordingData.length * LIVE_CHUNK_SIZE;
        _recBuf = null; // getLiveRecSample()로 대체
        if (appendOriginalBuffer) {
          _origBuf = appendOriginalBuffer;
          _origLen = _origBuf.getChannelData(0).length;
          numChannels = _origBuf.numberOfChannels;
        } else {
          _origBuf = null;
          _origLen = 0;
          numChannels = recordChannels >= 2 ? 2 : 1;
        }
      } else {
        // 일시정지/정지 상태: 기존 AudioBuffer 방식
        const _hasLiveRec = !!(track._liveRecBuffer && appendOriginalBuffer);
        _origBuf = _hasLiveRec ? appendOriginalBuffer : track.buffer;
        if (!_origBuf) { isRendering = false; return; }
        _recBuf = _hasLiveRec ? track._liveRecBuffer : null;
        _origLen = _origBuf.getChannelData(0).length;
        _recLen = _recBuf ? _recBuf.getChannelData(0).length : 0;
        numChannels = _origBuf.numberOfChannels;
      }
      const isStereo = numChannels >= 2;
      const channelHeight = isStereo ? displayHeight / 2 : displayHeight;
      const totalSamples = _origLen + _recLen;
      if (totalSamples === 0 || track.duration <= 0) {
        // 아직 데이터 없음 - 빈 그리드만 표시
        const centerY = displayHeight / 2;
        const maxAmpPx = displayHeight / 2;
        drawGrid(ctx, displayWidth, displayHeight, viewDuration, startTime, centerY, maxAmpPx);
        drawMinimap();
        isRendering = false;
        return;
      }
      const startSample = Math.floor((startTime / track.duration) * totalSamples);
      const endSample = Math.floor((endTime / track.duration) * totalSamples);
      const sampleChunk = Math.max(1, endSample - startSample);
      const step = Math.ceil(sampleChunk / displayWidth);
      // 그리드는 전체 높이 기준 (모노와 동일)
      const centerY = displayHeight / 2;
      const maxAmpPx = displayHeight / 2;
      drawGrid(ctx, displayWidth, displayHeight, viewDuration, startTime, centerY, maxAmpPx);
      // 다크모드 체크하여 파형 색상 변경
      const isDarkMode = document.documentElement.classList.contains('dark-mode');
      const waveColorFinal = isDarkMode ? adjustColorBrightness(waveColor, 30) : waveColor;
      // 채널별 파형 그리기
      const channelsToDraw = isStereo ? 2 : 1;
      for (let ch = 0; ch < channelsToDraw; ch++) {
        const _origCh = _origBuf ? _origBuf.getChannelData(ch) : null;
        const _recCh = _recBuf ? _recBuf.getChannelData(Math.min(ch, _recBuf.numberOfChannels - 1)) : null;
        const chOffsetY = ch * channelHeight;
        const chCenterY = chOffsetY + channelHeight / 2;
        const chMaxAmpPx = channelHeight / 2;
        ctx.fillStyle = waveColorFinal;
        ctx.beginPath();
        for (let i = 0; i < displayWidth; i++) {
          let min = 1.0;
          let max = -1.0;
          const chunkStart = startSample + (i * step);
          for (let j = 0; j < step; j++) {
            const idx = chunkStart + j;
            if (idx < totalSamples) {
              const datum = idx < _origLen
                ? (_origCh ? _origCh[idx] : 0)
                : (_isLiveRec ? getLiveRecSample(idx - _origLen, ch) : (_recCh ? _recCh[idx - _origLen] : 0));
              if (datum < min) min = datum;
              if (datum > max) max = datum;
            }
          }
          if (min === 1.0 && max === -1.0) { min = 0; max = 0; }
          const topY = chCenterY - (max * chMaxAmpPx * waveScale);
          const bottomY = chCenterY - (min * chMaxAmpPx * waveScale);
          const barHeight = Math.max(1, bottomY - topY);
          ctx.fillRect(i, topY, 1, barHeight);
        }
      }
      // 스테레오: 채널 구분선 + 라벨
      if (isStereo) {
        const divY = channelHeight;
        ctx.strokeStyle = isDarkMode ? '#555' : '#ccc';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(0, divY);
        ctx.lineTo(displayWidth, divY);
        ctx.stroke();
        ctx.setLineDash([]);
        // 채널 라벨
        ctx.font = 'bold 10px sans-serif';
        ctx.fillStyle = isDarkMode ? '#888' : '#aaa';
        ctx.fillText('L', 4, 14);
        ctx.fillText('R', 4, channelHeight + 14);
      }
      // 세그먼트, 선택 영역, 재생 위치 그리기
      if (track.segments) {
        track.segments.forEach(seg => {
          if (seg.end > startTime && seg.start < endTime) {
            const x1 = ((seg.start - startTime) / viewDuration) * displayWidth;
            const x2 = ((seg.end - startTime) / viewDuration) * displayWidth;
            // ✅ 화자별 색상 적용
            const speakerIdx = getSpeakerColorIndex(seg.label, seg.speakerGroup);
            const colors = speakerIdx >= 0 ? SPEAKER_COLORS[speakerIdx] : {
              bg: 'rgba(40, 167, 69, 0.2)',
              border: 'rgba(40, 167, 69, 0.6)',
              text: '#28a745'
            };
            ctx.fillStyle = colors.bg;
            ctx.fillRect(x1, 0, x2 - x1, displayHeight);
            const isHoverStart = (resizeState.id === seg.id && resizeState.side === 'start');
            ctx.fillStyle = isHoverStart ? colors.text : colors.border;
            const widthStart = isHoverStart ? 3 : 1;
            ctx.fillRect(x1, 0, widthStart, displayHeight);
            const isHoverEnd = (resizeState.id === seg.id && resizeState.side === 'end');
            ctx.fillStyle = isHoverEnd ? colors.text : colors.border;
            const widthEnd = isHoverEnd ? 3 : 1;
            ctx.fillRect(x2 - widthEnd, 0, widthEnd, displayHeight);
            ctx.font = '11px sans-serif';
            ctx.fillStyle = colors.text;
            ctx.fillText(seg.label, x1 + 4, displayHeight - 8);
          }
        });
      }
      // ✅ 마커 그리기
      if (track.markers) {
        track.markers.forEach(marker => {
          if (marker.time >= startTime && marker.time <= endTime) {
            const x = ((marker.time - startTime) / viewDuration) * displayWidth;
            const isHovered = (markerDragState.id === marker.id);
            // 마커 세로선
            ctx.strokeStyle = isHovered ? '#ffc107' : '#ff9800';
            ctx.lineWidth = isHovered ? 4 : 2;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, displayHeight);
            ctx.stroke();
            // 마커 삼각형 (하단)
            ctx.fillStyle = isHovered ? '#ffc107' : '#ff9800';
            ctx.beginPath();
            ctx.moveTo(x, displayHeight);
            ctx.lineTo(x - 6, displayHeight - 12);
            ctx.lineTo(x + 6, displayHeight - 12);
            ctx.closePath();
            ctx.fill();
            // 마커 라벨
            ctx.font = isHovered ? 'bold 10px sans-serif' : '10px sans-serif';
            ctx.fillStyle = isHovered ? '#ffc107' : '#ff9800';
            ctx.fillText(marker.label, x + 8, displayHeight - 14);
          }
        });
      }
      if (selStartTime !== null && selEndTime !== null) {
        const s = Math.min(selStartTime, selEndTime);
        const e = Math.max(selStartTime, selEndTime);
        if (e > startTime && s < endTime) {
          const x1 = ((s - startTime) / viewDuration) * displayWidth;
          const x2 = ((e - startTime) / viewDuration) * displayWidth;
          ctx.fillStyle = selectionColor;
          ctx.fillRect(x1, 0, x2 - x1, displayHeight);
          ctx.fillStyle = selectionColor.replace('0.25', '0.7');
          ctx.fillRect(x1, 0, 1, displayHeight);
          ctx.fillRect(x2 - 1, 0, 1, displayHeight);
        }
      }
      if (anchorTime >= startTime && anchorTime <= endTime) {
        const relativeAnchor = anchorTime - startTime;
        const anchorX = Math.floor(displayWidth * (relativeAnchor / viewDuration));
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.25)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.moveTo(anchorX, 0);
        ctx.lineTo(anchorX, displayHeight);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      // Time display removed - handled by updateTimeInfoPanel()
      if (waveViewParams.currentTime >= startTime && waveViewParams.currentTime <= endTime) {
        const relativeTime = waveViewParams.currentTime - startTime;
        const progressInView = relativeTime / viewDuration;
        const cursorX = Math.floor(displayWidth * progressInView);
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(cursorX, 0, 1.5, displayHeight);
      }
      // [NEW] Update time info panel
      updateTimeInfoPanel();
      // ... 파형 그리기 코드 ...
      // 녹음 중일 때 현재 위치 빨간 선만 표시 (REC 텍스트 제거)
      if (isRecording && !isPaused && activeTrackIndex >= 0 && tracks[activeTrackIndex]?.duration > 0) {
        const track = tracks[activeTrackIndex];
        const scrollContainer = $('timelineScroll');
        const totalWidth = displayWidth * zoomLevel;
        const scrollLeft = scrollContainer ? scrollContainer.scrollLeft : 0;
        const viewDuration = track.duration / zoomLevel;
        const startTime = (scrollLeft / totalWidth) * track.duration;
        const endTime = startTime + viewDuration;
        if (track.duration >= startTime && track.duration <= endTime) {
          const recordingX = ((track.duration - startTime) / viewDuration) * displayWidth;
          ctx.strokeStyle = '#f44336';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(recordingX, 0);
          ctx.lineTo(recordingX, displayHeight);
          ctx.stroke();
        }
      }
      isRendering = false;
    }
    // 녹음 상태 표시 (웨이브 캔버스에 직접 그리기)
    function drawRecordingStatus(ctx, width, height) {
      // 녹음 시간 계산
      let elapsedMs = Date.now() - recordingStartTime - pausedDuration;
      if (isPaused) {
        elapsedMs -= (Date.now() - pauseStartTime);
      }
      const recMins = Math.floor(elapsedMs / 60000);
      const recSecs = Math.floor((elapsedMs % 60000) / 1000);
      const recMs = Math.floor((elapsedMs % 1000) / 100);
      const timeStr = String(recMins).padStart(2, '0') + ':' +
        String(recSecs).padStart(2, '0') + '.' + recMs;
      // 상태 텍스트
      const isInsertMode = insertTargetTrackIndex >= 0;
      const modeText = isInsertMode ? ' [삽입]' : '';
      const recStatus = isPaused ? '⏸ PAUSED: ' : '🔴 REC: ';
      // 반투명 배경 (삽입 모드일 때 더 넓게)
      const bgWidth = isInsertMode ? 175 : 140;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(5, 5, bgWidth, 28);
      // 텍스트
      ctx.fillStyle = isPaused ? '#ff9800' : '#f44336';
      ctx.font = 'bold 14px monospace';
      ctx.fillText(recStatus + timeStr + modeText, 12, 24);
      // 녹음 중일 때 현재 녹음 위치 빨간 선
      if (!isPaused && activeTrackIndex >= 0 && tracks[activeTrackIndex]?.buffer) {
        const track = tracks[activeTrackIndex];
        const scrollContainer = $('timelineScroll');
        const totalWidth = width * zoomLevel;
        const scrollLeft = scrollContainer ? scrollContainer.scrollLeft : 0;
        const viewDuration = track.duration / zoomLevel;
        const startTime = (scrollLeft / totalWidth) * track.duration;
        const endTime = startTime + viewDuration;
        // 녹음 끝 위치가 현재 뷰에 있을 때만 빨간 선 표시
        if (track.duration >= startTime && track.duration <= endTime) {
          const recordingX = ((track.duration - startTime) / viewDuration) * width;
          ctx.strokeStyle = '#f44336';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(recordingX, 0);
          ctx.lineTo(recordingX, height);
          ctx.stroke();
        }
      }
    }

    function updateTimeInfoPanel() {
      // 재생 위치
      $('timeInfoCurrent').textContent = formatTime(waveViewParams.currentTime);
      // 화면 시작/끝/간격
      $('timeInfoViewStart').textContent = formatTime(waveViewParams.startTime);
      $('timeInfoViewEnd').textContent = formatTime(waveViewParams.endTime);
      $('timeInfoViewDur').textContent = formatTime(waveViewParams.viewDuration);
      // 구간 시작/끝/간격
      if (selStartTime !== null && selEndTime !== null) {
        const s = Math.min(selStartTime, selEndTime);
        const e = Math.max(selStartTime, selEndTime);
        const dur = e - s;
        $('timeInfoSelStart').textContent = formatTime(s);
        $('timeInfoSelEnd').textContent = formatTime(e);
        $('timeInfoSelDur').textContent = formatTime(dur);
      } else {
        $('timeInfoSelStart').textContent = '-';
        $('timeInfoSelEnd').textContent = '-';
        $('timeInfoSelDur').textContent = '-';
      }
    }

    function drawGrid(ctx, width, height, viewDuration, startTime, centerY, maxAmpPx) {
      const isDarkMode = document.documentElement.classList.contains('dark-mode');
      ctx.lineWidth = 1;
      ctx.font = '10px sans-serif';
      ctx.fillStyle = isDarkMode ? '#999' : '#999';
      const pixelsPerSecond = width / viewDuration;
      const minPixelSpacing = 100;
      const steps = [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 1200, 1800, 3600];
      let timeStep = steps[steps.length - 1];
      for (let s of steps) {
        if (s * pixelsPerSecond >= minPixelSpacing) {
          timeStep = s;
          break;
        }
      }
      const firstGridTime = Math.ceil(startTime / timeStep) * timeStep;
      ctx.strokeStyle = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : '#e0e0e0';
      ctx.beginPath();
      for (let t = firstGridTime; t < startTime + viewDuration; t += timeStep) {
        const relativeT = t - startTime;
        const x = (relativeT / viewDuration) * width;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.fillText(formatGridTime(t, timeStep), x + 4, 12);
      }
      ctx.stroke();
      // ✅ 스테레오 여부 확인: 채널 영역 목록 구성 (top/bottom 경계 포함)
      let channelRegions;
      const liveIsStereo = (isRecording && recordChannels >= 2);
      if (activeTrackIndex >= 0 && (tracks[activeTrackIndex]?.buffer?.numberOfChannels >= 2 || liveIsStereo)) {
        const chH = height / 2;
        channelRegions = [
          { centerY: chH / 2, maxAmpPx: chH / 2, top: 0, bottom: chH },
          { centerY: chH + chH / 2, maxAmpPx: chH / 2, top: chH, bottom: height }
        ];
      } else {
        channelRegions = [{ centerY, maxAmpPx, top: 0, bottom: height }];
      }
      // ✅ 각 채널 영역에 dB 레벨 라인 + 라벨 (클리핑 적용)
      const dbLevels = [0, -6, -12];
      ctx.fillStyle = isDarkMode ? 'rgba(255, 255, 255, 0.6)' : '#999';
      ctx.textAlign = 'right';
      channelRegions.forEach(region => {
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, region.top, width, region.bottom - region.top);
        ctx.clip();
        ctx.strokeStyle = isDarkMode ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0,0,0,0.05)';
        ctx.fillStyle = isDarkMode ? 'rgba(255, 255, 255, 0.6)' : '#999';
        dbLevels.forEach(db => {
          const amp = Math.pow(10, db / 20);
          const scaledY = amp * region.maxAmpPx * waveScale;
          const y1 = region.centerY - scaledY;
          const y2 = region.centerY + scaledY;
          ctx.beginPath();
          ctx.moveTo(0, y1);
          ctx.lineTo(width, y1);
          ctx.stroke();
          ctx.fillText(`${db}dB`, width - 4, y1 + 3);
          if (db !== -Infinity) {
            ctx.beginPath();
            ctx.moveTo(0, y2);
            ctx.lineTo(width, y2);
            ctx.stroke();
          }
        });
        // 중앙선
        ctx.strokeStyle = isDarkMode ? 'rgba(255, 255, 255, 0.2)' : '#ccc';
        ctx.beginPath();
        ctx.moveTo(0, region.centerY);
        ctx.lineTo(width, region.centerY);
        ctx.stroke();
        ctx.restore();
      });
      // 적정 볼륨 dB 기준선
      if (showTargetDb) {
        const targetAmp = Math.pow(10, targetDbLevel / 20);
        ctx.strokeStyle = '#4caf50';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.fillStyle = '#4caf50';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'right';
        channelRegions.forEach(region => {
          ctx.save();
          ctx.beginPath();
          ctx.rect(0, region.top, width, region.bottom - region.top);
          ctx.clip();
          const scaledY = targetAmp * region.maxAmpPx * waveScale;
          const y1 = region.centerY - scaledY;
          const y2 = region.centerY + scaledY;
          ctx.beginPath();
          ctx.moveTo(0, y1);
          ctx.lineTo(width, y1);
          ctx.moveTo(0, y2);
          ctx.lineTo(width, y2);
          ctx.stroke();
          ctx.fillText(targetDbLevel + 'dB', width - 4, y1 - 3);
          ctx.restore();
        });
        ctx.setLineDash([]);
      }
      ctx.textAlign = 'left';
    }

    function formatGridTime(sec, step) {
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.floor(sec % 60);
      const remainder = sec % 1;
      // 1시간 이상이면 h:mm:ss
      if (sec >= 3600) return `${h}:${m < 10 ? '0'+m : m}:${s < 10 ? '0'+s : s}`;
      // 1분 이상이면 m:ss
      if (step >= 1) return `${m}:${s < 10 ? '0'+s : s}`;
      // 0.1초 이상이면 소수점 1자리
      if (step >= 0.1) return `${m}:${s < 10 ? '0'+s : s}.${Math.floor(remainder * 10)}`;
      // 그 외 밀리초
      const msVal = Math.floor(remainder * 1000);
      return `${m}:${s < 10 ? '0'+s : s}.${msVal.toString().padStart(3, '0')}`;
    }

    function applyZoomCenter(newLevel) {
      if (activeTrackIndex === -1) return;
      const anchor = playbackOffset;
      const track = tracks[activeTrackIndex];
      const container = $('waveContainer');
      const scrollContainer = $('timelineScroll');
      const spacer = $('timelineSpacer');
      zoomLevel = newLevel;
      if (zoomLevel < 1.0) zoomLevel = 1.0;
      // [NEW] 5분 제한: 최대 표시 범위를 5분으로 제한
      const displayWidth = container.clientWidth;
      const maxViewDuration = 300; // 5분
      const minZoomForDuration = (track.duration / maxViewDuration);
      if (zoomLevel < minZoomForDuration) {
        zoomLevel = minZoomForDuration;
      }
      // ✅ 최대 확대 제한: 화면에 0.01초만 보이도록
      const minViewDuration = 0.01; // 0.01초
      const maxZoomLevel = track.duration / minViewDuration;
      if (zoomLevel > maxZoomLevel) {
        zoomLevel = maxZoomLevel;
      }
      const totalWidth = displayWidth * zoomLevel;
      spacer.style.width = `${totalWidth}px`;
      const anchorPixel = (anchor / track.duration) * totalWidth;
      const targetScroll = anchorPixel - (displayWidth / 2);
      scrollContainer.scrollLeft = targetScroll;
      drawWaveform();
    }

    function zoomIn() {
      // 선택 영역이 있으면 해당 영역을 화면에 맞춤
      if (activeTrackIndex !== -1 && selStartTime !== null && selEndTime !== null) {
        const start = Math.min(selStartTime, selEndTime);
        const end = Math.max(selStartTime, selEndTime);
        const selectionDuration = end - start;
        // 선택 영역이 너무 짧으면 (0.01초 미만) 일반 확대
        if (selectionDuration < 0.01) {
          applyZoomCenter(zoomLevel * 1.8);
          return;
        }
        zoomToSelection(start, end);
      } else {
        // 선택 영역 없으면 기존처럼 중앙 기준 확대
        applyZoomCenter(zoomLevel * 1.8);
      }
    }

    function zoomOut() {
      applyZoomCenter(zoomLevel / 1.8);
    } // ✅ 1.5 → 1.8
    function zoomFit() {
      zoomLevel = 1.0;
      $('timelineScroll').scrollLeft = 0;
      drawWaveform();
    }
    // 선택 영역을 화면에 맞추는 함수
    function zoomToSelection(startTime, endTime) {
      if (activeTrackIndex === -1) return;
      const track = tracks[activeTrackIndex];
      const container = $('waveContainer');
      const scrollContainer = $('timelineScroll');
      const spacer = $('timelineSpacer');
      const selectionDuration = endTime - startTime;
      const displayWidth = container.clientWidth;
      // ✅ 수정: 선택 영역이 화면의 90%를 차지하도록 (양쪽 5%씩 여백)
      // 여백 비율: 0.9 = 90% 사용, 양쪽 5%씩 여백
      const paddingRatio = 0.9;
      const targetZoomLevel = (track.duration / selectionDuration) * paddingRatio;
      // 최소/최대 줌 레벨 체크
      zoomLevel = targetZoomLevel;
      if (zoomLevel < 1.0) zoomLevel = 1.0;
      // 5분 제한 체크
      const maxViewDuration = 300;
      const minZoomForDuration = (track.duration / maxViewDuration);
      if (zoomLevel < minZoomForDuration) {
        zoomLevel = minZoomForDuration;
      }
      const totalWidth = displayWidth * zoomLevel;
      spacer.style.width = `${totalWidth}px`;
      // 선택 영역의 중심점을 화면 중앙에 배치
      const selectionCenter = (startTime + endTime) / 2;
      const centerPixel = (selectionCenter / track.duration) * totalWidth;
      const targetScroll = centerPixel - (displayWidth / 2);
      scrollContainer.scrollLeft = Math.max(0, targetScroll);
      drawWaveform();
      // 확대 비율 표시
      const zoomRatio = (targetZoomLevel / 1.0).toFixed(1);
      showCenterToast(`선택 영역 확대 (${zoomRatio}x)`);
    }
    const waveContainer = $('waveContainer');

    function getTimeFromX(clientX) {
      if (activeTrackIndex === -1) return 0;
      const container = $('waveContainer');
      const scrollContainer = $('timelineScroll');
      const track = tracks[activeTrackIndex];
      const rect = container.getBoundingClientRect();
      const mouseX = clientX - rect.left;
      const width = container.clientWidth;
      const totalWidth = width * zoomLevel;
      const scrollLeft = scrollContainer.scrollLeft;
      const startTime = (scrollLeft / totalWidth) * track.duration;
      const viewDuration = track.duration / zoomLevel;
      const ratio = Math.max(0, Math.min(1, mouseX / width));
      return Math.min(track.duration, Math.max(0, startTime + (ratio * viewDuration)));
    }

    function dragScrollLoop() {
      if (!isDragging && !resizeState.id) return;
      if (edgeScrollSpeed !== 0) {
        const scrollContainer = $('timelineScroll');
        scrollContainer.scrollLeft += edgeScrollSpeed;
        // [NEW] 드래그 중에는 60fps로 제한 (16ms)
        const now = performance.now();
        if (now - lastDragDraw > 16) {
          if (resizeState.id) {
            drawWaveform();
          } else {
            if (selStartTime === null) selStartTime = getTimeFromX(lastMouseX);
            selEndTime = getTimeFromX(lastMouseX);
            drawWaveform();
          }
          lastDragDraw = now;
        }
      }
      requestAnimationFrame(dragScrollLoop);
    }
    waveContainer.addEventListener('mousedown', (e) => {
      if (activeTrackIndex === -1 || e.button !== 0) return;
      const time = getTimeFromX(e.clientX);
      // ✅ Ctrl+클릭: 해당 위치의 세그먼트 선택
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        selectSegmentAtTime(time);
        return;
      }
      // [NEW] Shift+클릭 구간 선택
      if (e.shiftKey) {
        // ✅ 마커 드래그 모드
        if (markerDragState.id) {
          isDragging = true;
          lastMouseX = e.clientX;
          dragScrollLoop();
          return;
        }
        if (resizeState.id && resizeState.side) {
          // 세그먼트 리사이즈 모드
          isDragging = true;
          lastMouseX = e.clientX;
          dragScrollLoop();
          return;
        }
        // Shift+클릭 구간 선택 로직
        if (selStartTime !== null && selEndTime !== null && Math.abs(selEndTime - selStartTime) > 0.001) {
          // 이미 구간이 있으면: 가까운 쪽 끝점 이동
          const distToStart = Math.abs(time - selStartTime);
          const distToEnd = Math.abs(time - selEndTime);
          if (distToStart < distToEnd) {
            selStartTime = snapToZeroCrossing(time);
            // 재생바를 구간 시작으로
            playbackOffset = Math.min(selStartTime, selEndTime);
            anchorTime = playbackOffset;
          } else {
            selEndTime = snapToZeroCrossing(time);
            // 재생바를 구간 시작으로
            playbackOffset = Math.min(selStartTime, selEndTime);
            anchorTime = playbackOffset;
          }
        } else if (shiftClickStart !== null) {
          // 첫 클릭 후 Shift+클릭: 구간 완성
          const snappedTime = snapToZeroCrossing(time);
          selStartTime = Math.min(shiftClickStart, snappedTime);
          selEndTime = Math.max(shiftClickStart, snappedTime);
          // 재생바를 구간 시작으로
          playbackOffset = selStartTime;
          anchorTime = selStartTime;
          shiftClickStart = null;
        }
        drawWaveform();
        return;
      }
      // 일반 클릭 (Shift 없이): 항상 첫 클릭으로 설정
      const snappedTime = snapToZeroCrossing(time);
      shiftClickStart = snappedTime;
      selStartTime = snappedTime;
      selEndTime = snappedTime;
      handleSeekClick(time);
      // 드래그 시작
      isDragging = true;
      dragStartX = e.clientX;
      lastMouseX = e.clientX;
      dragScrollLoop();
      drawWaveform();
    });
    let isTicking = false;
    waveContainer.addEventListener('mousemove', (e) => {
      if (activeTrackIndex === -1) return;
      lastMouseX = e.clientX;
      if (!isTicking) {
        window.requestAnimationFrame(() => {
          handleMouseMove(e);
          isTicking = false;
        });
        isTicking = true;
      }
    });

    function handleMouseMove(e) {
      const track = tracks[activeTrackIndex];
      // ✅ 마커 드래그 중 처리
      if (markerDragState.id && isDragging) {
        const newTime = getTimeFromX(e.clientX);
        const marker = track.markers.find(m => m.id === markerDragState.id);
        if (marker) {
          marker.time = Math.max(0, Math.min(track.duration, newTime));
          track.isDirty = true;
          minimapNeedsRedraw = true;
          renderMarkerList();
          renderPlaylist();
          drawWaveform();
        }
        const rect = waveContainer.getBoundingClientRect();
        const mouseRelX = e.clientX - rect.left;
        if (mouseRelX < 50) edgeScrollSpeed = -5;
        else if (mouseRelX > rect.width - 50) edgeScrollSpeed = 5;
        else edgeScrollSpeed = 0;
        return;
      }
      if (resizeState.id && isDragging) {
        const newTime = getTimeFromX(e.clientX);
        const seg = track.segments.find(s => s.id === resizeState.id);
        if (seg) {
          if (resizeState.side === 'start') {
            seg.start = Math.min(newTime, seg.end - 0.01);
            seg.start = Math.max(0, seg.start);
          } else {
            seg.end = Math.max(newTime, seg.start + 0.01);
            seg.end = Math.min(track.duration, seg.end);
          }
          track.isDirty = true;
          minimapNeedsRedraw = true;
          renderSegmentList();
          renderPlaylist();
          drawWaveform();
        }
        // 현재 마우스 위치의 컨테이너 찾기
        const rect = waveContainer.getBoundingClientRect();
        const mouseRelX = e.clientX - rect.left;
        if (mouseRelX < 50) edgeScrollSpeed = -5;
        else if (mouseRelX > rect.width - 50) edgeScrollSpeed = 5;
        else edgeScrollSpeed = 0;
        return;
      }
      if (!isDragging) {
        if (!e.shiftKey) {
          let needRedraw = false;
          if (resizeState.id) {
            resizeState = { id: null, side: null };
            needRedraw = true;
          }
          if (markerDragState.id) {
            markerDragState = { id: null };
            needRedraw = true;
          }
          if (needRedraw) {
            waveContainer.style.cursor = 'text';
            drawWaveform();
          }
          return;
        }
        // 현재 마우스 위치의 컨테이너 찾기
        const rect = waveContainer.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const width = waveContainer.clientWidth;
        const scrollLeft = $('timelineScroll').scrollLeft;
        const totalWidth = width * zoomLevel;
        const viewDur = track.duration / zoomLevel;
        const startTime = (scrollLeft / totalWidth) * track.duration;
        const getX = (t) => ((t - startTime) / viewDur) * width;
        let hovered = false;
        let newState = {
          id: null,
          side: null
        };
        for (const seg of track.segments) {
          if (seg.end < startTime || seg.start > startTime + viewDur) continue;
          const startX = getX(seg.start);
          const endX = getX(seg.end);
          if (Math.abs(mouseX - startX) <= RESIZE_THRESHOLD) {
            waveContainer.style.cursor = 'ew-resize';
            newState = {
              id: seg.id,
              side: 'start'
            };
            hovered = true;
            break;
          } else if (Math.abs(mouseX - endX) <= RESIZE_THRESHOLD) {
            waveContainer.style.cursor = 'ew-resize';
            newState = {
              id: seg.id,
              side: 'end'
            };
            hovered = true;
            break;
          }
        }
        // ✅ 마커 호버 감지 (세그먼트 엣지에 안 걸렸을 때)
        let markerHovered = false;
        let newMarkerState = { id: null };
        if (!hovered && track.markers) {
          for (const marker of track.markers) {
            if (marker.time < startTime || marker.time > startTime + viewDur) continue;
            const markerX = getX(marker.time);
            if (Math.abs(mouseX - markerX) <= RESIZE_THRESHOLD) {
              waveContainer.style.cursor = 'ew-resize';
              newMarkerState = { id: marker.id };
              markerHovered = true;
              hovered = true;
              break;
            }
          }
        }
        if (markerDragState.id !== newMarkerState.id) {
          markerDragState = newMarkerState;
          drawWaveform();
        }
        if (resizeState.id !== newState.id || resizeState.side !== newState.side) {
          resizeState = newState;
          if (!hovered) waveContainer.style.cursor = 'text';
          drawWaveform();
        }
        return;
      }
      if (isDragging) {
        // 현재 마우스 위치의 컨테이너 찾기
        const rect = waveContainer.getBoundingClientRect();
        const mouseRelX = e.clientX - rect.left;
        if (mouseRelX < 50) {
          edgeScrollSpeed = -5;
        } else if (mouseRelX > rect.width - 50) {
          edgeScrollSpeed = 5;
        } else {
          edgeScrollSpeed = 0;
        }
        selEndTime = snapToZeroCrossing(getTimeFromX(e.clientX));
        drawWaveform();
      }
    }
    window.addEventListener('mouseup', (e) => {
      // ✅ 마커 드래그 종료
      if (markerDragState.id && isDragging) {
        isDragging = false;
        edgeScrollSpeed = 0;
        minimapNeedsRedraw = true;
        renderTranscriptPanel();
        drawWaveform();
        return;
      }
      if (resizeState.id && isDragging) {
        isDragging = false;
        edgeScrollSpeed = 0;
        minimapNeedsRedraw = true;
        drawWaveform();
        return;
      }
      if (!isDragging) return;
      isDragging = false;
      edgeScrollSpeed = 0;
      const dist = Math.abs(e.clientX - dragStartX);
      if (dist < 5) {
        selStartTime = null;
        selEndTime = null;
        handleSeekClick(getTimeFromX(e.clientX));
      } else {
        const s = Math.min(selStartTime, selEndTime);
        const eVal = Math.max(selStartTime, selEndTime);
        selStartTime = s;
        selEndTime = eVal;
        playbackOffset = s;
        anchorTime = s;
        // ✅ 재생 중 구간 변경 시 즉시 적용
        if (isPlaying && isLoopEnabled) {
          updatePlaybackRegion();
        }
      }
      minimapNeedsRedraw = true;
      drawWaveform();
    });

    function handleSeekClick(time) {
      if (activeTrackIndex === -1) return;
      const wasPlaying = isPlaying;
      if (wasPlaying) pauseAudio();
      playbackOffset = time;
      anchorTime = time;
      if (wasPlaying) playAudio();
      else drawWaveform();
    }
    $('waveContainer').addEventListener('wheel', throttle((e) => {
      if (activeTrackIndex === -1) return;
      e.preventDefault();
      // 녹음 중 줌 변경 시 수동 모드로 전환
      if (isRecording) {
        userManualZoom = true;
      }
      if (e.shiftKey || Math.abs(e.deltaX) > 0) {
        const scrollAmount = (Math.abs(e.deltaX) > 0) ? e.deltaX : e.deltaY;
        $('timelineScroll').scrollLeft += scrollAmount * 3; // ✅ 3배 빠르게
        return;
      }
      const container = $('waveContainer');
      const scrollContainer = $('timelineScroll');
      const spacer = $('timelineSpacer');
      const track = tracks[activeTrackIndex];
      const rect = container.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const currentTotalWidth = container.clientWidth * zoomLevel;
      const mouseTime = ((scrollContainer.scrollLeft + mouseX) / currentTotalWidth) * track.duration;
      const zoomFactor = 1.3; // ✅ 1.1 → 1.3 (약 2배 빠름)
      if (e.deltaY < 0) zoomLevel *= zoomFactor;
      else zoomLevel /= zoomFactor;
      if (zoomLevel < 1.0) zoomLevel = 1.0;
      const displayWidth = container.clientWidth;
      const maxViewDuration = 300;
      const minZoomForDuration = (track.duration / maxViewDuration);
      if (zoomLevel < minZoomForDuration) {
        zoomLevel = minZoomForDuration;
      }
      // ✅ 최대 확대 제한: 화면에 0.01초만 보이도록
      const minViewDuration = 0.01;
      const maxZoomLevel = track.duration / minViewDuration;
      if (zoomLevel > maxZoomLevel) {
        zoomLevel = maxZoomLevel;
      }
      const newTotalWidth = container.clientWidth * zoomLevel;
      spacer.style.width = `${newTotalWidth}px`;
      const newScrollLeft = ((mouseTime / track.duration) * newTotalWidth) - mouseX;
      scrollContainer.scrollLeft = newScrollLeft;
      // 녹음 중이면 현재 보이는 시간 간격 저장
      if (isRecording && track.duration > 0) {
        recordingViewDuration = track.duration / zoomLevel;
        liveZoomLevel = zoomLevel;
      }
      drawWaveform();
    }, 100), {
      passive: false
    });
    const miniWrap = $('minimapWrapper');

    function handleMinimapScrub(e) {
      if (activeTrackIndex === -1) return;
      const rect = miniWrap.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const ratio = Math.max(0, Math.min(1, x / rect.width));
      const track = tracks[activeTrackIndex];
      const scrollContainer = $('timelineScroll');
      const waveContainer = $('waveContainer');
      const totalWidth = waveContainer.clientWidth * zoomLevel;
      const targetPx = totalWidth * ratio;
      scrollContainer.scrollLeft = targetPx - (waveContainer.clientWidth / 2);
      drawWaveform();
    }
    miniWrap.addEventListener('mousedown', (e) => {
      isMinimapDragging = true;
      handleMinimapScrub(e);
    });
    window.addEventListener('mousemove', (e) => {
      if (isMinimapDragging) handleMinimapScrub(e);
    });
    window.addEventListener('mouseup', () => {
      isMinimapDragging = false;
    });
    async function handleFileSelect(e) {
      try {
        const target = (e.files) ? e : e.target;
        if (!target || !target.files) return;
        const files = Array.from(target.files);
        if (files.length === 0) return;
        initAudioContext();
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        $('fileChip').textContent = '파일 처리 중...';
        for (const file of files) {
          try {
            console.log(`📁 파일 로드 시작: ${file.name} (${file.size} bytes)`);
            const arrayBuffer = await file.arrayBuffer();
            console.log(`📦 ArrayBuffer 크기: ${arrayBuffer.byteLength} bytes`);
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0)); // slice로 복사본 사용
            console.log(`🎵 디코딩 완료: ${audioBuffer.duration.toFixed(2)}초, ${audioBuffer.sampleRate}Hz, ${audioBuffer.numberOfChannels}채널`);
            // ✅ WAV 메타데이터 파싱 (마커/세그먼트 로드)
            let loadedMarkers = [];
            let loadedSegments = [];
            if (file.name.toLowerCase().endsWith('.wav')) {
              try {
                const metadata = parseWavMetadata(arrayBuffer);
                loadedMarkers = metadata.markers || [];
                loadedSegments = metadata.segments || [];
                if (loadedMarkers.length > 0 || loadedSegments.length > 0) {
                  console.log(`📂 메타데이터 로드: 마커 ${loadedMarkers.length}개, 세그먼트 ${loadedSegments.length}개`);
                  showCenterToast(`마커 ${loadedMarkers.length}개, 세그먼트 ${loadedSegments.length}개 로드됨`);
                }
              } catch (metaErr) {
                console.warn('⚠️ 메타데이터 파싱 실패 (무시):', metaErr);
              }
            }
            // ✅ 디코딩 직후 데이터 확인
            const ch0 = audioBuffer.getChannelData(0);
            // ✅ 첫 비제로 샘플 위치 찾기
            const firstNonZero = ch0.findIndex(v => Math.abs(v) > 0.0001);
            // ✅ RMS 계산
            const rms = Math.sqrt(ch0.reduce((sum, v) => sum + v * v, 0) / ch0.length);
            // ✅ 최대 진폭 찾기
            let maxAbs = 0;
            let maxAbsIndex = -1;
            for (let i = 0; i < ch0.length; i++) {
              const abs = Math.abs(ch0[i]);
              if (abs > maxAbs) {
                maxAbs = abs;
                maxAbsIndex = i;
              }
            }
            console.log(`• 첫 비제로 샘플 위치: ${firstNonZero} (${(firstNonZero / audioBuffer.sampleRate).toFixed(3)}초)`);
            console.log(`• 최대 진폭: ${maxAbs.toFixed(6)} (위치: ${maxAbsIndex}, ${(maxAbsIndex / audioBuffer.sampleRate).toFixed(3)}초)`);
            console.log(`• RMS: ${rms.toFixed(6)}`);
            console.log(`• 첫 10개 샘플: [${Array.from(ch0.slice(0, 10)).map(v => v.toFixed(3)).join(', ')}]`);
            console.log(`• 첫 비제로 샘플 주변 (${firstNonZero - 5} ~ ${firstNonZero + 5}): [${Array.from(ch0.slice(Math.max(0, firstNonZero - 5), firstNonZero + 5)).map(v => v.toFixed(3)).join(', ')}]`);
            console.log(`• 최대 진폭 주변 (${maxAbsIndex - 5} ~ ${maxAbsIndex + 5}): [${Array.from(ch0.slice(Math.max(0, maxAbsIndex - 5), maxAbsIndex + 5)).map(v => v.toFixed(3)).join(', ')}]`);
            if (firstNonZero === -1 || rms < 0.0001) {
              console.error(`❌ 경고: "${file.name}" 파일의 오디오 데이터가 비어있습니다!`);
              alert(`파일 "${file.name}"의 오디오 데이터가 비어있습니다. 다른 파일을 선택해주세요.`);
              continue;
            }
            const uniqueName = getUniqueName(file.name);
            tracks.push({
              id: Date.now() + Math.random(),
              name: uniqueName,
              buffer: audioBuffer,
              duration: audioBuffer.duration,
              selected: false,
              segments: loadedSegments.length > 0 ? loadedSegments : [], // ✅ 메타데이터에서 로드
              markers: loadedMarkers.length > 0 ? loadedMarkers : [], // ✅ 메타데이터에서 로드
              isDirty: false
            });
          } catch (err) {
            console.error(`❌ 파일 처리 오류 (${file.name}):`, err);
            alert(`파일 "${file.name}" 로드 실패: ${err.message}`);
          }
        }
        tracks.sort((a, b) => a.name.localeCompare(b.name));
        if (activeTrackIndex === -1 && tracks.length > 0) selectTrack(0);
        else renderPlaylist();
        updateInfoChip();
        $('fileInput').value = '';
      } catch (criticalErr) {
        console.error('❌ 치명적 오류:', criticalErr);
        alert("오류 발생: " + criticalErr.message);
        $('fileChip').textContent = '오류 발생';
      }
    }

    function updateInfoChip() {
      if (activeTrackIndex >= 0) {
        const t = tracks[activeTrackIndex];
        // [NEW] Show dirty status
        $('fileChip').textContent = `선택됨: ${t.name}${t.isDirty ? ' *' : ''}`;
      } else {
        $('fileChip').textContent = '선택된 파일 없음';
        $('timeDisplay').textContent = '00:00.000';
      }
    }
    window.toggleTrackSelect = function(e, index) {
      e.stopPropagation();
      if (index >= 0) tracks[index].selected = e.target.checked;
      renderPlaylist();
    }

    function selectAllTracks() {
      // 검색 필터 적용된 트랙만 선택
      const query = playlistSearchQuery.toLowerCase().trim();
      if (query) {
        tracks.forEach(t => {
          t.selected = t.name.toLowerCase().includes(query);
        });
        const count = tracks.filter(t => t.selected).length;
        showCenterToast(`검색 결과 ${count}개 트랙 선택됨`);
      } else {
        tracks.forEach(t => t.selected = true);
        showCenterToast(`전체 ${tracks.length}개 트랙 선택됨`);
      }
      renderPlaylist();
    }

    function deselectAllTracks() {
      tracks.forEach(t => t.selected = false);
      multiSelectAnchor = -1;
      renderPlaylist();
      showCenterToast('선택 해제됨');
    }
    // [NEW] Custom Confirm Logic Variables
    let pendingRemoveTracks = [];

    function deleteSelectedTracks() {
      const selected = tracks.filter(t => t.selected);
      if (selected.length === 0) return;
      // Check if any selected track is dirty
      const hasDirty = selected.some(t => t.isDirty);
      // If clean, remove immediately (Silent Remove)
      if (hasDirty) {
        pendingRemoveTracks = selected;
        $('customModal').classList.add('open');
      } else {
        performRemoval(selected);
      }
    }

    function performRemoval(targets) {
      const activeTrack = activeTrackIndex >= 0 ? tracks[activeTrackIndex] : null;
      const wasActiveRemoved = activeTrack && targets.includes(activeTrack);
      if (wasActiveRemoved) stopAudio();
      // Remove targets from tracks array
      tracks = tracks.filter(t => !targets.includes(t));
      // ✅ 활성 트랙이 삭제된 경우 처리
      if (wasActiveRemoved) {
        if (tracks.length > 0) {
          // ✅ 다음 파일 선택 (삭제된 위치 또는 마지막 파일)
          const newIndex = Math.min(activeTrackIndex, tracks.length - 1);
          selectTrack(newIndex);
          showCenterToast(`"${tracks[newIndex].name}" 파일로 전환됨`);
        } else {
          // ✅ 파일이 없으면 초기화
          activeTrackIndex = -1;
          resetEditorState();
        }
      } else {
        // 활성 트랙이 삭제되지 않았으면 인덱스만 재계산
        activeTrackIndex = tracks.findIndex(t => t.id === activeTrack.id);
      }
      renderPlaylist();
      updateInfoChip();
    }
    // ✅ 새 함수: 에디터 상태 초기화
    function resetEditorState() {
      stopAudio();
      // 파형 영역 초기화
      $('wavePlaceholder').style.display = 'flex';
      $('waveCanvas').style.display = 'none';
      // 선택 영역 초기화
      selStartTime = null;
      selEndTime = null;
      anchorTime = 0;
      playbackOffset = 0;
      // 세그먼트 리스트 초기화
      const segContainer = $('segmentListContainer');
      if (segContainer) {
        segContainer.innerHTML = '<div class="listHeader">📋 세그먼트</div><div class="placeholder">저장된 세그먼트가 없습니다</div>';
      }
      // 마커 리스트 초기화
      const markerContainer = $('markerListContainer');
      if (markerContainer) {
        markerContainer.innerHTML = '<div class="listHeader" style="color: #e65100;">📍 마커</div><div class="placeholder">저장된 마커가 없습니다</div>';
      }
      // 선택 인덱스 초기화
      selectedSegmentIndex = -1;
      selectedMarkerIndex = -1;
      // 미니맵 초기화
      const minimapCanvas = $('minimapCanvas');
      if (minimapCanvas) {
        const ctx = minimapCanvas.getContext('2d');
        ctx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
      }
      // 파일 정보 초기화
      $('fileChip').textContent = '선택된 파일 없음';
      // 시간 정보 초기화
      $('timeInfoCurrent').textContent = '00:00.000';
      $('timeInfoViewStart').textContent = '00:00.000';
      $('timeInfoViewEnd').textContent = '00:00.000';
      $('timeInfoViewDur').textContent = '00:00.000';
      $('timeInfoSelStart').textContent = '-';
      $('timeInfoSelEnd').textContent = '-';
      $('timeInfoSelDur').textContent = '-';
      // 리스트 레이아웃 리셋
      resetListLayout();
      console.log('✅ 에디터 상태 초기화 완료');
    }
    // Modal Actions
    $('btnModalCancel').addEventListener('click', () => {
      $('customModal').classList.remove('open');
      pendingRemoveTracks = [];
    });
    $('btnModalRemove').addEventListener('click', () => {
      if (pendingRemoveTracks.length > 0) performRemoval(pendingRemoveTracks);
      $('customModal').classList.remove('open');
      pendingRemoveTracks = [];
    });
    $('btnModalSave').addEventListener('click', () => {
      if (pendingRemoveTracks.length === 0) return;
      // Filter dirty tracks to save
      const dirtyTracks = pendingRemoveTracks.filter(t => t.isDirty);
      dirtyTracks.forEach(t => {
        const wavBlob = audioBufferToWav(t.buffer);
        const url = URL.createObjectURL(wavBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = t.name.replace(/\.wav$/i, '') + '.wav';
        a.click();
        URL.revokeObjectURL(url);
      });
      performRemoval(pendingRemoveTracks);
      $('customModal').classList.remove('open');
      pendingRemoveTracks = [];
    });
    // Shortcut Modal Actions
    $('btnShowShortcuts').addEventListener('click', () => {
      $('shortcutModal').classList.add('open');
    });
    $('btnCloseShortcuts').addEventListener('click', () => {
      $('shortcutModal').classList.remove('open');
    });
    // Close shortcut modal when clicking outside
    $('shortcutModal').addEventListener('click', (e) => {
      if (e.target === $('shortcutModal')) {
        $('shortcutModal').classList.remove('open');
      }
    });
    window.selectTrack = function(index) {
      if (index < 0 || index >= tracks.length) return;
      stopAudio();
      activeTrackIndex = index;
      anchorTime = 0;
      playbackOffset = 0;
      // [NEW] 5분 이상 파일은 자동으로 0~5분 범위로 줌인
      const track = tracks[index];
      if (track.duration > 300) {
        const container = $('waveContainer');
        const displayWidth = container.clientWidth || 800;
        zoomLevel = track.duration / 300; // 5분이 화면에 꽉 차도록
      } else {
        zoomLevel = 1.0;
      }
      selStartTime = null;
      selEndTime = null;
      $('timelineScroll').scrollLeft = 0;
      minimapNeedsRedraw = true; // [NEW]
      renderPlaylist();
      renderSegmentList();
      updateInfoChip();
      $('wavePlaceholder').style.display = 'none';
      $('waveCanvas').style.display = 'block';
      setTimeout(() => drawWaveform(), 50);
      renderMarkerList();
      renderTranscriptPanel(); // ✅ 트랙 전환 시 전사 패널도 갱신
      resetListLayout(); // ✅ 변경: updateListLayout() → resetListLayout()
    }

    function runGAS(fn, ...args) {
      return new Promise((resolve, reject) => {
        google.script.run.withSuccessHandler(resolve).withFailureHandler(e => reject(new Error(e && e.message ? e.message : String(e))))[fn](...args);
      });
    }
    // Toggle Collapsible Section
    window.toggleSection = function(sectionId) {
      const section = $(sectionId);
      const content = section.querySelector('.collapsibleContent');
      if (section.classList.contains('collapsed')) {
        section.classList.remove('collapsed');
        content.classList.remove('collapsed');
      } else {
        section.classList.add('collapsed');
        content.classList.add('collapsed');
      }
    }
    // Dark Mode Toggle
    window.toggleDarkMode = function(enabled) {
      if (enabled) {
        document.documentElement.classList.add('dark-mode');
        localStorage.setItem('darkMode', 'enabled');
      } else {
        document.documentElement.classList.remove('dark-mode');
        localStorage.setItem('darkMode', 'disabled');
      }
    }
    // Initialize Dark Mode from localStorage
    window.initDarkMode = function() {
      const darkMode = localStorage.getItem('darkMode');
      if (darkMode !== 'disabled') {
        document.documentElement.classList.add('dark-mode');
        const chk = $('chkDarkMode');
        if (chk) chk.checked = true;
      }
    }
    // 특정 시간에 있는 세그먼트 찾기
    async function init() {
      resizeObserver = new ResizeObserver(() => {
        if (activeTrackIndex >= 0) {
          const waveContainer = $('waveContainer');
          const scrollContainer = $('timelineScroll');
          const track = tracks[activeTrackIndex];
          const newWidth = waveContainer.clientWidth;
          // 초기화 또는 너비 변화 없으면 단순 렌더링
          if (lastWaveContainerWidth === 0 || lastWaveContainerWidth === newWidth) {
            lastWaveContainerWidth = newWidth;
            drawWaveform();
            return;
          }
          // ✅ 리사이즈 전: 현재 보고 있는 시간 위치 저장
          const oldTotalWidth = lastWaveContainerWidth * zoomLevel;
          const savedStartTime = (scrollContainer.scrollLeft / oldTotalWidth) * track.duration;
          // 너비 업데이트
          lastWaveContainerWidth = newWidth;
          // ✅ 리사이즈 후: 저장된 시간 위치로 스크롤 복원
          const newTotalWidth = newWidth * zoomLevel;
          const newScrollLeft = (savedStartTime / track.duration) * newTotalWidth;
          scrollContainer.scrollLeft = newScrollLeft;
          drawWaveform();
        }
      });
      resizeObserver.observe($('waveWrapper'));
      try {
        const b = await runGAS('getBootstrap');
        $('bootLine').textContent = b.ok ? 'Ready' : '';
      } catch (e) {}
      // [NEW] 자동 세그먼트 모달 초기화
      // initAutoSegmentModal(); // removed
      // [NEW] 볼륨/게인 모달 초기화
      // initVolumeGainModals(); // removed
      // initGenerateModals(); // removed
      initExportModals();
      // initEffectsModals(); // removed
      loadEditOptions();


      initWaveResizer();
      // ✅ 추가: 드래그 앤 드롭 초기화
      initDragAndDrop();
      // ✅ 추가: 플레이리스트 키보드 네비게이션 초기화
      initPlaylistKeyboardNav();
      // ✅ 추가: 플레이리스트 검색 초기화
      initPlaylistSearch();
      // ✅ 추가: 녹음 섹션 초기화
      initRecordingSection();
      initSettingsUI();
      initSentenceRecorder();
    }

    // doLogin 함수 내부 수정 (기존 micGranted 관련 try-catch 블록 완전 삭제)
    async function doLogin() {
      const id = String($('loginId').value || '').trim(),
        pw = String($('loginPw').value || '').trim();
      if (!id) return;
      $('btnLogin').disabled = true;

      // 여기서부터 try 블록 전까지 있던 기존 micGranted 권한 요청 코드를 모두 지우세요.

      try {
        const r = await runGAS('login', id, pw);
        if (!r.ok) {
          $('loginStatus').textContent = r.reason;
          return;
        }
        App.token = r.token;
        App.user = r.user;
        $('pageLogin').style.display = 'none';
        $('pageEditor').style.display = 'block';
        setTimeout(drawWaveform, 100);
        setTimeout(checkBackupRecovery, 500);

        // 로그인 성공하여 에디터 진입 시, 여기서 마이크 목록을 호출합니다.
        await populateAudioInputDevices(false);
        showCenterToast('✅ 마이크 연결 완료!');
        
      } catch (e) {
        console.error(e);
      } finally {
        $('btnLogin').disabled = false;
      }
    }

    async function doLogout() {
      try {
        stopAudio();
        if (App.token) await runGAS('logout', App.token);
      } catch (e) {}
      $('pageEditor').style.display = 'none';
      $('pageLogin').style.display = 'flex';
    }
    $('btnLogin').addEventListener('click', doLogin);
    $('loginPw').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') doLogin()
    });
    $('btnLogoutTop').addEventListener('click', doLogout);
    $('btnImport').addEventListener('click', () => $('fileInput').click());
    // Use addEventListener instead of inline HTML onchange
    $('fileInput').addEventListener('change', handleFileSelect);
    $('btnSelectAll')?.addEventListener('click', selectAllTracks);
    $('btnDeselectAll')?.addEventListener('click', deselectAllTracks);
    $('btnDeleteTracks')?.addEventListener('click', deleteSelectedTracks);
    $('btnPlay').addEventListener('click', playAudio);
    $('btnPause').addEventListener('click', pauseAudio);
    $('btnStop').addEventListener('click', stopAudio);
    $('btnLoop').addEventListener('click', toggleLoop);
    // [NEW] Slider Controls
    $('sliderWaveScale').addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      waveScale = value / 100; // 35 -> 0.35
      $('labelWaveScale').textContent = (value / 100).toFixed(2) + 'x';
      drawWaveform();
    });
    $('btnZoomIn').addEventListener('click', zoomIn);
    $('btnZoomOut').addEventListener('click', zoomOut);
    $('btnZoomFit').addEventListener('click', zoomFit);
    $('timelineScroll').addEventListener('scroll', throttle(() => drawWaveform(), 50)); // ~20fps for better performance
    $('btnAddSegment')?.addEventListener('click', addSegment);
    // [NEW] 선택 영역 세그먼트 삭제 버튼
    $('btnDeleteSegmentsInSelection')?.addEventListener('click', deleteSegmentsInSelection);
    // ✅ 추가: 전체 세그먼트 삭제 버튼
    $('btnDeleteAllSegments')?.addEventListener('click', deleteAllSegments);
    $('btnSaveJSON')?.addEventListener('click', saveJSON);
    $('btnExportCSV')?.addEventListener('click', exportCSV);
    $('btnSaveMarkerJSON')?.addEventListener('click', saveMarkerJSON);
    $('btnExportMarkerCSV')?.addEventListener('click', exportMarkerCSV);
    $('chkAutoScroll').addEventListener('change', (e) => e.target.blur());
    // Edit Events
    $('btnUndo').addEventListener('click', performUndo);
    $('btnRedo').addEventListener('click', performRedo);
    $('btnUndoTop').addEventListener('click', performUndo);
    $('btnRedoTop').addEventListener('click', performRedo);
    // [NEW] Save Listeners (ZIP Batch Save)
    $('btnSaveSelected')?.addEventListener('click', saveSelectedTracks);
    $('btnAddMarker')?.addEventListener('click', addMarker);
    $('btnDeleteMarkersInSelection')?.addEventListener('click', deleteMarkersInSelection);
    $('btnDeleteAllMarkers')?.addEventListener('click', deleteAllMarkers);

    $('btnToggleSidebar').addEventListener('click', toggleSidebar);
    $('btnToggleSidebarOpen').addEventListener('click', toggleSidebar);
    window.addEventListener('keydown', (e) => {
      // INPUT 요소에서는 단축키 무시 (전사 입력 중 포함)
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      // 한글 입력 감지 - 영어 모드 전환 안내
      if (/[ㄱ-ㅎㅏ-ㅣ가-힣]/.test(e.key)) {
        e.preventDefault();
        showCenterToast('⚠️ 영어 입력 모드로 전환하세요', 1000);
        return;
      }
      
      // Shortcuts
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        performUndo();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
        e.preventDefault();
        performRedo();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
        e.preventDefault();
        doCopy();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'x') {
        e.preventDefault();
        doCut();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault();
        doDuplicate();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
        e.preventDefault();
        doPaste();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveSelectedTracks();
      }

      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selStartTime !== null && selEndTime !== null) {
          e.preventDefault();
          doDeleteRegion();
        }
      }
      // R 키: 녹음 시작/일시정지 토글
      if (e.key === 'r' || e.key === 'R') {
        if (e.target.matches('input, textarea, select, [contenteditable]')) return;
        e.preventDefault();
        if (!isRecording) {
          $('btnStartRecord')?.click();
        } else {
          togglePauseRecording();
        }
        return;
      }
      // P 키: 녹음 정지
      if (e.key === 'p' || e.key === 'P') {
        if (e.target.matches('input, textarea, select, [contenteditable]')) return;
        if (!isRecording) return;
        e.preventDefault();
        stopRecording();
        return;
      }

      if (e.code === 'Space') {
        e.preventDefault();
        isPlaying ? pauseAudio() : playAudio();
      }
      if (e.code === 'Escape') {
        e.preventDefault();
        stopAudio();
        anchorTime = 0;
        playbackOffset = 0;
        selStartTime = null;
        selEndTime = null;
        drawWaveform();
      }
      // 확대/축소 단축키
      if (e.key === '=' || e.key === '+') {
        e.preventDefault();
        zoomIn();
      }
      if (e.key === '-' || e.key === '_') {
        e.preventDefault();
        zoomOut();
      }
      // 좌우 방향키로 화면 이동
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (activeTrackIndex === -1) return;
        const scrollContainer = $('timelineScroll');
        const scrollAmount = scrollContainer.clientWidth * 0.2;
        scrollContainer.scrollLeft -= scrollAmount;
        drawWaveform();
      }
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        if (activeTrackIndex === -1) return;
        const scrollContainer = $('timelineScroll');
        const scrollAmount = scrollContainer.clientWidth * 0.2;
        scrollContainer.scrollLeft += scrollAmount;
        drawWaveform();
      }
      // 위/아래 방향키로 포커스된 패널에 따라 선택 이동
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (focusedPanel === 'playlist') {
          movePlaylistSelection('up', e.shiftKey);
        }
      }
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (focusedPanel === 'playlist') {
          movePlaylistSelection('down', e.shiftKey);
        }
      }
      // ✅ Ctrl+A: 플레이리스트 전체 선택
      if ((e.ctrlKey || e.metaKey) && e.key === 'a' && focusedPanel === 'playlist') {
        e.preventDefault();
        selectAllTracks();
      }
      // ✅ Enter 키로 플레이리스트에서 재생 시작
      if (e.key === 'Enter' && focusedPanel === 'playlist') {
        e.preventDefault();
        if (activeTrackIndex >= 0) {
          if (isPlaying) {
            pauseAudio();
          } else {
            playAudio();
          }
        }
      }
      // ✅ Delete 키로 플레이리스트에서 파일 제거
      if ((e.key === 'Delete' || e.key === 'Backspace') && focusedPanel === 'playlist') {
        if (activeTrackIndex >= 0 && !e.target.matches('input')) {
          e.preventDefault();
          tracks[activeTrackIndex].selected = true;
          deleteSelectedTracks();
        }
      }


    });
    // [NEW] Spectrogram helper Functions (SAFE LOCATION)
    function SimpleFFT(size) {
      this.size = size;
      this.reverse = new Uint32Array(size);
      this.sin = new Float32Array(size);
      this.cos = new Float32Array(size);
      var limit = 1,
        bit = size >> 1;
      while (limit < size) {
        for (var i = 0; i < limit; i++) this.reverse[i + limit] = this.reverse[i] + bit;
        limit <<= 1;
        bit >>= 1;
      }
      // ⬇️ 이 부분을 수정
      for (var i = 0; i < size; i++) {
        this.sin[i] = Math.sin(-Math.PI * 2 * i / size); // 수정됨
        this.cos[i] = Math.cos(-Math.PI * 2 * i / size); // 수정됨
      }
    }
    SimpleFFT.prototype.calculate = function(real, imag) {
      var n = this.size;
      for (var i = 0; i < n; i++) {
        var rev = this.reverse[i];
        if (i < rev) {
          var tr = real[i];
          real[i] = real[rev];
          real[rev] = tr;
          var ti = imag[i];
          imag[i] = imag[rev];
          imag[rev] = ti;
        }
      }
      for (var limit = 2; limit <= n; limit <<= 1) {
        var halfLimit = limit >> 1;
        var step = n / limit;
        for (var i = 0; i < n; i += limit) {
          for (var j = 0; j < halfLimit; j++) {
            var k = j * step;
            var idx1 = i + j;
            var idx2 = idx1 + halfLimit;
            var tr = this.cos[k] * real[idx2] - this.sin[k] * imag[idx2];
            var ti = this.cos[k] * imag[idx2] + this.sin[k] * real[idx2];
            real[idx2] = real[idx1] - tr;
            imag[idx2] = imag[idx1] - ti;
            real[idx1] += tr;
            imag[idx1] += ti;
          }
        }
      }
    };

    // 세그먼트/마커 리스트 공간 조정
    function updateListLayout() {
      const segContainer = $('segmentListContainer');
      const markerContainer = $('markerListContainer');
      if (!segContainer || !markerContainer) return;
      // ✅ 사용자가 리사이즈 중이면 스킵
      if (isListResizing) return;
      // ✅ 사용자가 비율을 조정한 경우 해당 비율 유지
      if (savedListRatio !== null) {
        segContainer.style.width = '';
        markerContainer.style.width = '';
        segContainer.style.flex = `${savedListRatio}`;
        markerContainer.style.flex = `${1 - savedListRatio}`;
        return; // ✅ 자동 비율 조정 스킵
      }
      const track = activeTrackIndex >= 0 ? tracks[activeTrackIndex] : null;
      const hasSegments = track && track.segments && track.segments.length > 0;
      const hasMarkers = track && track.markers && track.markers.length > 0;
      // 클래스 초기화
      segContainer.classList.remove('has-content', 'no-content', 'equal', 'full');
      markerContainer.classList.remove('has-content', 'no-content', 'equal', 'full');
      // flex 모드로 복원
      segContainer.style.flex = '';
      segContainer.style.width = '';
      markerContainer.style.flex = '';
      markerContainer.style.width = '';
      if (hasSegments && hasMarkers) {
        segContainer.classList.add('equal');
        markerContainer.classList.add('equal');
      } else if (hasSegments && !hasMarkers) {
        segContainer.classList.add('full');
        markerContainer.classList.add('no-content');
      } else if (!hasSegments && hasMarkers) {
        segContainer.classList.add('no-content');
        markerContainer.classList.add('full');
      } else {
        segContainer.classList.add('equal');
        markerContainer.classList.add('equal');
      }
    }
    // 리스트 비율 초기화 (flex 모드로 복원)
    function resetListLayout() {
      const segContainer = $('segmentListContainer');
      const markerContainer = $('markerListContainer');
      if (!segContainer || !markerContainer) return;
      // ✅ 사용자 비율 초기화
      savedListRatio = null;
      // 고정 너비 제거하고 flex 모드로
      segContainer.style.width = '';
      segContainer.style.flex = '';
      markerContainer.style.width = '';
      markerContainer.style.flex = '';
      updateListLayout();
    }

    function finishLogin(token, user) {
      // 1. 전역 변수에 저장
      App.token = token;
      App.user = user || {
        user_id: 'Launcher',
        display_name: 'Launcher User'
      };
      // 2. 상단 UI 업데이트
      const displayName = (App.user.display_name || App.user.user_id);
      const whoLine = document.getElementById('whoLine');
      if (whoLine) {
        whoLine.textContent = displayName;
        whoLine.style.display = '';
      }
      const buildChip = document.getElementById('buildChip');
      if (buildChip) {
        buildChip.textContent = "Editor v1.0.0 (런처)";
      }
      // 4. 화면 전환 (로그인창 숨김 -> 에디터 보임)
      document.getElementById('pageLogin').style.display = 'none';
      document.getElementById('pageEditor').style.display = 'block';
      // 5. 에디터 초기화 (파형 그리기)
      if (typeof drawWaveform === 'function') {
        setTimeout(drawWaveform, 100);
      }
      // 6. 자동 백업 복구 확인 (에디터 화면 표시 후)
      setTimeout(checkBackupRecovery, 500);
    }

    function initWaveResizer() {
      const resizer = $('waveResizer');
      const waveWrapper = $('waveWrapper');
      if (!resizer || !waveWrapper) return;
      let isResizing = false;
      let startY = 0;
      let startWaveH = 0;
      resizer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isResizing = true;
        startY = e.clientY;
        startWaveH = waveWrapper.offsetHeight;
        resizer.classList.add('dragging');
        document.body.style.cursor = 'row-resize';
        document.body.style.userSelect = 'none';
      });
      window.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const delta = e.clientY - startY;
        // workspace 내 사용 가능한 최대 높이 계산
        const workspace = waveWrapper.parentElement;
        const bottomBar = $('bottomRecBar');
        const resizerH = resizer.offsetHeight || 6;
        const bottomBarH = bottomBar ? bottomBar.offsetHeight : 64;
        // workspace 전체 높이에서 waveWrapper 외 요소들의 높이를 뺌
        let usedH = 0;
        for (const child of workspace.children) {
          if (child !== waveWrapper) usedH += child.offsetHeight;
        }
        const maxWaveH = workspace.clientHeight - usedH;
        const newWaveH = Math.max(100, Math.min(maxWaveH, startWaveH + delta));
        waveWrapper.style.flex = '0 1 ' + newWaveH + 'px';
      });
      window.addEventListener('mouseup', () => {
        if (!isResizing) return;
        isResizing = false;
        resizer.classList.remove('dragging');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        const canvas = $('waveCanvas');
        const cont = $('waveContainer');
        if (canvas && cont) {
          canvas.width = cont.clientWidth;
          canvas.height = cont.clientHeight;
        }
        isRendering = false;
        minimapNeedsRedraw = true;
        drawWaveform();
      });
    }

    function downloadTextFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType + ';charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // 리스트 리사이저 초기화
    function toggleSidebar() {
      const editorWrap = $('editorWrap');
      const icon = $('sidebarToggleIcon');
      const btn = $('btnToggleSidebar');
      const scrollContainer = $('timelineScroll');
      const waveContainer = $('waveContainer');
      // ✅ 토글 전: 현재 보고 있는 시간 위치 저장
      let savedStartTime = 0;
      if (activeTrackIndex >= 0) {
        const track = tracks[activeTrackIndex];
        const currentDisplayWidth = waveContainer.clientWidth;
        const currentTotalWidth = currentDisplayWidth * zoomLevel;
        savedStartTime = (scrollContainer.scrollLeft / currentTotalWidth) * track.duration;
      }
      editorWrap.classList.toggle('sidebar-collapsed');
      // 아이콘 및 툴팁 변경
      if (editorWrap.classList.contains('sidebar-collapsed')) {
        btn.title = '사이드바 열기';
      } else {
        btn.title = '사이드바 닫기';
      }
      // ✅ 토글 후: 저장된 시간 위치로 스크롤 복원
      setTimeout(() => {
        if (activeTrackIndex >= 0) {
          const track = tracks[activeTrackIndex];
          const newDisplayWidth = waveContainer.clientWidth;
          const newTotalWidth = newDisplayWidth * zoomLevel;
          // 저장된 시간 위치로 스크롤 재계산
          const newScrollLeft = (savedStartTime / track.duration) * newTotalWidth;
          scrollContainer.scrollLeft = newScrollLeft;
          drawWaveform();
        }
      }, 350);
    }
    /* ================= 런처 자동 로그인 리스너 ================= */
    document.addEventListener('DOMContentLoaded', function() {
      // Dark Mode Initialization
      if (typeof initDarkMode === 'function') {
        initDarkMode();
      }
      const chkDarkMode = document.getElementById('chkDarkMode');
      if (chkDarkMode) {
        chkDarkMode.addEventListener('change', (e) => {
          toggleDarkMode(e.target.checked);
        });
      }
      if (window.LAUNCHER_USER && window.LAUNCHER_TOKEN) {
        console.log('✅ 런처 접속 확인: 자동 로그인 진행');
        finishLogin(window.LAUNCHER_TOKEN, window.LAUNCHER_USER);
      }
    });
    // 페이지 이탈 시 마이크 스트림 자동 해제 (프라이버시 보호)
    window.addEventListener('beforeunload', () => {
      // 녹음 중이면 긴급 백업 (동기적으로 최대한 시도)
      if (isRecording && liveRecordingData.length > 0) {
        try {
          const sr = audioCtx?.sampleRate || 48000;
          const totalChunks = flushedChunksL.length + liveRecordingData.length;
          const totalLen = flushedLength + liveRecordingData.length * LIVE_CHUNK_SIZE;
          // IndexedDB는 비동기지만, beforeunload에서 시작된 트랜잭션은
          // 브라우저가 가능한 한 완료하려고 시도함
          saveBackupChunks(liveRecordingData, liveRecordingDataR, backupChunkIndex);
          saveBackupMeta({
            startTime: recordingStartTime,
            sampleRate: sr,
            channels: recordChannels,
            chunkSize: LIVE_CHUNK_SIZE,
            totalChunks: totalChunks,
            duration: totalLen / sr
          });
        } catch (e) { /* 긴급 백업 실패는 무시 */ }
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }
      if (audioCtx && audioCtx.state !== 'closed') {
        audioCtx.close();
      }
    });
    // ==================== 새 버튼 이벤트 리스너 ====================
    // 편집 섹션 - 기존 기능 연결
    $('btnCut')?.addEventListener('click', doCut);
    $('btnCopy')?.addEventListener('click', doCopy);
    $('btnPaste')?.addEventListener('click', doPaste);
    $('btnDeleteRegion')?.addEventListener('click', doDeleteRegion);
    $('btnSilenceRegion')?.addEventListener('click', doSilenceRegion);
    $('btnReverseRegion')?.addEventListener('click', doReverseRegion);
    $('btnRepeatRegion')?.addEventListener('click', showRepeatModal);
    $('btnTrimToSelection')?.addEventListener('click', doTrimToSelection);
    $('btnSplitAtCursor')?.addEventListener('click', doSplitAtCursor);
    $('btnDuplicate')?.addEventListener('click', doDuplicate);
    // 편집 옵션 체크박스 변경 시 저장
    $('chkSnapToZero')?.addEventListener('change', saveEditOptions);
    $('chkRippleEdit')?.addEventListener('change', saveEditOptions);
    // 미구현 기능 클릭 시 알림
    document.querySelectorAll('.btn.not-impl').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const btnText = btn.textContent.trim();
        showCenterToast(`"${btnText}" 기능은 준비 중입니다`);
      });
    });
    console.log('✅ 새 사이드바 섹션 이벤트 리스너 등록 완료');
    // ==================== 내보내기 기능 ====================
    function initExportModals() {
      // WAV 내보내기 모달
      $('btnExportWAV').onclick = () => {
        if (isRecordingActive()) return;
        if (activeTrackIndex === -1) return showCenterToast('⚠️ 트랙을 선택해주세요');
        updateWavExportInfo();
        $('exportWavModal').classList.add('open');
      };
      $('btnCancelExportWav').onclick = () => $('exportWavModal').classList.remove('open');
      $('btnApplyExportWav').onclick = () => {
        $('exportWavModal').classList.remove('open');
        setTimeout(() => exportAsWav(), 100);
      };
      $('selectWavSampleRate').onchange = updateWavExportInfo;
      $('selectWavBitDepth').onchange = updateWavExportInfo;

      function updateWavExportInfo() {
        const track = tracks[activeTrackIndex];
        if (!track) return;
        const sr = $('selectWavSampleRate').value === 'original' ? track.buffer.sampleRate : parseInt($('selectWavSampleRate').value);
        const bits = parseInt($('selectWavBitDepth').value);
        const channels = track.buffer.numberOfChannels;
        const duration = track.duration;
        const fileSize = (sr * (bits / 8) * channels * duration) / (1024 * 1024);
        $('wavExportDetails').innerHTML = `
          • 길이: ${formatTime(duration)}<br>
          • 샘플레이트: ${sr} Hz<br>
          • 채널: ${channels === 1 ? '모노' : '스테레오'}<br>
          • 예상 크기: ~${fileSize.toFixed(1)} MB
          `;
      }

      function exportAsWav() {
        const track = tracks[activeTrackIndex];
        if (!track) return;
        const targetSampleRate = $('selectWavSampleRate').value === 'original' ?
          track.buffer.sampleRate :
          parseInt($('selectWavSampleRate').value);
        const bitDepth = parseInt($('selectWavBitDepth').value);
        let bufferToExport = track.buffer;
        // 리샘플링 필요시
        if (targetSampleRate !== track.buffer.sampleRate) {
          bufferToExport = resampleBuffer(track.buffer, targetSampleRate);
        }
        const wavData = audioBufferToWavWithBitDepth(bufferToExport, bitDepth);
        const blob = new Blob([wavData], {
          type: 'audio/wav'
        });
        const fileName = track.name.replace(/\.[^/.]+$/, '') + '_export.wav';
        downloadBlob(blob, fileName, 'audio/wav');
        showCenterToast(`✅ ${fileName} 저장됨`);
      }
      // 비트뎁스 지원 WAV 인코더
      function audioBufferToWavWithBitDepth(buffer, bitDepth = 16) {
        const numChannels = buffer.numberOfChannels;
        const sampleRate = buffer.sampleRate;
        const format = bitDepth === 32 ? 3 : 1; // 3 = float, 1 = PCM
        const bytesPerSample = bitDepth / 8;
        let interleaved;
        if (numChannels === 2) {
          const left = buffer.getChannelData(0);
          const right = buffer.getChannelData(1);
          interleaved = new Float32Array(left.length * 2);
          for (let i = 0; i < left.length; i++) {
            interleaved[i * 2] = left[i];
            interleaved[i * 2 + 1] = right[i];
          }
        } else {
          interleaved = buffer.getChannelData(0);
        }
        const dataLength = interleaved.length * bytesPerSample;
        const headerLength = 44;
        const totalLength = headerLength + dataLength;
        const arrayBuffer = new ArrayBuffer(totalLength);
        const view = new DataView(arrayBuffer);
        // WAV 헤더
        writeString(view, 0, 'RIFF');
        view.setUint32(4, totalLength - 8, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, format, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * bytesPerSample, true);
        view.setUint16(32, numChannels * bytesPerSample, true);
        view.setUint16(34, bitDepth, true);
        writeString(view, 36, 'data');
        view.setUint32(40, dataLength, true);
        // 오디오 데이터
        let offset = 44;
        for (let i = 0; i < interleaved.length; i++) {
          const sample = Math.max(-1, Math.min(1, interleaved[i]));
          if (bitDepth === 16) {
            view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          } else if (bitDepth === 24) {
            const val = sample < 0 ? sample * 0x800000 : sample * 0x7FFFFF;
            view.setUint8(offset, val & 0xFF);
            view.setUint8(offset + 1, (val >> 8) & 0xFF);
            view.setUint8(offset + 2, (val >> 16) & 0xFF);
          } else if (bitDepth === 32) {
            view.setFloat32(offset, sample, true);
          }
          offset += bytesPerSample;
        }
        return arrayBuffer;
      }

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }
      // 리샘플링 함수
      function resampleBuffer(buffer, targetSampleRate) {
        const ratio = buffer.sampleRate / targetSampleRate;
        const newLength = Math.round(buffer.length / ratio);
        const ctx = new(window.AudioContext || window.webkitAudioContext)({
          sampleRate: targetSampleRate
        });
        const newBuffer = ctx.createBuffer(buffer.numberOfChannels, newLength, targetSampleRate);
        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
          const oldData = buffer.getChannelData(ch);
          const newData = newBuffer.getChannelData(ch);
          for (let i = 0; i < newLength; i++) {
            const srcIndex = i * ratio;
            const idx = Math.floor(srcIndex);
            const frac = srcIndex - idx;
            const a = oldData[idx] || 0;
            const b = oldData[idx + 1] || 0;
            newData[i] = a + frac * (b - a);
          }
        }
        return newBuffer;
      }
      // MP3 내보내기 모달
      $('btnExportMP3').onclick = () => {
        if (isRecordingActive()) return;
        if (activeTrackIndex === -1) return showCenterToast('⚠️ 트랙을 선택해주세요');
        if (typeof lamejs === 'undefined') return showCenterToast('⚠️ MP3 인코더 로드 실패');
        updateMp3ExportInfo();
        $('exportMp3Modal').classList.add('open');
      };
      $('btnCancelExportMp3').onclick = () => $('exportMp3Modal').classList.remove('open');
      $('btnApplyExportMp3').onclick = () => {
        $('exportMp3Modal').classList.remove('open');
        setTimeout(() => exportAsMp3(), 100);
      };
      $('selectMp3Bitrate').onchange = updateMp3ExportInfo;

      function updateMp3ExportInfo() {
        const track = tracks[activeTrackIndex];
        if (!track) return;
        const bitrate = parseInt($('selectMp3Bitrate').value);
        const duration = track.duration;
        const fileSize = (bitrate * 1000 / 8 * duration) / (1024 * 1024);
        $('mp3ExportDetails').innerHTML = `
          • 길이: ${formatTime(duration)}<br>
          • 비트레이트: ${bitrate} kbps<br>
          • 예상 크기: ~${fileSize.toFixed(1)} MB
          `;
      }

      function exportAsMp3() {
        const track = tracks[activeTrackIndex];
        if (!track) return;
        showCenterToast('🔄 MP3 변환 중...');
        setTimeout(() => {
          try {
            const buffer = track.buffer;
            const bitrate = parseInt($('selectMp3Bitrate').value);
            const channels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
            const mp3Data = [];
            const left = buffer.getChannelData(0);
            const right = channels > 1 ? buffer.getChannelData(1) : left;
            const sampleBlockSize = 1152;
            const leftInt = new Int16Array(left.length);
            const rightInt = new Int16Array(right.length);
            for (let i = 0; i < left.length; i++) {
              leftInt[i] = Math.max(-32768, Math.min(32767, Math.round(left[i] * 32767)));
              rightInt[i] = Math.max(-32768, Math.min(32767, Math.round(right[i] * 32767)));
            }
            for (let i = 0; i < leftInt.length; i += sampleBlockSize) {
              const leftChunk = leftInt.subarray(i, i + sampleBlockSize);
              const rightChunk = rightInt.subarray(i, i + sampleBlockSize);
              const mp3buf = channels > 1 ?
                mp3encoder.encodeBuffer(leftChunk, rightChunk) :
                mp3encoder.encodeBuffer(leftChunk);
              if (mp3buf.length > 0) mp3Data.push(mp3buf);
            }
            const end = mp3encoder.flush();
            if (end.length > 0) mp3Data.push(end);
            const blob = new Blob(mp3Data, {
              type: 'audio/mp3'
            });
            const fileName = track.name.replace(/\.[^/.]+$/, '') + '_export.mp3';
            downloadBlob(blob, fileName, 'audio/mp3');
            showCenterToast(`✅ ${fileName} 저장됨`);
          } catch (e) {
            console.error('MP3 변환 오류:', e);
            showCenterToast('❌ MP3 변환 실패: ' + e.message);
          }
        }, 100);
      }
      // 선택 구간 내보내기
      if ($('btnExportSelection')) {
        $('btnExportSelection').onclick = () => {
          if (activeTrackIndex === -1) return showCenterToast('⚠️ 트랙을 선택해주세요');
          if (selStartTime === null || selEndTime === null) return showCenterToast('⚠️ 구간을 선택해주세요');
          const sT = Math.min(selStartTime, selEndTime);
          const eT = Math.max(selStartTime, selEndTime);
          const duration = eT - sT;
          $('selectionExportDetails').innerHTML = `
            • 시작: ${formatTime(sT)}<br>
            • 끝: ${formatTime(eT)}<br>
            • 길이: ${duration.toFixed(2)}초
            `;
          $('exportSelectionModal').classList.add('open');
        };
        $('btnCancelExportSelection').onclick = () => $('exportSelectionModal').classList.remove('open');
        $('btnApplyExportSelection').onclick = () => {
          $('exportSelectionModal').classList.remove('open');
          setTimeout(() => exportSelection(), 100);
        };
      }

      function exportSelection() {
        const track = tracks[activeTrackIndex];
        const format = $('selectSelectionFormat').value;
        const sT = Math.min(selStartTime, selEndTime);
        const eT = Math.max(selStartTime, selEndTime);
        const buffer = track.buffer;
        const sr = buffer.sampleRate;
        const startSample = Math.floor(sT * sr);
        const endSample = Math.floor(eT * sr);
        const length = endSample - startSample;
        const ctx = new(window.AudioContext || window.webkitAudioContext)();
        const newBuffer = ctx.createBuffer(buffer.numberOfChannels, length, sr);
        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
          const oldData = buffer.getChannelData(ch);
          const newData = newBuffer.getChannelData(ch);
          for (let i = 0; i < length; i++) {
            newData[i] = oldData[startSample + i];
          }
        }
        const baseName = track.name.replace(/\.[^/.]+$/, '') + '_selection';
        if (format === 'mp3') {
          exportBufferAsMp3(newBuffer, baseName + '.mp3');
        } else {
          const wavData = audioBufferToWavWithBitDepth(newBuffer, 16);
          downloadBlob(new Blob([wavData], {
            type: 'audio/wav'
          }), baseName + '.wav', 'audio/wav');
          showCenterToast(`✅ ${baseName}.wav 저장됨`);
        }
      }

      function exportBufferAsMp3(buffer, fileName) {
        try {
          const bitrate = 192;
          const channels = buffer.numberOfChannels;
          const mp3encoder = new lamejs.Mp3Encoder(channels, buffer.sampleRate, bitrate);
          const mp3Data = [];
          const left = buffer.getChannelData(0);
          const right = channels > 1 ? buffer.getChannelData(1) : left;
          const leftInt = new Int16Array(left.length);
          const rightInt = new Int16Array(right.length);
          for (let i = 0; i < left.length; i++) {
            leftInt[i] = Math.max(-32768, Math.min(32767, Math.round(left[i] * 32767)));
            rightInt[i] = Math.max(-32768, Math.min(32767, Math.round(right[i] * 32767)));
          }
          const sampleBlockSize = 1152;
          for (let i = 0; i < leftInt.length; i += sampleBlockSize) {
            const leftChunk = leftInt.subarray(i, i + sampleBlockSize);
            const rightChunk = rightInt.subarray(i, i + sampleBlockSize);
            const mp3buf = channels > 1 ? mp3encoder.encodeBuffer(leftChunk, rightChunk) : mp3encoder.encodeBuffer(leftChunk);
            if (mp3buf.length > 0) mp3Data.push(mp3buf);
          }
          const end = mp3encoder.flush();
          if (end.length > 0) mp3Data.push(end);
          downloadBlob(new Blob(mp3Data, {
            type: 'audio/mp3'
          }), fileName, 'audio/mp3');
          showCenterToast(`✅ ${fileName} 저장됨`);
        } catch (e) {
          showCenterToast('❌ MP3 변환 실패');
        }
      }
      // 무음 기준 분할 저장
      if ($('btnExportBySilence')) {
        $('btnExportBySilence').onclick = () => {
          if (activeTrackIndex === -1) return showCenterToast('⚠️ 트랙을 선택해주세요');
          $('exportSilenceModal').classList.add('open');
        };
        $('btnCancelExportSilence').onclick = () => $('exportSilenceModal').classList.remove('open');
        $('sliderSilenceThreshold').oninput = function() {
          $('labelSilenceThreshold').textContent = this.value + ' dB';
        };
        $('sliderSilenceMinDuration').oninput = function() {
          $('labelSilenceMinDuration').textContent = parseFloat(this.value).toFixed(1) + ' 초';
        };
        $('btnPreviewSilenceSplit').onclick = () => {
          const track = tracks[activeTrackIndex];
          if (!track) return;
          const threshold = parseFloat($('sliderSilenceThreshold').value);
          const minDuration = parseFloat($('sliderSilenceMinDuration').value);
          const splits = detectSilenceSplits(track.buffer, threshold, minDuration);
          showCenterToast(`🔍 ${splits.length}개 구간 감지됨`);
        };
        $('btnApplyExportSilence').onclick = () => {
          $('exportSilenceModal').classList.remove('open');
          setTimeout(() => exportBySilence(), 100);
        };
      }
      // 전사/자막 이벤트
      $('btnAddTranscript')?.addEventListener('click', addTranscriptToSelection);
      $('btnAddAllTranscripts')?.addEventListener('click', addAllTranscripts);
      $('btnToggleTranscriptPanel')?.addEventListener('click', () => {
        toggleTranscriptPanel();
      });
      $('btnClearAllTranscripts')?.addEventListener('click', clearAllTranscripts);
      $('btnExportSRT')?.addEventListener('click', exportSRT);
      $('btnExportVTT')?.addEventListener('click', exportVTT);
      $('btnExportTXT')?.addEventListener('click', exportTranscriptTXT);
    }

    function toggleTranscriptPanel() {
      const wrapper = $('transcriptPanelWrapper');
      const resizer2 = $('verticalResizer2');
      
      if (!wrapper) return;
      
      const isVisible = wrapper.style.display !== 'none';
      
      if (isVisible) {
        // 숨기기
        wrapper.style.display = 'none';
        if (resizer2) resizer2.style.display = 'none';
      } else {
        // 보이기
        wrapper.style.display = '';
        if (resizer2) resizer2.style.display = '';
        // 전사 패널 렌더링
        renderTranscriptPanel();
      }
    }
      // ========== 설정 섹션 이벤트 ==========
      // 파형 색상
      $('selectWaveColor')?.addEventListener('change', (e) => {
        waveColor = e.target.value;
        localStorage.setItem('waveColor', waveColor);
        drawWaveform();
      });
      // 선택 영역 색상
      $('selectSelectionColor')?.addEventListener('change', (e) => {
        selectionColor = e.target.value;
        localStorage.setItem('selectionColor', selectionColor);
        drawWaveform();
      });
      // 기본 재생 속도
      $('sliderDefaultSpeed')?.addEventListener('input', (e) => {
        defaultPlaybackSpeed = parseFloat(e.target.value);
        $('labelDefaultSpeed').textContent = defaultPlaybackSpeed.toFixed(1) + 'x';
        localStorage.setItem('defaultPlaybackSpeed', defaultPlaybackSpeed);
      });
      // 설정 초기화
      $('btnResetSettings')?.addEventListener('click', resetSettings);
      // 캐시 삭제
      $('btnClearCache')?.addEventListener('click', clearCache);
    // 이펙트 미리듣기 공통
    let effectPreviewCtx = null;
    let effectPreviewSource = null;

    function stopEffectPreview() {
      if (effectPreviewSource) {
        try {
          effectPreviewSource.stop();
        } catch (e) {}
        effectPreviewSource = null;
      }
      if (effectPreviewCtx) {
        effectPreviewCtx.close();
        effectPreviewCtx = null;
      }
    }
    // 필터 미리듣기
    function previewFilter(type, freq, q) {
      stopEffectPreview();
      const track = tracks[activeTrackIndex];
      if (!track) return;
      effectPreviewCtx = new(window.AudioContext || window.webkitAudioContext)();
      effectPreviewSource = effectPreviewCtx.createBufferSource();
      effectPreviewSource.buffer = track.buffer;
      const filter = effectPreviewCtx.createBiquadFilter();
      filter.type = type;
      filter.frequency.value = freq;
      filter.Q.value = q;
      effectPreviewSource.connect(filter);
      filter.connect(effectPreviewCtx.destination);
      const startTime = selStartTime !== null ? Math.min(selStartTime, selEndTime || 0) : 0;
      effectPreviewSource.start(0, startTime, 3);
      setTimeout(() => stopEffectPreview(), 3000);
    }
    // 로우패스 필터 적용
    function applyLowPass() {
      const freq = parseFloat($('sliderLowPassFreq').value);
      const q = parseFloat($('sliderLowPassQ').value);
      applyBiquadFilter('lowpass', freq, q, 0);
      showCenterToast(`✅ 로우패스 필터 적용됨 (${freq} Hz)`);
    }
    // 하이패스 필터 적용
    function applyHighPass() {
      const freq = parseFloat($('sliderHighPassFreq').value);
      const q = parseFloat($('sliderHighPassQ').value);
      applyBiquadFilter('highpass', freq, q, 0);
      showCenterToast(`✅ 하이패스 필터 적용됨 (${freq} Hz)`);
    }
    // Biquad 필터 적용 공통 함수
    function applyBiquadFilter(type, freq, q, gain) {
      const track = tracks[activeTrackIndex];
      if (!track) return;
      saveState(); // 작업 전에 저장
      const ctx = new OfflineAudioContext(
        track.buffer.numberOfChannels,
        track.buffer.length,
        track.buffer.sampleRate
      );
      const source = ctx.createBufferSource();
      source.buffer = track.buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = type;
      filter.frequency.value = freq;
      filter.Q.value = q;
      if (gain !== 0) filter.gain.value = gain;
      source.connect(filter);
      filter.connect(ctx.destination);
      source.start();
      ctx.startRendering().then(renderedBuffer => {
        track.buffer = renderedBuffer;
        track.duration = renderedBuffer.duration;
        track.isDirty = true;
        minimapNeedsRedraw = true;
        drawWaveform();
        renderPlaylist();
      });
    }
    // 험 제거 라벨 업데이트
    function updateHumLabel() {
      const baseFreq = parseInt($('selectHumFreq').value);
      const harmonics = parseInt($('sliderHumHarmonics').value);
      const freqList = [];
      for (let i = 1; i <= harmonics; i++) {
        freqList.push(baseFreq * i);
      }
      $('labelHumHarmonics').textContent = harmonics + '개 (' + freqList.join(', ') + ' Hz)';
    }
    // 험 제거 미리듣기
    function previewDeHum() {
      stopEffectPreview();
      const track = tracks[activeTrackIndex];
      if (!track) return;
      const baseFreq = parseInt($('selectHumFreq').value);
      const harmonics = parseInt($('sliderHumHarmonics').value);
      const q = parseFloat($('sliderHumQ').value);
      effectPreviewCtx = new(window.AudioContext || window.webkitAudioContext)();
      effectPreviewSource = effectPreviewCtx.createBufferSource();
      effectPreviewSource.buffer = track.buffer;
      let lastNode = effectPreviewSource;
      for (let i = 1; i <= harmonics; i++) {
        const notch = effectPreviewCtx.createBiquadFilter();
        notch.type = 'notch';
        notch.frequency.value = baseFreq * i;
        notch.Q.value = q;
        lastNode.connect(notch);
        lastNode = notch;
      }
      lastNode.connect(effectPreviewCtx.destination);
      const startTime = selStartTime !== null ? Math.min(selStartTime, selEndTime || 0) : 0;
      effectPreviewSource.start(0, startTime, 3);
      setTimeout(() => stopEffectPreview(), 3000);
    }
    // 험 제거 적용
    function applyDeHum() {
      const track = tracks[activeTrackIndex];
      if (!track) return;
      saveState(); // 작업 전에 저장
      const baseFreq = parseInt($('selectHumFreq').value);
      const harmonics = parseInt($('sliderHumHarmonics').value);
      const q = parseFloat($('sliderHumQ').value);
      const ctx = new OfflineAudioContext(
        track.buffer.numberOfChannels,
        track.buffer.length,
        track.buffer.sampleRate
      );
      const source = ctx.createBufferSource();
      source.buffer = track.buffer;
      let lastNode = source;
      for (let i = 1; i <= harmonics; i++) {
        const notch = ctx.createBiquadFilter();
        notch.type = 'notch';
        notch.frequency.value = baseFreq * i;
        notch.Q.value = q;
        lastNode.connect(notch);
        lastNode = notch;
      }
      lastNode.connect(ctx.destination);
      source.start();
      ctx.startRendering().then(renderedBuffer => {
        track.buffer = renderedBuffer;
        track.duration = renderedBuffer.duration;
        track.isDirty = true;
        minimapNeedsRedraw = true;
        drawWaveform();
        renderPlaylist();
        showCenterToast(`✅ ${baseFreq}Hz 험 제거 적용됨 (${harmonics}개 하모닉스)`);
      });
    }
    // 그래픽 EQ 초기화
    function resetEQSliders() {
      document.querySelectorAll('.eqSlider').forEach(slider => {
        slider.value = 0;
        slider.parentElement.querySelector('.eqValue').textContent = '0dB';
      });
      $('selectEQPreset').value = '';
    }
    // EQ 프리셋 적용
    function applyEQPreset() {
      const preset = $('selectEQPreset').value;
      const presets = {
        vocal: [0, -2, 0, 2, 4, 3, 2, 0],
        bass: [6, 4, 2, 0, -1, -2, -1, 0],
        treble: [-2, -1, 0, 0, 1, 3, 5, 6],
        reduce_mud: [0, 0, -4, -2, 0, 0, 0, 0],
        telephone: [-8, -4, 0, 4, 4, 0, -6, -10]
      };
      if (!presets[preset]) return;
      const ids = ['eq60', 'eq170', 'eq310', 'eq600', 'eq1k', 'eq3k', 'eq6k', 'eq12k'];
      presets[preset].forEach((val, i) => {
        const slider = $(ids[i]);
        slider.value = val;
        slider.parentElement.querySelector('.eqValue').textContent = val + 'dB';
      });
    }
    // 그래픽 EQ 미리듣기
    function previewGraphicEQ() {
      stopEffectPreview();
      const track = tracks[activeTrackIndex];
      if (!track) return;
      const freqs = [60, 170, 310, 600, 1000, 3000, 6000, 12000];
      const ids = ['eq60', 'eq170', 'eq310', 'eq600', 'eq1k', 'eq3k', 'eq6k', 'eq12k'];
      effectPreviewCtx = new(window.AudioContext || window.webkitAudioContext)();
      effectPreviewSource = effectPreviewCtx.createBufferSource();
      effectPreviewSource.buffer = track.buffer;
      let lastNode = effectPreviewSource;
      freqs.forEach((freq, i) => {
        const gain = parseFloat($(ids[i]).value);
        if (gain !== 0) {
          const filter = effectPreviewCtx.createBiquadFilter();
          filter.type = 'peaking';
          filter.frequency.value = freq;
          filter.Q.value = 1.4;
          filter.gain.value = gain;
          lastNode.connect(filter);
          lastNode = filter;
        }
      });
      lastNode.connect(effectPreviewCtx.destination);
      const startTime = selStartTime !== null ? Math.min(selStartTime, selEndTime || 0) : 0;
      effectPreviewSource.start(0, startTime, 3);
      setTimeout(() => stopEffectPreview(), 3000);
    }
    // 그래픽 EQ 적용
    function applyGraphicEQ() {
      const track = tracks[activeTrackIndex];
      if (!track) return;
      saveState(); // 작업 전에 저장
      const freqs = [60, 170, 310, 600, 1000, 3000, 6000, 12000];
      const ids = ['eq60', 'eq170', 'eq310', 'eq600', 'eq1k', 'eq3k', 'eq6k', 'eq12k'];
      const gains = ids.map(id => parseFloat($(id).value));
      if (gains.every(g => g === 0)) {
        return showCenterToast('⚠️ EQ 변경 사항이 없습니다');
      }
      const ctx = new OfflineAudioContext(
        track.buffer.numberOfChannels,
        track.buffer.length,
        track.buffer.sampleRate
      );
      const source = ctx.createBufferSource();
      source.buffer = track.buffer;
      let lastNode = source;
      freqs.forEach((freq, i) => {
        if (gains[i] !== 0) {
          const filter = ctx.createBiquadFilter();
          filter.type = 'peaking';
          filter.frequency.value = freq;
          filter.Q.value = 1.4;
          filter.gain.value = gains[i];
          lastNode.connect(filter);
          lastNode = filter;
        }
      });
      lastNode.connect(ctx.destination);
      source.start();
      ctx.startRendering().then(renderedBuffer => {
        track.buffer = renderedBuffer;
        track.duration = renderedBuffer.duration;
        track.isDirty = true;
        minimapNeedsRedraw = true;
        drawWaveform();
        renderPlaylist();
        showCenterToast('✅ 그래픽 EQ 적용됨');
      });
    }
    // 파라메트릭 EQ 미리듣기
    function previewParametricEQ() {
      const freq = parseFloat($('sliderParaFreq').value);
      const gain = parseFloat($('sliderParaGain').value);
      const q = parseFloat($('sliderParaQ').value);
      stopEffectPreview();
      const track = tracks[activeTrackIndex];
      if (!track) return;
      effectPreviewCtx = new(window.AudioContext || window.webkitAudioContext)();
      effectPreviewSource = effectPreviewCtx.createBufferSource();
      effectPreviewSource.buffer = track.buffer;
      const filter = effectPreviewCtx.createBiquadFilter();
      filter.type = 'peaking';
      filter.frequency.value = freq;
      filter.Q.value = q;
      filter.gain.value = gain;
      effectPreviewSource.connect(filter);
      filter.connect(effectPreviewCtx.destination);
      const startTime = selStartTime !== null ? Math.min(selStartTime, selEndTime || 0) : 0;
      effectPreviewSource.start(0, startTime, 3);
      setTimeout(() => stopEffectPreview(), 3000);
    }
    // 파라메트릭 EQ 적용
    function applyParametricEQ() {
      const freq = parseFloat($('sliderParaFreq').value);
      const gain = parseFloat($('sliderParaGain').value);
      const q = parseFloat($('sliderParaQ').value);
      if (gain === 0) return showCenterToast('⚠️ 게인이 0입니다');
      applyBiquadFilter('peaking', freq, q, gain);
      const freqStr = freq >= 1000 ? (freq / 1000).toFixed(1) + 'kHz' : freq + 'Hz';
      showCenterToast(`✅ 파라메트릭 EQ 적용됨 (${freqStr}, ${gain > 0 ? '+' : ''}${gain}dB)`);
    }
    // 딜레이 미리듣기
    function previewDelay() {
      stopEffectPreview();
      const track = tracks[activeTrackIndex];
      if (!track) return;
      const delayTime = parseFloat($('sliderDelayTime').value) / 1000;
      const feedback = parseFloat($('sliderDelayFeedback').value) / 100;
      const mix = parseFloat($('sliderDelayMix').value) / 100;
      effectPreviewCtx = new(window.AudioContext || window.webkitAudioContext)();
      effectPreviewSource = effectPreviewCtx.createBufferSource();
      effectPreviewSource.buffer = track.buffer;
      const dryGain = effectPreviewCtx.createGain();
      dryGain.gain.value = 1 - mix * 0.5;
      const wetGain = effectPreviewCtx.createGain();
      wetGain.gain.value = mix;
      const delay = effectPreviewCtx.createDelay(2);
      delay.delayTime.value = delayTime;
      const feedbackGain = effectPreviewCtx.createGain();
      feedbackGain.gain.value = feedback;
      effectPreviewSource.connect(dryGain);
      dryGain.connect(effectPreviewCtx.destination);
      effectPreviewSource.connect(delay);
      delay.connect(wetGain);
      wetGain.connect(effectPreviewCtx.destination);
      delay.connect(feedbackGain);
      feedbackGain.connect(delay);
      const startTime = selStartTime !== null ? Math.min(selStartTime, selEndTime || 0) : 0;
      effectPreviewSource.start(0, startTime, 3);
      setTimeout(() => stopEffectPreview(), 4000);
    }
    // 딜레이 적용
    function applyDelay() {
      const track = tracks[activeTrackIndex];
      if (!track) return;
      saveState(); // 작업 전에 저장
      const delayTime = parseFloat($('sliderDelayTime').value) / 1000;
      const feedback = parseFloat($('sliderDelayFeedback').value) / 100;
      const mix = parseFloat($('sliderDelayMix').value) / 100;
      showCenterToast('🔄 딜레이 적용 중...');
      const buffer = track.buffer;
      const sr = buffer.sampleRate;
      const channels = buffer.numberOfChannels;
      const delaySamples = Math.floor(delayTime * sr);
      // 딜레이로 인한 추가 길이 계산 (피드백 고려)
      const maxRepeats = feedback > 0 ? Math.ceil(Math.log(0.01) / Math.log(feedback)) : 1;
      const extraLength = delaySamples * Math.min(maxRepeats, 10);
      const newLength = buffer.length + extraLength;
      const ctx = new(window.AudioContext || window.webkitAudioContext)();
      const newBuffer = ctx.createBuffer(channels, newLength, sr);
      for (let ch = 0; ch < channels; ch++) {
        const input = buffer.getChannelData(ch);
        const output = newBuffer.getChannelData(ch);
        // 원본 복사 (dry)
        for (let i = 0; i < input.length; i++) {
          output[i] = input[i] * (1 - mix * 0.5);
        }
        // 딜레이 추가 (wet)
        let currentFeedback = mix;
        let currentDelay = delaySamples;
        while (currentFeedback > 0.01 && currentDelay < newLength) {
          for (let i = 0; i < input.length; i++) {
            const outIdx = i + currentDelay;
            if (outIdx < newLength) {
              output[outIdx] += input[i] * currentFeedback;
            }
          }
          currentFeedback *= feedback;
          currentDelay += delaySamples;
        }
      }
      // 리플 편집: 길이 증가에 따른 조정 (끝부분에 추가되므로 이동 불필요)
      // 딜레이는 끝에 추가되므로 세그먼트/마커 이동 필요 없음
      track.buffer = newBuffer;
      track.duration = newBuffer.duration;
      track.isDirty = true;
      minimapNeedsRedraw = true;
      drawWaveform();
      renderPlaylist();
      showCenterToast(`✅ 딜레이 적용됨 (${$('sliderDelayTime').value}ms)`);
    }
    // 노이즈 게이트 미리듣기
    function previewNoiseGate() {
      showCenterToast('🔍 노이즈 게이트는 미리듣기가 지원되지 않습니다. 바로 적용해주세요.');
    }
    // 노이즈 게이트 적용
    function applyNoiseGate() {
      const track = tracks[activeTrackIndex];
      if (!track) return;
      saveState(); // 작업 전에 저장
      const thresholdDb = parseFloat($('sliderGateThreshold').value);
      const attackMs = parseFloat($('sliderGateAttack').value);
      const releaseMs = parseFloat($('sliderGateRelease').value);
      const reductionDb = parseFloat($('sliderGateReduction').value);
      const threshold = Math.pow(10, thresholdDb / 20);
      const reduction = Math.pow(10, reductionDb / 20);
      showCenterToast('🔄 노이즈 게이트 적용 중...');
      const buffer = track.buffer;
      const sr = buffer.sampleRate;
      const channels = buffer.numberOfChannels;
      const attackSamples = Math.floor(attackMs * sr / 1000);
      const releaseSamples = Math.floor(releaseMs * sr / 1000);
      const ctx = new(window.AudioContext || window.webkitAudioContext)();
      const newBuffer = ctx.createBuffer(channels, buffer.length, sr);
      // RMS 계산용 윈도우 크기
      const windowSize = 1024;
      for (let ch = 0; ch < channels; ch++) {
        const input = buffer.getChannelData(ch);
        const output = newBuffer.getChannelData(ch);
        let gateOpen = false;
        let envelope = reduction;
        for (let i = 0; i < input.length; i++) {
          // RMS 계산
          let rms = 0;
          const start = Math.max(0, i - windowSize / 2);
          const end = Math.min(input.length, i + windowSize / 2);
          for (let j = start; j < end; j++) {
            rms += input[j] * input[j];
          }
          rms = Math.sqrt(rms / (end - start));
          // 게이트 상태 결정
          if (rms > threshold) {
            gateOpen = true;
          } else if (rms < threshold * 0.8) {
            gateOpen = false;
          }
          // 엔벨로프 적용
          const targetEnvelope = gateOpen ? 1 : reduction;
          const rate = gateOpen ? (1 / attackSamples) : (1 / releaseSamples);
          envelope += (targetEnvelope - envelope) * rate;
          output[i] = input[i] * envelope;
        }
      }
      track.buffer = newBuffer;
      track.duration = newBuffer.duration;
      track.isDirty = true;
      minimapNeedsRedraw = true;
      drawWaveform();
      renderPlaylist();
      showCenterToast(`✅ 노이즈 게이트 적용됨 (임계값: ${thresholdDb}dB)`);
    }

    function detectSilenceSplits(buffer, thresholdDb, minDuration) {
      const threshold = Math.pow(10, thresholdDb / 20);
      const data = buffer.getChannelData(0);
      const sr = buffer.sampleRate;
      const minSamples = Math.floor(minDuration * sr);
      const splits = [];
      let regionStart = 0;
      let silenceStart = -1;
      const blockSize = 1024;
      for (let i = 0; i < data.length; i += blockSize) {
        let maxAmp = 0;
        for (let j = i; j < Math.min(i + blockSize, data.length); j++) {
          maxAmp = Math.max(maxAmp, Math.abs(data[j]));
        }
        const isSilent = maxAmp < threshold;
        const currentTime = i / sr;
        if (isSilent && silenceStart === -1) {
          silenceStart = i;
        } else if (!isSilent && silenceStart !== -1) {
          const silenceLength = i - silenceStart;
          if (silenceLength >= minSamples) {
            const splitPoint = silenceStart + silenceLength / 2;
            if (regionStart < splitPoint / sr) {
              splits.push({
                start: regionStart,
                end: splitPoint / sr
              });
              regionStart = splitPoint / sr;
            }
          }
          silenceStart = -1;
        }
      }
      // 마지막 구간
      if (regionStart < buffer.duration) {
        splits.push({
          start: regionStart,
          end: buffer.duration
        });
      }
      return splits;
    }
    async function exportBySilence() {
      const track = tracks[activeTrackIndex];
      const format = $('selectSilenceFormat').value;
      const threshold = parseFloat($('sliderSilenceThreshold').value);
      const minDuration = parseFloat($('sliderSilenceMinDuration').value);
      const ext = format === 'mp3' ? 'mp3' : 'wav';
      showCenterToast('🔄 무음 감지 및 분할 중...');
      const splits = detectSilenceSplits(track.buffer, threshold, minDuration);
      if (splits.length <= 1) {
        return showCenterToast('⚠️ 분할 가능한 무음 구간이 없습니다');
      }
      const zip = new JSZip();
      const baseName = track.name.replace(/\.[^/.]+$/, '');
      for (let i = 0; i < splits.length; i++) {
        const {
          start,
          end
        } = splits[i];
        const segBuffer = extractBufferRange(track.buffer, start, end);
        const fileName = `${baseName}_${String(i + 1).padStart(3, '0')}.${ext}`;
        let data;
        if (format === 'mp3') {
          data = encodeBufferToMp3Blob(segBuffer);
        } else {
          data = new Blob([audioBufferToWavWithBitDepth(segBuffer, 16)], {
            type: 'audio/wav'
          });
        }
        zip.file(fileName, data);
      }
      const content = await zip.generateAsync({
        type: 'blob'
      });
      downloadBlob(content, `${baseName}_by_silence.zip`, 'application/zip');
      showCenterToast(`✅ ${splits.length}개 파일 저장됨`);
    }
    // 주파수 → 음이름 변환
    function frequencyToNote(freq) {
      const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const A4 = 440;
      if (freq < 20 || freq > 20000) return '';
      const semitones = Math.round(12 * Math.log2(freq / A4));
      const noteIndex = ((semitones % 12) + 12 + 9) % 12; // A=9
      const octave = Math.floor((semitones + 9) / 12) + 4;
      return notes[noteIndex] + octave;
    }
    // 톤 미리듣기
    let tonePreviewOsc = null;
    let tonePreviewGain = null;

    function previewTone() {
      stopTonePreview();
      const ctx = new(window.AudioContext || window.webkitAudioContext)();
      const freq = parseFloat($('sliderToneFreq').value);
      const waveform = $('selectToneWaveform').value;
      const volume = parseFloat($('sliderToneVolume').value) / 100;
      tonePreviewOsc = ctx.createOscillator();
      tonePreviewGain = ctx.createGain();
      tonePreviewOsc.type = waveform;
      tonePreviewOsc.frequency.value = freq;
      tonePreviewGain.gain.value = volume * 0.5;
      tonePreviewOsc.connect(tonePreviewGain);
      tonePreviewGain.connect(ctx.destination);
      tonePreviewOsc.start();
      // 2초 후 자동 정지
      setTimeout(() => stopTonePreview(), 2000);
    }

    function stopTonePreview() {
      if (tonePreviewOsc) {
        try {
          tonePreviewOsc.stop();
        } catch (e) {}
        tonePreviewOsc = null;
      }
    }
    // 톤 생성 적용
    function applyGenerateTone() {
      const freq = parseFloat($('sliderToneFreq').value);
      const waveform = $('selectToneWaveform').value;
      const duration = parseFloat($('sliderToneDuration').value);
      const volume = parseFloat($('sliderToneVolume').value) / 100;
      const insertMode = $('selectToneInsert').value;
      const sampleRate = 44100;
      const length = Math.floor(sampleRate * duration);
      const audioCtx = new(window.AudioContext || window.webkitAudioContext)();
      const buffer = audioCtx.createBuffer(1, length, sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < length; i++) {
        const t = i / sampleRate;
        let sample = 0;
        switch (waveform) {
          case 'sine':
            sample = Math.sin(2 * Math.PI * freq * t);
            break;
          case 'square':
            sample = Math.sin(2 * Math.PI * freq * t) > 0 ? 1 : -1;
            break;
          case 'triangle':
            sample = 2 * Math.abs(2 * (t * freq - Math.floor(t * freq + 0.5))) - 1;
            break;
          case 'sawtooth':
            sample = 2 * (t * freq - Math.floor(t * freq + 0.5));
            break;
        }
        // 페이드 인/아웃 (클릭 방지)
        const fadeLen = Math.min(0.01 * sampleRate, length / 4);
        if (i < fadeLen) sample *= i / fadeLen;
        if (i > length - fadeLen) sample *= (length - i) / fadeLen;
        data[i] = sample * volume;
      }
      insertGeneratedAudio(buffer, insertMode, `tone_${freq}Hz_${waveform}`);
    }
    // 노이즈 미리듣기
    let noisePreviewSource = null;
    let noisePreviewCtx = null;

    function previewNoise() {
      stopNoisePreview();
      const type = $('selectNoiseType').value;
      const volume = parseFloat($('sliderNoiseVolume').value) / 100;
      noisePreviewCtx = new(window.AudioContext || window.webkitAudioContext)();
      const bufferSize = noisePreviewCtx.sampleRate * 2;
      const buffer = noisePreviewCtx.createBuffer(1, bufferSize, noisePreviewCtx.sampleRate);
      const data = buffer.getChannelData(0);
      generateNoiseData(data, type);
      noisePreviewSource = noisePreviewCtx.createBufferSource();
      const gainNode = noisePreviewCtx.createGain();
      gainNode.gain.value = volume * 0.5;
      noisePreviewSource.buffer = buffer;
      noisePreviewSource.loop = true;
      noisePreviewSource.connect(gainNode);
      gainNode.connect(noisePreviewCtx.destination);
      noisePreviewSource.start();
      setTimeout(() => stopNoisePreview(), 2000);
    }

    function stopNoisePreview() {
      if (noisePreviewSource) {
        try {
          noisePreviewSource.stop();
        } catch (e) {}
        noisePreviewSource = null;
      }
      if (noisePreviewCtx) {
        noisePreviewCtx.close();
        noisePreviewCtx = null;
      }
    }
    // 노이즈 데이터 생성
    function generateNoiseData(data, type) {
      let b0 = 0,
        b1 = 0,
        b2 = 0,
        b3 = 0,
        b4 = 0,
        b5 = 0,
        b6 = 0;
      for (let i = 0; i < data.length; i++) {
        const white = Math.random() * 2 - 1;
        switch (type) {
          case 'white':
            data[i] = white;
            break;
          case 'pink':
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
            b6 = white * 0.115926;
            break;
          case 'brown':
            data[i] = (b0 = (b0 + (0.02 * white)) / 1.02) * 3.5;
            break;
        }
      }
    }
    // 노이즈 생성 적용
    function applyGenerateNoise() {
      const type = $('selectNoiseType').value;
      const duration = parseFloat($('sliderNoiseDuration').value);
      const volume = parseFloat($('sliderNoiseVolume').value) / 100;
      const insertMode = $('selectNoiseInsert').value;
      const sampleRate = 44100;
      const length = Math.floor(sampleRate * duration);
      const audioCtx = new(window.AudioContext || window.webkitAudioContext)();
      const buffer = audioCtx.createBuffer(1, length, sampleRate);
      const data = buffer.getChannelData(0);
      generateNoiseData(data, type);
      // 볼륨 적용 및 페이드
      const fadeLen = Math.min(0.01 * sampleRate, length / 4);
      for (let i = 0; i < length; i++) {
        if (i < fadeLen) data[i] *= (i / fadeLen) * volume;
        else if (i > length - fadeLen) data[i] *= ((length - i) / fadeLen) * volume;
        else data[i] *= volume;
      }
      insertGeneratedAudio(buffer, insertMode, `${type}_noise`);
    }
    // 무음 생성 적용
    function applyGenerateSilence() {
      const duration = parseFloat($('sliderSilenceDuration').value);
      const insertMode = $('selectSilenceInsert').value;
      const sampleRate = 44100;
      const length = Math.floor(sampleRate * duration);
      const audioCtx = new(window.AudioContext || window.webkitAudioContext)();
      const buffer = audioCtx.createBuffer(1, length, sampleRate);
      // 데이터는 기본값 0 (무음)
      insertGeneratedAudio(buffer, insertMode, 'silence');
    }
    // 생성된 오디오 삽입
    function insertGeneratedAudio(buffer, mode, name) {
      saveState(); // 작업 전에 저장
      const now = new Date();
      const timestamp = now.toTimeString().slice(0, 8).replace(/:/g, '-');
      const fileName = `generated_${name}_${timestamp}.wav`;
      const currentTrack = (activeTrackIndex >= 0) ? tracks[activeTrackIndex] : null;
      if (mode === 'new' || !currentTrack) {
        // 새 트랙으로 추가
        const trackData = {
          id: 'gen_' + Date.now(),
          name: fileName,
          buffer: buffer,
          duration: buffer.duration,
          segments: [] // ✅ 추가: 세그먼트 배열 초기화
        };
        tracks.push(trackData);
        renderPlaylist();
        selectTrack(tracks.length - 1);
        minimapNeedsRedraw = true;
        setTimeout(() => {
          drawWaveform();
        }, 50);
        showCenterToast(`✅ "${fileName}" 생성됨`);
      } else {
        // 현재 트랙에 삽입/대체
        const current = currentTrack.buffer;
        const sampleRate = current.sampleRate;
        const channels = current.numberOfChannels;
        let newBuffer;
        const audioCtx = new(window.AudioContext || window.webkitAudioContext)();
        if (mode === 'replace' && selStartTime !== null && selEndTime !== null) {
          const sT = Math.min(selStartTime, selEndTime);
          const eT = Math.max(selStartTime, selEndTime);
          const startSample = Math.floor(sT * sampleRate);
          const endSample = Math.floor(eT * sampleRate);
          const newLength = current.length - (endSample - startSample) + buffer.length;
          newBuffer = audioCtx.createBuffer(channels, newLength, sampleRate);
          for (let ch = 0; ch < channels; ch++) {
            const oldData = current.getChannelData(ch);
            const newData = newBuffer.getChannelData(ch);
            const genData = buffer.getChannelData(0);
            for (let i = 0; i < startSample; i++) newData[i] = oldData[i];
            for (let i = 0; i < buffer.length; i++) newData[startSample + i] = genData[i];
            for (let i = endSample; i < current.length; i++) {
              newData[startSample + buffer.length + (i - endSample)] = oldData[i];
            }
          }
          // 리플 편집: 세그먼트/마커 조정
          if ($('chkRippleEdit')?.checked) {
            const diff = buffer.duration - (eT - sT);
            currentTrack.segments.forEach(seg => {
              if (seg.start >= eT) {
                seg.start += diff;
                seg.end += diff;
              } else if (seg.end > sT && seg.start < sT) {
                seg.end = sT;
              }
            });
            if (currentTrack.markers) {
              currentTrack.markers.forEach(marker => {
                if (marker.time >= eT) {
                  marker.time += diff;
                }
              });
            }
          }
          selStartTime = null;
          selEndTime = null;
        } else if (mode === 'start') {
          newBuffer = audioCtx.createBuffer(channels, current.length + buffer.length, sampleRate);
          for (let ch = 0; ch < channels; ch++) {
            const oldData = current.getChannelData(ch);
            const newData = newBuffer.getChannelData(ch);
            const genData = buffer.getChannelData(0);
            for (let i = 0; i < buffer.length; i++) newData[i] = genData[i];
            for (let i = 0; i < current.length; i++) newData[buffer.length + i] = oldData[i];
          }
          // 리플 편집: 모든 세그먼트/마커 이동
          if ($('chkRippleEdit')?.checked) {
            const insertDuration = buffer.duration;
            currentTrack.segments.forEach(seg => {
              seg.start += insertDuration;
              seg.end += insertDuration;
            });
            if (currentTrack.markers) {
              currentTrack.markers.forEach(marker => {
                marker.time += insertDuration;
              });
            }
          }
        } else if (mode === 'end') {
          newBuffer = audioCtx.createBuffer(channels, current.length + buffer.length, sampleRate);
          for (let ch = 0; ch < channels; ch++) {
            const oldData = current.getChannelData(ch);
            const newData = newBuffer.getChannelData(ch);
            const genData = buffer.getChannelData(0);
            for (let i = 0; i < current.length; i++) newData[i] = oldData[i];
            for (let i = 0; i < buffer.length; i++) newData[current.length + i] = genData[i];
          }
        } else {
          const cursorSample = Math.floor((anchorTime || 0) * sampleRate);
          newBuffer = audioCtx.createBuffer(channels, current.length + buffer.length, sampleRate);
          for (let ch = 0; ch < channels; ch++) {
            const oldData = current.getChannelData(ch);
            const newData = newBuffer.getChannelData(ch);
            const genData = buffer.getChannelData(0);
            for (let i = 0; i < cursorSample; i++) newData[i] = oldData[i];
            for (let i = 0; i < buffer.length; i++) newData[cursorSample + i] = genData[i];
            for (let i = cursorSample; i < current.length; i++) {
              newData[buffer.length + i] = oldData[i];
            }
          }
          // 리플 편집: 커서 위치 이후 세그먼트/마커 이동
          if ($('chkRippleEdit')?.checked) {
            const cursorTime = anchorTime || 0;
            const insertDuration = buffer.duration;
            currentTrack.segments.forEach(seg => {
              if (seg.start >= cursorTime) {
                seg.start += insertDuration;
                seg.end += insertDuration;
              } else if (seg.end > cursorTime) {
                seg.end += insertDuration;
              }
            });
            if (currentTrack.markers) {
              currentTrack.markers.forEach(marker => {
                if (marker.time >= cursorTime) {
                  marker.time += insertDuration;
                }
              });
            }
          }
        }
        currentTrack.buffer = newBuffer;
        currentTrack.duration = newBuffer.duration;
        renderPlaylist();
        updateInfoChip();
        minimapNeedsRedraw = true;
        setTimeout(() => {
          drawWaveform();
          renderSegmentList();
          renderMarkerList();
        }, 50);
        showCenterToast(`✅ ${name} 삽입됨`);
      }
    }
    // ========== 녹음 섹션 함수들 ==========
    // 녹음 UI 초기화
    async function initRecordingSection() {
      console.log('🎙️ 녹음 섹션 초기화 시작');
      // 입력 장치 목록 가져오기 (자동 권한 요청 안 함)
      await populateAudioInputDevices(true);
      // 🎤 마이크 연결 버튼
      // 기존 btnMicConnect 이벤트 리스너를 찾아 아래로 교체하세요.
      $('btnMicConnect').addEventListener('click', async () => {
        try {
          showCenterToast('🎤 마이크 목록 갱신 중...');
          // false를 전달하여 강제로 스트림을 열고 라벨을 확보하게 합니다.
          await populateAudioInputDevices(false); 
          showCenterToast('✅ 마이크 연결 완료!');
        } catch (err) {
          console.error('마이크 연결 실패:', err);
          showCenterToast('⚠️ 마이크 연결 중 오류가 발생했습니다.');
        }
      });
      // 입력 장치 선택 이벤트
      const selectInput = $('selectAudioInput');
      if (selectInput) {
        selectInput.addEventListener('change', async (e) => {
          selectedInputDeviceId = e.target.value;
          if (selectedInputDeviceId) {
            await setupInputMonitoring();
          } else {
            stopInputMonitoring();
          }
        });
      }
      // 입력 모니터링 체크박스
      const chkMonitor = $('chkInputMonitor');
      if (chkMonitor) {
        chkMonitor.addEventListener('change', (e) => {
          const volWrap = $('monitorVolumeWrap');
          if (volWrap) volWrap.style.display = e.target.checked ? 'block' : 'none';
          if (inputMonitorGain) {
            const vol = e.target.checked ? parseInt($('monitorVolume')?.value || 100) / 100 : 0;
            inputMonitorGain.gain.value = vol;
          }
        });
      }
      const monitorVol = $('monitorVolume');
      if (monitorVol) {
        monitorVol.addEventListener('input', (e) => {
          const val = parseInt(e.target.value);
          $('monitorVolumeValue').textContent = val + '%';
          if (inputMonitorGain && $('chkInputMonitor')?.checked) {
            inputMonitorGain.gain.value = val / 100;
          }
        });
      }
      // 녹음 시작 버튼
      const btnStart = $('btnStartRecord');
      if (btnStart) {
        btnStart.addEventListener('click', startRecording);
      }
      // 녹음 정지 버튼
      const btnStop = $('btnStopRecord');
      if (btnStop) {
        btnStop.addEventListener('click', stopRecording);
      }
      // 녹음 일시정지 버튼
      const btnPause = $('btnPauseRecord');
      if (btnPause) {
        btnPause.addEventListener('click', togglePauseRecording);
      }
      // 하단 녹음 컨트롤 바 이벤트
      $('bottomBtnStart')?.addEventListener('click', startRecording);
      $('bottomBtnStop')?.addEventListener('click', stopRecording);
      $('bottomBtnPause')?.addEventListener('click', togglePauseRecording);
      // 녹음 설정 이벤트
      // 적정 볼륨 설정
      $('chkTargetDb')?.addEventListener('change', (e) => {
        showTargetDb = e.target.checked;
        minimapNeedsRedraw = true;
        drawWaveform();
      });
      $('sliderTargetDb')?.addEventListener('input', (e) => {
        targetDbLevel = parseInt(e.target.value);
        $('labelTargetDb').textContent = targetDbLevel + ' dB';
        updateWaveTargetLine();
        minimapNeedsRedraw = true;
        drawWaveform();
      });
      $('selectSampleRate')?.addEventListener('change', (e) => {
        recordSampleRate = parseInt(e.target.value);
        updateRecSettingSummary();
      });
      $('selectBitDepth')?.addEventListener('change', (e) => {
        recordBitDepth = parseInt(e.target.value);
        updateRecSettingSummary();
      });
      $('selectChannels')?.addEventListener('change', (e) => {
        recordChannels = parseInt(e.target.value);
        updateRecSettingSummary();
      });
      // 녹음 모드 카드 스타일 동기화
      window.updateRecordModeCards = function updateRecordModeCards() {
        document.querySelectorAll('.record-mode-card').forEach(card => {
          const radio = card.querySelector('input[type="radio"]');
          if (radio && radio.checked) {
            card.style.border = '1px solid #4a90d9';
            card.style.background = '#f0f7ff';
            card.style.color = '#1a56db';
          } else {
            card.style.border = '1px solid #555';
            card.style.background = '';
            card.style.color = '#888';
          }
        });
      }
      document.querySelectorAll('input[name="recordMode"]').forEach(radio => {
        radio.addEventListener('change', () => {
          updateRecordModeCards();
          // "새 트랙으로 녹음" 선택 시: 타이머 숨김 + 트랙 선택 해제
          if ($('chkRecordNewTrack')?.checked) {
            $('recordingTime').innerHTML = ''; 
            $('recordingStatus').textContent = '';
            $('bottomRecTimer').style.display = 'none';
            // 파일 관리 목록 선택 해제
            tracks.forEach(t => t.selected = false);
            activeTrackIndex = -1;
            multiSelectAnchor = -1;
            renderPlaylist();
            resetEditorState();
          }
        });
      });
      // '현재 음원에 선택된 위치에서 녹음' 선택 시 트랙이 없으면 경고
      const chkAppend = $('chkRecordAppend');
      if (chkAppend) {
        chkAppend.addEventListener('change', () => {
          if (chkAppend.checked && (activeTrackIndex < 0 || !tracks[activeTrackIndex]?.buffer)) {
            showCenterToast('⚠️ 음원을 먼저 선택하세요');
            $('chkRecordNewTrack').checked = true;
            updateRecordModeCards();
          }
        });
      }
      // '현재 음원에 이어서 녹음' 선택 시 트랙이 없으면 경고
      const chkContinue = $('chkRecordContinue');
      if (chkContinue) {
        chkContinue.addEventListener('change', () => {
          if (chkContinue.checked && (activeTrackIndex < 0 || !tracks[activeTrackIndex]?.buffer)) {
            showCenterToast('⚠️ 이어서 녹음할 음원을 먼저 선택하세요');
            $('chkRecordNewTrack').checked = true;
            updateRecordModeCards();
          }
        });
      }
      // 녹음 일시정지 중 미니맵 드래그로 위치 이동
      const miniCanvas = $('minimapCanvas');
      let lastDragTime = 0;
      const DRAG_THROTTLE = 50; // 50ms 쓰로틀
      if (miniCanvas) {
        // 마우스 다운
        miniCanvas.addEventListener('mousedown', (e) => {
          if (!isRecording || !isPaused) return;
          isLiveMinimapDragging = true;
          handleLiveMinimapDrag(e);
        });
        // 마우스 이동 (쓰로틀링 적용)
        miniCanvas.addEventListener('mousemove', (e) => {
          if (!isLiveMinimapDragging) return;
          const now = Date.now();
          if (now - lastDragTime < DRAG_THROTTLE) return;
          lastDragTime = now;
          handleLiveMinimapDrag(e);
        });
        // 마우스 업 (window에서)
        window.addEventListener('mouseup', () => {
          isLiveMinimapDragging = false;
        });
        // 클릭 (드래그 안 할 때)
        miniCanvas.addEventListener('click', (e) => {
          if (!isRecording || !isPaused) return;
          handleLiveMinimapDrag(e);
        });
      }
      // 녹음 일시정지 중 키보드로 위치 이동 및 줌
      document.addEventListener('keydown', (e) => {
        if (!isRecording || !isPaused) return;
        const totalSamples = flushedLength + liveRecordingData.length * LIVE_CHUNK_SIZE;
        const duration = totalSamples / audioCtx.sampleRate;
        const baseViewDuration = 15;
        const viewDuration = baseViewDuration / liveZoomLevel;
        const step = viewDuration * 0.2; // 뷰 길이의 20%씩 이동
        if (e.key === 'ArrowLeft') {
          liveViewStartTime = Math.max(0, liveViewStartTime - step);
          liveViewLocked = false;
          e.preventDefault();
        } else if (e.key === 'ArrowRight') {
          const maxStart = Math.max(0, duration - viewDuration);
          liveViewStartTime = Math.min(maxStart, liveViewStartTime + step);
          liveViewLocked = false;
          e.preventDefault();
        } else if (e.key === 'ArrowUp') {
          // 줌 인
          liveZoomLevel = Math.min(4.0, liveZoomLevel + 0.2);
          liveViewLocked = false;
          e.preventDefault();
        } else if (e.key === 'ArrowDown') {
          // 줌 아웃
          liveZoomLevel = Math.max(0.5, liveZoomLevel - 0.2);
          liveViewLocked = false;
          e.preventDefault();
        } else if (e.key === 'End') {
          // End 키: 최신 위치로 이동
          liveViewLocked = true;
          e.preventDefault();
        } else if (e.key === 'Home') {
          // Home 키: 처음으로 이동
          liveViewStartTime = 0;
          liveViewLocked = false;
          e.preventDefault();
        }
      });
      // 녹음 일시정지 중 웨이브 화면에서 휠로 확대/축소
      const waveContainer = $('waveContainer');
      if (waveContainer) {
        waveContainer.addEventListener('wheel', (e) => {
          if (!isRecording || !isPaused) return;
          e.preventDefault();
          // 기존 줌 시스템 사용
          const delta = e.deltaY > 0 ? -0.1 : 0.1;
          zoomLevel = Math.max(0.5, Math.min(10.0, zoomLevel + delta));
          liveZoomLevel = zoomLevel;
          // 수동 줌 모드로 전환 + 보이는 시간 간격 저장
          userManualZoom = true;
          const track = tracks[activeTrackIndex];
          if (track && track.duration > 0) {
            recordingViewDuration = track.duration / zoomLevel;
          }
          // 기존 웨이브폼 다시 그리기
          isRendering = false;
          drawWaveform();
        }, {
          passive: false
        });
      }
      updateRecSettingSummary();
      updateWaveTargetLine();
      // 자동 저장 설정 복원
      if ($('chkAutoSave')) {
        $('chkAutoSave').checked = localStorage.getItem('autoSaveOnStop') === 'true';
        $('chkAutoSave').addEventListener('change', (e) => {
          localStorage.setItem('autoSaveOnStop', e.target.checked);
        });
      }
      console.log('✅ 녹음 섹션 초기화 완료');
    }

    function updateWaveTargetLine() {
      const line = $('waveTargetLine');
      if (!line) return;
      const percent = Math.max(0, Math.min(100, (targetDbLevel + 60) / 60 * 100));
      line.style.bottom = percent + '%';
    }

    function updateRecSettingSummary() {
      const el = $('recSettingSummary');
      if (!el) return;
      const sr = parseInt($('selectSampleRate')?.value || 48000);
      const bit = $('selectBitDepth')?.value || '16';
      const ch = parseInt($('selectChannels')?.value || 1);
      const srStr = sr >= 1000 ? (sr / 1000) + 'kHz' : sr + 'Hz';
      const chStr = ch >= 2 ? 'Stereo' : 'Mono';
      el.textContent = srStr + ' / ' + bit + 'bit / ' + chStr;
    }

    // 녹음 중 미니맵 드래그 핸들러
    function handleLiveMinimapDrag(e) {
      if (!isRecording || !isPaused) return;
      const miniCanvas = $('minimapCanvas');
      if (!miniCanvas) return;
      const rect = miniCanvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const ratio = Math.max(0, Math.min(1, clickX / miniCanvas.width));
      // 현재 트랙의 duration 사용 (임시 버퍼 기준)
      const track = tracks[activeTrackIndex];
      if (!track || !track.buffer) return;
      const duration = track.duration;
      const scrollContainer = $('timelineScroll');
      const waveContainer = $('waveContainer');
      if (!scrollContainer || !waveContainer) return;
      // 클릭한 위치로 스크롤 이동 (기존 시스템 방식)
      const totalWidth = waveContainer.clientWidth * zoomLevel;
      const viewWidth = waveContainer.clientWidth;
      const newScrollLeft = (ratio * totalWidth) - (viewWidth / 2);
      scrollContainer.scrollLeft = Math.max(0, Math.min(totalWidth - viewWidth, newScrollLeft));
      // 기존 웨이브폼 다시 그리기
      isRendering = false;
      drawWaveform();
    }
    // 오디오 입력 장치 목록 가져오기 (권한 요청 없이)
    async function populateAudioInputDevices(skipPermissionRequest = false) {
      const select = $('selectAudioInput');
      if (!select) return;
      const prevValue = select.value;
      let tempStream = null; // 스트림 유지용 변수 추가

      try {
        let devices = await navigator.mediaDevices.enumerateDevices();
        let audioInputs = devices.filter(d => d.kind === 'audioinput');
        
        // 라벨이 존재하는지 확인
        let hasLabels = audioInputs.length > 0 && audioInputs[0].label;

        // 라벨이 비어있다면(스트림이 없어서 숨겨진 경우) 스트림을 연 상태로 다시 조회
        if (!hasLabels && !skipPermissionRequest) {
          try {
            console.log('🎤 마이크 권한 요청 및 라벨 확보 중...');
            // 1. 스트림을 열고 닫지 않음!
            tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            
            // 2. 스트림이 활성화된 상태에서 장치 목록을 다시 가져옴
            devices = await navigator.mediaDevices.enumerateDevices();
            audioInputs = devices.filter(d => d.kind === 'audioinput');
            console.log('🎤 마이크 목록 확보 완료');
          } catch (permErr) {
            console.warn('🎤 마이크 권한 요청 실패:', permErr.message);
          }
        }

        // 셀렉트 박스 렌더링
        select.innerHTML = '';
        if (audioInputs.length > 0 && audioInputs[0].label) {
          audioInputs.forEach((device, index) => {
            const option = document.createElement('option');
            option.value = device.deviceId || 'default';
            option.textContent = device.label || `마이크 ${index + 1}`;
            if (device.deviceId === 'default') option.textContent = '기본값 - ' + (device.label || 'Default');
            select.appendChild(option);
          });
        } else {
          const opt = document.createElement('option');
          opt.value = 'default';
          opt.textContent = '기본 마이크 (권한 필요)';
          select.appendChild(opt);
        }

        // 이전 선택값 복원
        if (prevValue && [...select.options].some(o => o.value === prevValue)) {
          select.value = prevValue;
        } else if (select.options.length > 0) {
          select.selectedIndex = 0;
        }
        selectedInputDeviceId = select.value;

      } catch (err) {
        console.error('입력 장치 목록 가져오기 실패:', err);
      } finally {
        // 3. 목록 생성이 모두 끝난 후(finally 블록)에 스트림을 안전하게 닫아줍니다.
        if (tempStream) {
          tempStream.getTracks().forEach(t => t.stop());
        }
      }
    }
    // 입력 모니터링 설정
    async function setupInputMonitoring() {
      stopInputMonitoring();
      if (!selectedInputDeviceId) return;
      try {
        initAudioContext();
        const monitorConstraints = {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        };
        if (selectedInputDeviceId && selectedInputDeviceId !== 'default') {
          monitorConstraints.deviceId = { exact: selectedInputDeviceId };
        }
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: monitorConstraints
        });
        // 오디오 노드 연결 (기존 연결이 없을 때만 생성)
        let source;
        if (!inputAnalyser) {
          source = audioCtx.createMediaStreamSource(mediaStream);
          inputAnalyser = audioCtx.createAnalyser();
          inputAnalyser.fftSize = 2048;
          inputMonitorGain = audioCtx.createGain();
          inputMonitorGain.gain.value = $('chkInputMonitor')?.checked ? (parseInt($('monitorVolume')?.value || 100) / 100) : 0;
          source.connect(inputAnalyser);
          inputAnalyser.connect(inputMonitorGain);
          inputMonitorGain.connect(audioCtx.destination);
          startLevelMeter();
        } else {
          source = audioCtx.createMediaStreamSource(mediaStream);
        }
        source.connect(inputAnalyser);
        inputAnalyser.connect(inputMonitorGain);
        inputMonitorGain.connect(audioCtx.destination);
        startLevelMeter();
        console.log('✅ 입력 모니터링 설정 완료');
      } catch (err) {
        console.error('입력 모니터링 설정 실패:', err);
        showCenterToast('⚠️ 마이크 연결 실패');
      }
    }
    // 입력 모니터링 정지
    function stopInputMonitoring() {
      if (levelAnimationId) {
        cancelAnimationFrame(levelAnimationId);
        levelAnimationId = null;
      }
      if (mediaStream && !isRecording) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }
      inputAnalyser = null;
      inputMonitorGain = null;
      const levelBar = $('inputLevelBar');
      const levelValue = $('inputLevelValue');
      if (levelBar) levelBar.style.width = '0%';
      if (levelValue) levelValue.textContent = '-∞ dB';
    }
    // 레벨 미터 시작
    function startLevelMeter() {
      if (!inputAnalyser) return;
      const dataArray = new Float32Array(inputAnalyser.fftSize);
      const levelBar = $('inputLevelBar');
      const levelValue = $('inputLevelValue');
      const waveLevelBar = $('waveLevelBar');

      let smoothPercent = 0;
      let smoothPercentH = 0;
      const decayRate = 0.92;

      // 피크 홀드
      let peakPercent = 0;
      let peakHoldTime = 0;
      const peakHoldDuration = 1500;  // 1.5초 유지
      const peakDecayRate = 0.96;     // 피크 선은 더 천천히 떨어짐
      const wavePeakLine = $('wavePeakLine');

      function updateMeter() {
        if (!inputAnalyser) return;
        inputAnalyser.getFloatTimeDomainData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i] * dataArray[i];
        }
        const rms = Math.sqrt(sum / dataArray.length);
        const db = rms > 0 ? 20 * Math.log10(rms) : -100;
        const percent = Math.max(0, Math.min(100, (db + 60) / 60 * 100));
        const now = Date.now();

        // 수평 미터: 스무스 디케이
        if (percent >= smoothPercentH) {
          smoothPercentH = percent;
        } else {
          smoothPercentH = smoothPercentH * decayRate;
          if (smoothPercentH < 0.5) smoothPercentH = 0;
        }
        if (levelBar) levelBar.style.width = smoothPercentH + '%';
        if (levelValue) levelValue.textContent = db > -60 ? db.toFixed(1) + ' dB' : '-∞ dB';

        // 수직 미터: 스무스 디케이
        if (percent >= smoothPercent) {
          smoothPercent = percent;
        } else {
          smoothPercent = smoothPercent * decayRate;
          if (smoothPercent < 0.5) smoothPercent = 0;
        }
        if (waveLevelBar) waveLevelBar.style.height = smoothPercent + '%';

        // 피크 인디케이터
        if (percent >= peakPercent) {
          peakPercent = percent;
          peakHoldTime = now;
        } else if (now - peakHoldTime > peakHoldDuration) {
          // 홀드 시간 지나면 천천히 하강
          peakPercent = peakPercent * peakDecayRate;
          if (peakPercent < 0.5) peakPercent = 0;
        }
        if (wavePeakLine) {
          if (peakPercent > 0.5) {
            wavePeakLine.style.display = 'block';
            wavePeakLine.style.bottom = peakPercent + '%';
          } else {
            wavePeakLine.style.display = 'none';
          }
        }

        levelAnimationId = requestAnimationFrame(updateMeter);
      }
      updateMeter();
    }
    // 시간 포맷팅 (초 → MM:SS.ms)
    function formatTime(seconds) {
      if (!seconds || !isFinite(seconds)) return '00:00.0';
      const mins = Math.floor(seconds / 60);
      const secs = (seconds % 60).toFixed(1);
      return String(mins).padStart(2, '0') + ':' + secs.padStart(4, '0');
    }
    // 녹음 시작
    // 입력 장치 미선택 안내 모달
    function showInputDeviceModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.style.display = 'flex';
      modal.innerHTML = `
        <div class="modal-box" style="width:400px;">
          <div class="modal-title">🎙️ 입력 장치를 선택해주세요</div>
          <div class="modal-desc">
            <p style="margin-bottom:12px; color:#666;">녹음을 시작하려면 먼저 오디오 입력 장치를 선택해야 합니다.</p>
            <div style="padding:12px; background:#e3f2fd; border-radius:8px; font-size:12px; line-height:1.6;">
              <strong>📖 설정 방법</strong>
              <p style="margin:8px 0 0 0;">
                1. 사이드바 상단의 <strong>입력 장치</strong> 드롭다운을 클릭하세요<br>
                2. 사용할 마이크를 선택하세요<br>
                3. 레벨 미터로 입력 신호를 확인하세요<br>
                4. 녹음 시작 버튼을 누르세요
              </p>
            </div>
            <div style="padding:10px; background:#fff8e1; border-radius:8px; margin-top:12px; font-size:11px;">
              <strong>⚠️ 장치가 보이지 않나요?</strong>
              <p style="margin:6px 0 0 0; line-height:1.5;">
                브라우저에서 마이크 접근 권한을 허용해주세요.<br>
                주소창 왼쪽의 🔒 아이콘을 클릭하여 확인할 수 있습니다.
              </p>
            </div>
          </div>
          <div class="modal-actions">
            <button class="btn primary" id="btnInputModalSelect">입력 장치 선택하기</button>
            <button class="btn" id="btnInputModalClose">닫기</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      modal.querySelector('#btnInputModalClose').addEventListener('click', () => {
        modal.remove();
      });
      modal.querySelector('#btnInputModalSelect').addEventListener('click', async () => {
        modal.remove();
        // 권한 요청하여 장치 목록 갱신
        try {
          const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          tempStream.getTracks().forEach(t => t.stop());
          await populateAudioInputDevices();
          showCenterToast('🎙️ 입력 장치 목록이 갱신되었습니다. 장치를 선택해주세요.');
        } catch (err) {
          showCenterToast('⚠️ 마이크 권한이 거부되었습니다.');
        }
      });
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });
    }
    async function startRecording() {
      if (isRecording) return;
      // 입력 장치 체크
      const selectInput = $('selectAudioInput');
      if (!selectInput || !selectInput.value) {
        showInputDeviceModal();
        return;
      }
      try {
        // audioCtx 확실히 초기화
        if (!audioCtx) {
          initAudioContext();
        }
        if (audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }
        // 항상 새 스트림 획득 (이전 스트림 정리)
        if (mediaStream) {
          mediaStream.getTracks().forEach(t => t.stop());
          mediaStream = null;
        }
        const deviceId = selectInput.value;
        const audioConstraints = {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        };
        if (deviceId && deviceId !== 'default' && deviceId !== '') {
          audioConstraints.deviceId = { exact: deviceId };
        }
        if (recordChannels >= 2) {
          audioConstraints.channelCount = 2;
        }
        console.log('🎙️ getUserMedia 요청:', JSON.stringify(audioConstraints));
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: audioConstraints
        });
        console.log('🎙️ 스트림 획득 성공');
        // 권한 획득 후 장치 목록 갱신 (label 포함)
        populateAudioInputDevices(true);
        // 오디오 노드 연결
        const source = audioCtx.createMediaStreamSource(mediaStream);
        inputAnalyser = audioCtx.createAnalyser();
        inputAnalyser.fftSize = 2048;
        inputMonitorGain = audioCtx.createGain();
        inputMonitorGain.gain.value = $('chkInputMonitor')?.checked ? 1.0 : 0;
        // 입력 분석기 연결 (레벨 미터용)
        source.connect(inputAnalyser);
        inputAnalyser.connect(inputMonitorGain);
        inputMonitorGain.connect(audioCtx.destination);
        // 레벨 미터 시작
        startLevelMeter();
        // AudioWorklet으로 실시간 데이터 수집 (별도 오디오 스레드)
        const spChannels = recordChannels >= 2 ? 2 : 1;
        liveRecordingData = [];
        liveRecordingDataR = [];
        flushedChunksL = [];
        flushedChunksR = [];
        flushedLength = 0;
        workletBatchL = new Float32Array(LIVE_CHUNK_SIZE);
        workletBatchR = recordChannels >= 2 ? new Float32Array(LIVE_CHUNK_SIZE) : null;
        workletBatchPos = 0;
        const workletCode = `
          class RecorderProcessor extends AudioWorkletProcessor {
            constructor() {
              super();
              this.bufferSize = 8192;
              this.buffersL = new Float32Array(this.bufferSize);
              this.buffersR = new Float32Array(this.bufferSize);
              this.pos = 0;
            }
            process(inputs) {
              const input = inputs[0];
              if (!input || !input[0]) return true;
              const len = input[0].length;
              for (let i = 0; i < len; i++) {
                this.buffersL[this.pos] = input[0][i];
                this.buffersR[this.pos] = input.length >= 2 ? input[1][i] : input[0][i];
                this.pos++;
                if (this.pos >= this.bufferSize) {
                  this.port.postMessage({
                    left: new Float32Array(this.buffersL),
                    right: new Float32Array(this.buffersR)
                  });
                  this.pos = 0;
                }
              }
              return true;
            }
          }
          registerProcessor('recorder-processor', RecorderProcessor);
        `;
        const blob = new Blob([workletCode], { type: 'application/javascript' });
        const workletUrl = URL.createObjectURL(blob);
        if (!workletRegistered) {
          try {
            await audioCtx.audioWorklet.addModule(workletUrl);
            workletRegistered = true;
          } catch (e) { /* 이미 등록된 경우 무시 */
            workletRegistered = true;
          }
        }
        URL.revokeObjectURL(workletUrl);
        workletNode = new AudioWorkletNode(audioCtx, 'recorder-processor', {
          numberOfInputs: 1,
          numberOfOutputs: 1,
          channelCount: spChannels
        });
        workletNode.port.onmessage = (e) => {
          if (!isRecording || isPaused) return;
          liveRecordingData.push(e.data.left);
          if (recordChannels >= 2) {
            liveRecordingDataR.push(e.data.right);
          }
        };
        source.connect(workletNode);
        // AudioWorklet을 무음으로 destination에 연결 (audio graph 활성 유지)
        const workletSilentGain = audioCtx.createGain();
        workletSilentGain.gain.value = 0;
        workletNode.connect(workletSilentGain);
        workletSilentGain.connect(audioCtx.destination);
        // MediaRecorder도 병행 (최종 파일용)
        //recordedChunks = [];
        const options = {
          mimeType: 'audio/webm;codecs=opus'
        };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'audio/webm';
        }
        mediaRecorder = new MediaRecorder(mediaStream, options);
        mediaRecorder.ondataavailable = (e) => {
          // 청크를 메모리에 쌓지 않음 (최종 처리는 AudioWorklet 데이터 사용)
          // MediaRecorder는 onstop 이벤트 트리거 용도로만 유지
        };
        mediaRecorder.onstop = processRecordedAudio;
        const isInsertMode = $('chkRecordAppend')?.checked && activeTrackIndex >= 0 && tracks[activeTrackIndex]?.buffer;
        const isContinueMode = $('chkRecordContinue')?.checked && activeTrackIndex >= 0 && tracks[activeTrackIndex]?.buffer;

        // === 설정 불일치 확인 (이어서/삽입 모드) ===
        if (isContinueMode || isInsertMode) {
          const trackBuf = tracks[activeTrackIndex].buffer;
          const trackCh = trackBuf.numberOfChannels;
          const trackSr = trackBuf.sampleRate;
          const mismatches = [];
          if (trackCh !== recordChannels) {
            mismatches.push(`채널: 음원 <b>${trackCh === 1 ? '모노(1ch)' : '스테레오(2ch)'}</b> ↔ 녹음 설정 <b>${recordChannels === 1 ? '모노(1ch)' : '스테레오(2ch)'}</b>`);
          }
          if (trackSr !== recordSampleRate) {
            mismatches.push(`샘플레이트: 음원 <b>${trackSr.toLocaleString()}Hz</b> ↔ 녹음 설정 <b>${recordSampleRate.toLocaleString()}Hz</b>`);
          }
          if (mismatches.length > 0) {
            const confirmed = await new Promise(resolve => {
              const modalEl = document.createElement('div');
              modalEl.className = 'modal-overlay open';
              modalEl.innerHTML = `
                <div class="modal-box">
                  <div class="modal-title">녹음 설정 불일치</div>
                  <div class="modal-desc">
                    현재 음원과 녹음 설정이 다릅니다.<br><br>
                    ${mismatches.join('<br>')}<br><br>
                    현재 음원에 맞춰서 녹음을 진행할까요?
                  </div>
                  <div class="modal-actions">
                    <button class="btn primary" id="btnMismatchConfirm">확인</button>
                    <button class="btn" id="btnMismatchCancel">취소</button>
                  </div>
                </div>`;
              document.body.appendChild(modalEl);
              modalEl.querySelector('#btnMismatchConfirm').onclick = () => { modalEl.remove(); resolve(true); };
              modalEl.querySelector('#btnMismatchCancel').onclick = () => { modalEl.remove(); resolve(false); };
            });
            if (!confirmed) return;
            // 현재 음원에 맞춰 설정 변경
            if (trackCh !== recordChannels) {
              recordChannels = trackCh;
              $('selectChannels').value = String(trackCh);
            }
            if (trackSr !== recordSampleRate) {
              recordSampleRate = trackSr;
              $('selectSampleRate').value = String(trackSr);
            }
          }
        }

        if (isContinueMode) {
          // === 이어서 녹음 모드 ===
          appendOriginalBuffer = tracks[activeTrackIndex].buffer;
          const track = tracks[activeTrackIndex];
          track.isRecording = true;
          track._isLiveRec = true;    // ← 추가
          // 선택/커서를 원본 끝으로 이동
          anchorTime = appendOriginalBuffer.duration;
          playbackOffset = appendOriginalBuffer.duration;
          selStartTime = null;
          selEndTime = null;
          clearMinimap();
        } else if (isInsertMode) {
          // === 현재 위치에 삽입 모드 ===
          // 원본 트랙 정보 저장
          insertTargetTrackIndex = activeTrackIndex;
          insertTargetBuffer = tracks[activeTrackIndex].buffer;
          insertTime = selStartTime !== null ? Math.min(selStartTime, selEndTime || selStartTime) : anchorTime;
          // 임시 녹음 트랙 생성 (녹음 파형 표시용)
          tracks.forEach(t => t.selected = false);
          const now = new Date();
          const timeStr = String(now.getHours()).padStart(2,'0') + String(now.getMinutes()).padStart(2,'0') + String(now.getSeconds()).padStart(2,'0');
          const tempTrack = {
            name: `EasyRec_${timeStr} (삽입용)`,
            buffer: null,
            duration: 0,
            segments: [],
            markers: [],
            undoStack: [],
            redoStack: [],
            selected: true,
            isRecording: true,
            _isLiveRec: true          // ← 추가
          };
          tracks.push(tempTrack);
          activeTrackIndex = tracks.length - 1;
          renderPlaylist();
          clearMinimap();
        } else {
          // === 새 트랙으로 녹음 모드 ===
          appendOriginalBuffer = null;
          insertTargetTrackIndex = -1;
          insertTargetBuffer = null;
          insertTime = 0;
          tracks.forEach(t => t.selected = false);
          const now = new Date();
          const timeStr = String(now.getHours()).padStart(2,'0') + String(now.getMinutes()).padStart(2,'0') + String(now.getSeconds()).padStart(2,'0');
          const tempTrack = {
            name: `EasyRec_${timeStr}`,
            buffer: null,
            duration: 0,
            segments: [],
            markers: [],
            undoStack: [],
            redoStack: [],
            selected: true,
            isRecording: true,
            _isLiveRec: true          // ← 추가
          };
          tracks.push(tempTrack);
          activeTrackIndex = tracks.length - 1;
          renderPlaylist();
        }
        // 캔버스 초기화 (첫 녹음 시 필요)
        const canvas = $('waveCanvas');
        const container = $('waveContainer');
        if (canvas && container) {
          const displayWidth = Math.max(800, container.clientWidth || 800);
          const displayHeight = Math.max(250, container.clientHeight || 250);
          canvas.width = displayWidth;
          canvas.height = displayHeight;
          canvas.style.width = displayWidth + 'px';
          canvas.style.height = displayHeight + 'px';
        }
        // 빈 화면 메시지 숨기기
        const emptyMsg = $('wavePlaceholder');
        if (emptyMsg) emptyMsg.style.display = 'none';
        // 미니맵 캔버스 초기화
        const miniCanvas = $('minimapCanvas');
        const miniContainer = $('minimapWrapper');
        if (miniCanvas && miniContainer) {
          const miniWidth = Math.max(800, miniContainer.clientWidth || 800);
          const miniHeight = Math.max(40, miniContainer.clientHeight || 40);
          miniCanvas.width = miniWidth;
          miniCanvas.height = miniHeight;
        }
        clearMinimap();
        // 녹음 시작
        mediaRecorder.start(100);
        isRecording = true;
        isPaused = false;
        updateRecSettingSummary();
        pausedDuration = 0;
        recordingStartTime = Date.now();
        // 자동 백업 세션 시작
        backupChunkIndex = 0;
        clearBackup().then(() => {
          saveBackupMeta({
            startTime: recordingStartTime,
            sampleRate: audioCtx?.sampleRate || 48000,
            channels: recordChannels,
            chunkSize: LIVE_CHUNK_SIZE
          });
        });
        // 5초마다 미플러시 데이터도 백업
        if (backupInterval) clearInterval(backupInterval);
        backupInterval = setInterval(() => {
          if (!isRecording || isPaused) return;
          if (liveRecordingData.length === 0) return;
          const sr = audioCtx?.sampleRate || 48000;
          const totalChunks = flushedChunksL.length + liveRecordingData.length;
          const totalLen = flushedLength + liveRecordingData.length * LIVE_CHUNK_SIZE;
          // 미플러시 청크를 임시 백업
          saveBackupChunks(liveRecordingData, liveRecordingDataR, backupChunkIndex).then(() => {
            saveBackupMeta({
              startTime: recordingStartTime,
              sampleRate: sr,
              channels: recordChannels,
              chunkSize: LIVE_CHUNK_SIZE,
              totalChunks: totalChunks,
              duration: totalLen / sr
            });
          });
        }, 5000);
        if (isContinueMode || isInsertMode) {
          // 이어서/삽입 모드: 현재 확대율 유지 (단, 30초보다 넓으면 30초로)
          const totalDur = tracks[activeTrackIndex]?.duration || 10;
          const currentViewDur = totalDur / zoomLevel;
          if (currentViewDur > 30) {
            zoomLevel = totalDur / 30;
          }
          liveZoomLevel = zoomLevel;
          userManualZoom = true;
          recordingViewDuration = totalDur / zoomLevel;
        } else {
          // 새 트랙 모드: 줌 초기화
          liveZoomLevel = 1.0;
          zoomLevel = 1.0;
          userManualZoom = false;
          recordingViewDuration = 30;
        }
        // UI 업데이트
        $('btnStartRecord').style.display = 'none';
        $('recordingControls').style.display = 'block';
        if ($('btnPauseRecord')) { $('btnPauseRecord').style.display = 'inline-flex'; $('btnPauseRecord').textContent = '⏸ 일시정지 (R)'; }
        $('btnStopRecord').style.display = 'inline-flex';
        $('recordingStatus').textContent = '';
        // 하단 녹음 바
        $('bottomRecBar').style.display = 'flex';
        $('bottomBtnStart').style.display = 'none';
        if ($('bottomBtnPause')) { $('bottomBtnPause').style.display = 'inline-flex'; $('bottomBtnPause').textContent = '⏸ 일시정지 (R)'; }
        $('bottomBtnStop').style.display = 'inline-flex';
        $('bottomRecTimer').style.display = 'inline';
        // 녹음 중 설정 변경 불가
        $('selectSampleRate').disabled = true;
        $('selectBitDepth').disabled = true;
        $('selectChannels').disabled = true;
        if ($('chkRecordAppend')) $('chkRecordAppend').disabled = true;
        if ($('chkRecordContinue')) $('chkRecordContinue').disabled = true;
        if ($('chkRecordNewTrack')) $('chkRecordNewTrack').disabled = true;
        updateRecordingTimer();
        startLiveBufferUpdate(); // 실시간 버퍼 업데이트 시작
        showCenterToast('🔴 녹음 시작');
        console.log('🎙️ 녹음 시작');
      } catch (err) {
        console.error('녹음 시작 실패:', err);
        if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
          showCenterToast('⚠️ 마이크 권한이 거부되었습니다. 브라우저 설정에서 마이크를 허용해주세요.');
        } else if (err.name === 'NotFoundError') {
          showCenterToast('⚠️ 마이크를 찾을 수 없습니다. 마이크가 연결되어 있는지 확인해주세요.');
        } else {
          showCenterToast('⚠️ 녹음 시작 실패: ' + err.message);
        }
      }
    }
    // 실시간 버퍼 업데이트 시작 (기존 drawWaveform 시스템 사용)
    function startLiveBufferUpdate() {
      if (!audioCtx) initAudioContext();
      const sampleRate = audioCtx?.sampleRate || 48000;
      const META_INTERVAL = 80; // 메타데이터 업데이트 간격 (ms)
      let lastMetaUpdate = 0;
      // 재개 시 줌 레벨 복원 (수동 줌이면 그대로 유지)
      if (userManualZoom && liveZoomLevel > 0) {
        zoomLevel = liveZoomLevel;
      }
      // 빈 화면 메시지 숨기기 & 캔버스 표시
      const emptyMsg = $('wavePlaceholder');
      if (emptyMsg) emptyMsg.style.display = 'none';
      // 캔버스 초기화 및 표시
      const canvas = $('waveCanvas');
      const container = $('waveContainer');
      if (canvas && container) {
        const displayWidth = Math.max(800, container.clientWidth || 800);
        const displayHeight = Math.max(250, container.clientHeight || 250);
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        canvas.style.display = 'block';
      }
      function liveDrawLoop(now) {
        if (!isRecording) {
          stopLiveBufferUpdate();
          return;
        }
        liveBufferUpdateInterval = requestAnimationFrame(liveDrawLoop);
        // 일시정지 중에는 스킵
        if (isPaused) return;
        // 메타데이터 업데이트는 80ms마다 (줌/플러시 계산은 비용이 있으므로)
        if (now - lastMetaUpdate >= META_INTERVAL) {
          lastMetaUpdate = now;
          const totalLength = flushedLength + liveRecordingData.length * LIVE_CHUNK_SIZE;
          if (totalLength === 0) {
            minimapNeedsRedraw = true;
            isRendering = false;
            drawWaveform();
            return;
          }
          try {
            // 현재 트랙에 메타데이터 설정
            if (activeTrackIndex >= 0 && tracks[activeTrackIndex]) {
              const track = tracks[activeTrackIndex];
              track._liveRecLength = totalLength;
              if (appendOriginalBuffer) {
                track.duration = appendOriginalBuffer.duration + (totalLength / sampleRate);
              } else {
                track.duration = totalLength / sampleRate;
              }
            }
            // 녹음 중 자동 줌 계산
            const recDuration = totalLength / sampleRate;
            const totalDuration = appendOriginalBuffer
              ? appendOriginalBuffer.duration + recDuration
              : recDuration;
            if (appendOriginalBuffer || insertTargetTrackIndex >= 0) {
              if (zoomLevel !== liveZoomLevel) {
                recordingViewDuration = totalDuration / zoomLevel;
              }
              zoomLevel = totalDuration / recordingViewDuration;
              liveZoomLevel = zoomLevel;
            } else {
              if (!userManualZoom) {
                if (totalDuration <= recordingViewDuration) {
                  zoomLevel = 1.0;
                } else {
                  zoomLevel = totalDuration / recordingViewDuration;
                }
              } else {
                if (totalDuration > recordingViewDuration) {
                  zoomLevel = totalDuration / recordingViewDuration;
                }
              }
            }
            liveZoomLevel = zoomLevel;
            // 30초마다 플러시 (장시간 녹음 안정성)
            if (liveRecordingData.length * LIVE_CHUNK_SIZE > 30 * sampleRate) {
              flushLiveRecording(sampleRate);
            }
          } catch (err) {
            console.error('실시간 버퍼 업데이트 실패:', err);
          }
        }
        // 그리기는 매 프레임 (~60fps)
        minimapNeedsRedraw = true;
        isRendering = false;
        drawWaveform();
      }
      liveBufferUpdateInterval = requestAnimationFrame(liveDrawLoop);
    }
    // 실시간 버퍼 업데이트 중지
    function stopLiveBufferUpdate() {
      if (liveBufferUpdateInterval) {
        cancelAnimationFrame(liveBufferUpdateInterval);
        liveBufferUpdateInterval = null;
      }
    }
    // 장시간 녹음 플러시: liveRecordingData → flushedChunks로 이동 (복사 없음, O(1))
    function flushLiveRecording(sampleRate) {
      if (liveRecordingData.length === 0) return;
      const sr = sampleRate || audioCtx?.sampleRate || 48000;
      const newLength = liveRecordingData.length * LIVE_CHUNK_SIZE;
      const newChunksL = liveRecordingData;
      const newChunksR = liveRecordingDataR;
      const saveStartIdx = backupChunkIndex;
      // 청크 참조만 이동 (데이터 복사 없음!)
      flushedChunksL.push(...newChunksL);
      flushedChunksR.push(...newChunksR);
      flushedLength += newLength;
      liveRecordingData = [];
      liveRecordingDataR = [];
      // IndexedDB에 새 청크만 백업 (비동기, 녹음에 영향 없음)
      saveBackupChunks(newChunksL, newChunksR, saveStartIdx).then(() => {
        saveBackupMeta({
          startTime: recordingStartTime,
          sampleRate: sr,
          channels: recordChannels,
          chunkSize: LIVE_CHUNK_SIZE,
          totalChunks: flushedChunksL.length,
          duration: flushedLength / sr
        });
      });
      backupChunkIndex = flushedChunksL.length;
      showBackupStatus('💾 백업 완료: ' + (flushedLength / sr).toFixed(1) + '초');
    }

    // 최종 AudioBuffer 생성 (녹음 종료 시 1회만 호출)
    function buildFinalAudioBuffer(sampleRate) {
      // 잔여 live 데이터도 합침
      if (liveRecordingData.length > 0) {
        flushLiveRecording(sampleRate);
      }
      if (flushedChunksL.length === 0) return null;
      const sr = sampleRate || audioCtx?.sampleRate || 48000;
      const numCh = flushedChunksR.length > 0 ? 2 : 1;
      const totalLength = flushedChunksL.length * LIVE_CHUNK_SIZE;
      const audioBuffer = audioCtx.createBuffer(numCh, totalLength, sr);
      const chL = audioBuffer.getChannelData(0);
      for (let i = 0; i < flushedChunksL.length; i++) {
        chL.set(flushedChunksL[i], i * LIVE_CHUNK_SIZE);
      }
      if (numCh >= 2) {
        const chR = audioBuffer.getChannelData(1);
        for (let i = 0; i < flushedChunksR.length; i++) {
          chR.set(flushedChunksR[i], i * LIVE_CHUNK_SIZE);
        }
      }
      return audioBuffer;
    }
    // 자동 스크롤 (녹음 중 최신 위치 따라가기)
    function autoScrollToEnd() {
      // 현재 뷰 유지 플래그가 설정되어 있으면 스크롤하지 않음
      if (keepCurrentView) return;
      const track = tracks[activeTrackIndex];
      if (!track || !track.buffer) return;
      const scrollContainer = $('timelineScroll');
      const waveContainer = $('waveContainer');
      if (!scrollContainer || !waveContainer) return;
      const totalWidth = waveContainer.clientWidth * zoomLevel;
      const viewWidth = waveContainer.clientWidth;
      // 항상 녹음 끝이 화면 오른쪽에 오도록 스크롤
      const targetScroll = totalWidth - viewWidth;
      if (targetScroll > 0) {
        scrollContainer.scrollLeft = targetScroll;
      } else {
        scrollContainer.scrollLeft = 0;
      }
    }
    // 미니맵 초기화
    function clearMinimap() {
      const miniCanvas = $('minimapCanvas');
      if (miniCanvas) {
        // 크기가 0이면 강제 설정
        if (miniCanvas.width === 0 || miniCanvas.height === 0) {
          const miniContainer = $('minimapWrapper');
          miniCanvas.width = miniContainer ? Math.max(800, miniContainer.clientWidth) : 800;
          miniCanvas.height = miniContainer ? Math.max(40, miniContainer.clientHeight) : 40;
        }
        const ctx = miniCanvas.getContext('2d');
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card').trim() || '#fff';
        ctx.fillRect(0, 0, miniCanvas.width, miniCanvas.height);
      }
    }
    // 실시간 미니맵 그리기
    function drawLiveMinimap(duration, viewStart, viewEnd) {
      const miniCanvas = $('minimapCanvas');
      if (!miniCanvas) return;
      const totalSamples = flushedLength + liveRecordingData.length * LIVE_CHUNK_SIZE;
      if (totalSamples === 0) return;
      const miniContainer = $('minimapWrapper');
      const dpr = window.devicePixelRatio || 1;
      if (miniCanvas.width === 0 || miniCanvas.height === 0 || miniCanvas.width < 100) {
        const w = miniContainer ? Math.max(800, miniContainer.clientWidth) : 800;
        const h = miniContainer ? Math.max(40, miniContainer.clientHeight) : 40;
        miniCanvas.width = w * dpr;
        miniCanvas.height = h * dpr;
      }
      const ctx = miniCanvas.getContext('2d');
      const width = miniCanvas.width / dpr;
      const height = miniCanvas.height / dpr;
      ctx.save();
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card').trim() || '#fff';
      ctx.fillRect(0, 0, width, height);
      const isStereo = recordChannels >= 2;
      const numCh = isStereo ? 2 : 1;
      const chH = isStereo ? height / 2 : height;
      const isDarkMode = document.documentElement.classList.contains('dark-mode');
      const step = Math.ceil(totalSamples / width);
      for (let ch = 0; ch < numCh; ch++) {
        const flushedArr = ch === 0 ? flushedChunksL : flushedChunksR;
        const liveArr = ch === 0 ? liveRecordingData : liveRecordingDataR;
        const chOffsetY = ch * chH;
        const chCenterY = chOffsetY + chH / 2;
        const chMaxAmp = chH / 2;
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line').trim() || '#e9e9e9';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, chCenterY);
        ctx.lineTo(width, chCenterY);
        ctx.stroke();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = isDarkMode ? adjustColorBrightness(waveColor, 30) : waveColor;
        for (let x = 0; x < width; x++) {
          let min = 1.0, max = -1.0;
          const sStart = x * step;
          const sEnd = Math.min(sStart + step, totalSamples);
          // 플러시된 청크에서 읽기
          if (flushedArr.length > 0 && sStart < flushedLength) {
            const end = Math.min(sEnd, flushedLength);
            const subStep = Math.max(1, Math.floor((end - sStart) / 32));
            for (let j = sStart; j < end; j += subStep) {
              const ci = (j / LIVE_CHUNK_SIZE) | 0;
              const oi = j % LIVE_CHUNK_SIZE;
              if (ci < flushedArr.length && flushedArr[ci]) {
                const val = flushedArr[ci][oi] || 0;
                if (val < min) min = val;
                if (val > max) max = val;
              }
            }
          }
          // 라이브 청크에서 읽기
          if (sEnd > flushedLength && liveArr.length > 0) {
            const lStart = Math.max(0, sStart - flushedLength);
            const lEnd = sEnd - flushedLength;
            const subStep = Math.max(1, Math.floor((lEnd - lStart) / 32));
            for (let j = lStart; j < lEnd; j += subStep) {
              const ci = (j / LIVE_CHUNK_SIZE) | 0;
              const oi = j % LIVE_CHUNK_SIZE;
              if (ci < liveArr.length && liveArr[ci]) {
                const val = liveArr[ci][oi] || 0;
                if (val < min) min = val;
                if (val > max) max = val;
              }
            }
          }
          if (min === 1.0 && max === -1.0) { min = 0; max = 0; }
          const topY = chCenterY - (max * chMaxAmp * 0.8);
          const bottomY = chCenterY - (min * chMaxAmp * 0.8);
          const barH = Math.max(1, bottomY - topY);
          ctx.fillRect(x, topY, 1, barH);
        }
        ctx.globalAlpha = 1;
      }
      if (duration > 0 && viewEnd > viewStart) {
        const vpStartX = (viewStart / duration) * width;
        const vpEndX = (Math.min(viewEnd, duration) / duration) * width;
        const vpWidth = Math.max(2, vpEndX - vpStartX);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        if (vpStartX > 0) ctx.fillRect(0, 0, vpStartX, height);
        if (vpEndX < width) ctx.fillRect(vpEndX, 0, width - vpEndX, height);
        ctx.strokeStyle = isPaused ? '#ff9800' : '#f44336';
        ctx.lineWidth = 2;
        ctx.strokeRect(vpStartX, 1, vpWidth, height - 2);
      }
      ctx.restore();
    }
    // 녹음 시간 표시 업데이트
    function updateRecordingTimer() {
      if (!isRecording) return;
      // 일시정지 시간 제외
      let elapsed = Date.now() - recordingStartTime - pausedDuration;
      if (isPaused) {
        elapsed -= (Date.now() - pauseStartTime);
      }
      const totalMs = Math.max(0, elapsed);
      const minutes = Math.floor(totalMs / 60000);
      const seconds = Math.floor((totalMs % 60000) / 1000);
      const ms = Math.floor((totalMs % 1000) / 100);
      const timerEl = $('recordingTime');
      if (timerEl) {
        const hours = Math.floor(totalMs / 3600000);
        const timeStr = String(hours).padStart(2, '0') + ':' +
          String(minutes % 60).padStart(2, '0') + ':' +
          String(seconds).padStart(2, '0') + '.' + ms;
        // 이어서 녹음 모드: 총 시간도 표시
        let totalStr = '';
        if (appendOriginalBuffer && activeTrackIndex >= 0 && tracks[activeTrackIndex]) {
          const totalSec = appendOriginalBuffer.duration + totalMs / 1000;
          const tH = Math.floor(totalSec / 3600);
          const tM = Math.floor((totalSec % 3600) / 60);
          const tS = Math.floor(totalSec % 60);
          const tMs = Math.floor((totalSec * 10) % 10);
          totalStr = ' (' + String(tH).padStart(2, '0') + ':' +
            String(tM).padStart(2, '0') + ':' +
            String(tS).padStart(2, '0') + '.' + tMs + ')';
        }
        const totalColor = document.documentElement.classList.contains('dark-mode') ? '#fff' : '#666';
        timerEl.innerHTML = timeStr + (totalStr ? '<span style="color:' + totalColor + '; font-size:12px;">' + totalStr + '</span>' : '');
        const bottomTimer = $('bottomRecTimer');
        if (bottomTimer) bottomTimer.innerHTML = timeStr + (totalStr ? '<span style="color:' + totalColor + '; font-size:16px;">' + totalStr + '</span>' : '');
      }
      requestAnimationFrame(updateRecordingTimer);
    }
    // 녹음 정지
    function stopRecording() {
      if (!isRecording) return;
      // mediaRecorder가 없어도 상태 정리는 해야 함
      if (!mediaRecorder) {
        isRecording = false;
        isPaused = false;
        isRendering = false;
        $('btnStartRecord').style.display = 'block';
        $('recordingControls').style.display = 'none';
        $('recordingTime').innerHTML = ''; 
        $('recordingStatus').textContent = '';
        // 하단 녹음 바 리셋
        $('bottomRecBar').style.display = 'flex';
        $('bottomBtnStart').style.display = 'inline-flex';
        $('bottomBtnStop').style.display = 'none';
        if ($('bottomBtnPause')) $('bottomBtnPause').style.display = 'none';
        $('bottomRecTimer').style.display = 'none';
        return;
      }
      // 먼저 isRecording을 false로 설정 (애니메이션 중지)
      isRecording = false;
      isPaused = false;
      // 백업 인터벌 정리
      if (backupInterval) {
        clearInterval(backupInterval);
        backupInterval = null;
      }
      mediaRecorder.stop();
      // AudioWorklet 정리
      if (workletNode) {
        workletNode.port.onmessage = null;
        workletNode.disconnect();
        workletNode = null;
      }
      // Worklet 내부 잔여 데이터는 process()가 return true로 계속 실행되므로
      // disconnect 시점에 자동 정리됨 (잔여 128미만 샘플은 무시 가능)

      // 실시간 버퍼 업데이트 정지
      stopLiveBufferUpdate();
      // 입력 분석기 정리 (스트림은 유지)
      /*
      if (inputAnalyser) {
      inputAnalyser.disconnect();
      inputAnalyser = null;
      }
      if (inputMonitorGain) {
      inputMonitorGain.disconnect();
      inputMonitorGain = null;
      }
      // 레벨 미터 정지
      if (levelAnimationId) {
      cancelAnimationFrame(levelAnimationId);
      levelAnimationId = null;
      }
      */
      // 스트림은 유지 (입력 장치 선택 유지를 위해)
      // mediaStream은 정리하지 않음
      // UI 업데이트
      $('btnStartRecord').style.display = 'block';
      $('recordingControls').style.display = 'none';
      $('recordingTime').innerHTML = ''; 
      $('recordingStatus').textContent = '';
      // 하단 녹음 바 리셋
      $('bottomRecBar').style.display = 'flex';
      $('bottomBtnStart').style.display = 'inline-flex';
      $('bottomBtnStop').style.display = 'none';
      if ($('bottomBtnPause')) $('bottomBtnPause').style.display = 'none';
      $('bottomRecTimer').style.display = 'none';
      // 녹음 설정 다시 활성화
      if ($('selectSampleRate')) $('selectSampleRate').disabled = false;
      if ($('selectBitDepth')) $('selectBitDepth').disabled = false;
      if ($('selectChannels')) $('selectChannels').disabled = false;
      // 레벨 미터 초기화
      const levelBar = $('inputLevelBar');
      const levelValue = $('inputLevelValue');
      if (levelBar) levelBar.style.width = '0%';
      if (levelValue) levelValue.textContent = '-∞ dB';
      // 렌더링 플래그 리셋 (혹시 모를 상황 대비)
      isRendering = false;
      showCenterToast('⬛ 녹음 정지, 처리 중...');
      console.log('🎙️ 녹음 정지');
      // 녹음 중 설정 다시 활성화
      if ($('chkRecordAppend')) $('chkRecordAppend').disabled = false;
      if ($('chkRecordContinue')) $('chkRecordContinue').disabled = false;
      if ($('chkRecordNewTrack')) $('chkRecordNewTrack').disabled = false;
    }
    // 녹음 일시정지 토글
    function togglePauseRecording() {
      if (!isRecording || !mediaRecorder) return;
      const btnPause = $('btnPauseRecord');
      const statusEl = $('recordingStatus');
      if (!isPaused) {
        // 일시정지
        mediaRecorder.pause();
        isPaused = true;
        pauseStartTime = Date.now();
        // 실시간 데이터를 임시 버퍼로 변환하여 기존 시스템 사용
        createTempBufferFromLiveData();
        $('btnPauseRecord').textContent = '▶ 계속 (R)';
        $('bottomBtnPause').textContent = '▶ 계속 (R)';
        if (statusEl) statusEl.textContent = ' (일시정지)';
        showCenterToast('⏸ 녹음 일시정지');
      } else {
        // 재개
        mediaRecorder.resume();
        isPaused = false;
        pausedDuration += Date.now() - pauseStartTime;
        // 현재 줌 레벨 저장 + 보이는 시간 간격 계산
        liveZoomLevel = zoomLevel;
        const track = tracks[activeTrackIndex];
        if (track && track.duration > 0 && zoomLevel > 0) {
          recordingViewDuration = track.duration / zoomLevel;
          userManualZoom = true; // 일시정지에서 재개하면 수동 모드 유지
        }
        // 재개 직후 잠시 뷰 유지
        keepCurrentView = true;
        setTimeout(() => {
          keepCurrentView = false;
        }, 500);
        // 임시 버퍼는 유지 (실시간 업데이트가 덮어씀)
        if (activeTrackIndex >= 0 && tracks[activeTrackIndex]) {
          tracks[activeTrackIndex].isRecording = true;
          tracks[activeTrackIndex]._isLiveRec = true;
          tracks[activeTrackIndex].buffer = null; // 라이브 모드로 복귀
        }
        $('btnPauseRecord').textContent = '⏸ 일시정지 (R)';
        $('bottomBtnPause').textContent = '⏸ 일시정지 (R)';
        if (statusEl) statusEl.textContent = '';
        showCenterToast('▶ 녹음 재개');
        // 실시간 버퍼 업데이트 재시작
        if (!liveBufferUpdateInterval) {
          startLiveBufferUpdate();
        }
      }
    }
    // 실시간 녹음 데이터를 임시 버퍼로 변환
    function createTempBufferFromLiveData() {
      if (liveRecordingData.length === 0 && flushedLength === 0) return;
      if (!audioCtx) initAudioContext();
      try {
        const sampleRate = audioCtx?.sampleRate || 48000;
        // 잔여 데이터 플러시
        const finalBuffer = buildFinalAudioBuffer(sampleRate);
        if (!finalBuffer) return;
        // 현재 트랙에 최종 버퍼 설정
        if (activeTrackIndex >= 0 && tracks[activeTrackIndex]) {
          tracks[activeTrackIndex].buffer = finalBuffer;
          tracks[activeTrackIndex].duration = finalBuffer.duration;
          tracks[activeTrackIndex].isRecording = false;
          delete tracks[activeTrackIndex]._isLiveRec;
          delete tracks[activeTrackIndex]._liveRecLength;
        }
        zoomLevel = liveZoomLevel;
        isRendering = false;
        drawWaveform();
      } catch (err) {
        console.error('임시 버퍼 생성 실패:', err);
      }
    }
    // 녹음된 오디오 처리
    async function processRecordedAudio() {
      // audioCtx 확인
      if (!audioCtx) {
        initAudioContext();
      }
      // 실시간 데이터로 AudioBuffer 생성
      const sampleRate = audioCtx?.sampleRate || 48000;
      // 잔여 데이터 플러시
      const audioBuffer = buildFinalAudioBuffer(sampleRate);
      if (!audioBuffer) {
        showCenterToast('⚠️ 녹음된 데이터가 없습니다');
        if (activeTrackIndex >= 0 && tracks[activeTrackIndex]?.isRecording) {
          tracks.splice(activeTrackIndex, 1);
          activeTrackIndex = tracks.length > 0 ? tracks.length - 1 : -1;
          renderPlaylist();
        }
        return;
      }
      try {
        const numChannels = audioBuffer.numberOfChannels;
        const totalLength = audioBuffer.length;
        const duration = audioBuffer.duration;
        const minutes = Math.floor(duration / 60);
        const seconds = (duration % 60).toFixed(1);
        if (appendOriginalBuffer) {
          // === 이어서 녹음 모드 완료 ===
          if (activeTrackIndex >= 0 && tracks[activeTrackIndex]) {
            const track = tracks[activeTrackIndex];
            delete track._liveRecBuffer; // 듀얼 버퍼 정리
            delete track._isLiveRec;
            delete track._liveRecLength;
            const combined = concatBuffers(appendOriginalBuffer, audioBuffer);
            track.buffer = combined;
            track.duration = combined.duration;
            track.isRecording = false;
            track.isDirty = true;
            saveState();
            const recDuration = audioBuffer.duration;
            showCenterToast(`✅ ${formatTime(recDuration)} 녹음이 이어붙여졌습니다 (총 ${formatTime(combined.duration)})`);
          }
          appendOriginalBuffer = null;
        } else if (insertTargetTrackIndex >= 0 && insertTargetBuffer) {
          // === 현재 음원에 선택된 위치에서 녹음 모드 ===
          // 임시 녹음 트랙 제거
          if (activeTrackIndex >= 0 && tracks[activeTrackIndex]?.isRecording) {
            tracks.splice(activeTrackIndex, 1);
          }
          // 원본 트랙으로 돌아가기
          activeTrackIndex = Math.min(insertTargetTrackIndex, tracks.length - 1);
          tracks[activeTrackIndex].selected = true;
          // 원본 버퍼에 녹음 데이터 삽입
          const targetTrack = tracks[activeTrackIndex];
          targetTrack.buffer = insertTargetBuffer; // 원본 복원
          targetTrack.duration = insertTargetBuffer.duration;
          await insertRecordedAudio(audioBuffer);
          // 정리
          insertTargetTrackIndex = -1;
          insertTargetBuffer = null;
          insertTime = 0;
        } else {
          // === 새 트랙으로 녹음 ===
          if (activeTrackIndex >= 0 && tracks[activeTrackIndex]?.isRecording) {
            const track = tracks[activeTrackIndex];
            track.buffer = audioBuffer;
            track.duration = audioBuffer.duration;
            track.isRecording = false;
            delete track._isLiveRec;
            delete track._liveRecLength;
            saveState();
          }
        }
        // 실시간 데이터 정리
        liveRecordingData = [];
        liveRecordingDataR = [];
        flushedChunksL = [];
        flushedChunksR = [];
        flushedLength = 0;
        // 정상 종료 시 백업 삭제
        clearBackup();
        // UI 업데이트
        renderPlaylist();
        selStartTime = null;
        selEndTime = null;
        anchorTime = 0;
        // zoomLevel 유지 (녹음 중 확대율 그대로) //zoomLevel = 1.0;
        // isRendering 플래그 강제 리셋
        isRendering = false;
        // 캔버스 강제 초기화 (첫 녹음 시 필요)
        const canvas = $('waveCanvas');
        const container = $('waveContainer');
        if (canvas && container) {
          const displayWidth = Math.max(800, container.clientWidth);
          const displayHeight = Math.max(250, container.clientHeight);
          canvas.width = displayWidth;
          canvas.height = displayHeight;
          canvas.style.width = displayWidth + 'px';
          canvas.style.height = displayHeight + 'px';
        }
        // 미니맵 캔버스도 초기화
        const miniCanvas = $('minimapCanvas');
        const miniContainer = $('minimapContainer');
        if (miniCanvas && miniContainer) {
          miniCanvas.width = miniContainer.clientWidth || 800;
          miniCanvas.height = miniContainer.clientHeight || 50;
        }
        // 강제로 파형 다시 그리기
        setTimeout(() => {
          isRendering = false;
          forceRedrawWaveform();
        }, 50);
        // 한번 더 확실하게
        setTimeout(() => {
          isRendering = false;
          forceRedrawWaveform();
        }, 200);
        // 최종 확인
        setTimeout(() => {
          isRendering = false;
          forceRedrawWaveform();
        }, 500);
        setTimeout(() => {
          if (activeTrackIndex >= 0 && tracks[activeTrackIndex]?.buffer) {
            drawWaveform();
            drawMinimap();
          }
        }, 200);
        // 이어서 녹음 모드: 확정된 총 시간 표시
        if ($('chkRecordContinue')?.checked && activeTrackIndex >= 0 && tracks[activeTrackIndex]?.buffer) {
          const totalSec = tracks[activeTrackIndex].buffer.duration;
          const tH = Math.floor(totalSec / 3600);
          const tM = Math.floor((totalSec % 3600) / 60);
          const tS = Math.floor(totalSec % 60);
          const tMs = Math.floor((totalSec * 10) % 10);
          const totalStr = String(tH).padStart(2, '0') + ':' + String(tM).padStart(2, '0') + ':' + String(tS).padStart(2, '0') + '.' + tMs;
          const totalColor = document.documentElement.classList.contains('dark-mode') ? '#fff' : '#666';
          const timerHtml = '<span style="color:' + totalColor + '; font-size:14px;">총 ' + totalStr + '</span>';
          if ($('recordingTime')) $('recordingTime').innerHTML = timerHtml;
          const bottomTimer = $('bottomRecTimer');
          if (bottomTimer) {
            bottomTimer.innerHTML = '<span style="color:' + totalColor + '; font-size:16px;">총 ' + totalStr + '</span>';
            bottomTimer.style.display = 'inline';
          }
        }
        showCenterToast(`✅ 녹음 완료 (${minutes}분 ${seconds}초)`);
        console.log(`✅ 녹음 완료, 길이: ${duration.toFixed(2)}초`);
        // 자동 저장
        if ($('chkAutoSave')?.checked && activeTrackIndex >= 0 && tracks[activeTrackIndex]?.buffer) {
          try {
            const track = tracks[activeTrackIndex];
            let fileName = track.name;
            if (!fileName.toLowerCase().endsWith('.wav')) fileName += '.wav';
            const wavBlob = audioBufferToWav(track.buffer);
            // 저장 위치 선택 다이얼로그 시도 → 실패 시 기본 다운로드
            let saved = false;
            if (window.showSaveFilePicker) {
              try {
                const handle = await window.showSaveFilePicker({
                  suggestedName: fileName,
                  types: [{ description: 'WAV Audio', accept: { 'audio/wav': ['.wav'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(wavBlob);
                await writable.close();
                saved = true;
                showCenterToast(`💾 저장 완료: ${fileName}`, 2000);
              } catch (pickerErr) {
                if (pickerErr.name !== 'AbortError') {
                  console.warn('FilePicker 실패, 기본 다운로드로 전환:', pickerErr);
                } else {
                  saved = true; // 사용자가 취소한 경우
                }
              }
            }
            if (!saved) {
              downloadBlob(wavBlob, fileName, 'audio/wav');
              showCenterToast(`💾 자동 저장: ${fileName}`, 2000);
            }
          } catch (autoSaveErr) {
            console.error('자동 저장 실패:', autoSaveErr);
            showCenterToast('⚠️ 자동 저장 실패: ' + autoSaveErr.message);
          }
        }
      } catch (err) {
        console.error('녹음 처리 실패:', err);
        showCenterToast('⚠️ 녹음 처리 실패: ' + err.message);
        // 오류 시 임시 트랙 제거
        if (activeTrackIndex >= 0 && tracks[activeTrackIndex]?.isRecording) {
          tracks.splice(activeTrackIndex, 1);
          activeTrackIndex = tracks.length > 0 ? tracks.length - 1 : -1;
          renderPlaylist();
        }
      }
    }
    // 현재 위치에 녹음 삽입
    async function insertRecordedAudio(recordedBuffer) {
      if (activeTrackIndex < 0) {
        showCenterToast('⚠️ 삽입할 트랙이 없습니다');
        return;
      }
      const track = tracks[activeTrackIndex];
      const currentBuffer = track.buffer;
      // 저장된 삽입 위치 사용, 없으면 현재 앵커/선택 위치
      const targetTime = insertTime > 0 ? insertTime :
        (selStartTime !== null ? Math.min(selStartTime, selEndTime || selStartTime) : anchorTime);
      const insertSample = Math.floor(targetTime * currentBuffer.sampleRate);
      saveState();
      const newLength = currentBuffer.length + recordedBuffer.length;
      const newBuffer = audioCtx.createBuffer(
        currentBuffer.numberOfChannels,
        newLength,
        currentBuffer.sampleRate
      );
      for (let ch = 0; ch < currentBuffer.numberOfChannels; ch++) {
        const newData = newBuffer.getChannelData(ch);
        const oldData = currentBuffer.getChannelData(ch);
        const recCh = Math.min(ch, recordedBuffer.numberOfChannels - 1);
        const recData = recordedBuffer.getChannelData(recCh);
        for (let i = 0; i < insertSample; i++) {
          newData[i] = oldData[i];
        }
        for (let i = 0; i < recordedBuffer.length; i++) {
          newData[insertSample + i] = recData[i];
        }
        for (let i = insertSample; i < currentBuffer.length; i++) {
          newData[i + recordedBuffer.length] = oldData[i];
        }
      }
      track.buffer = newBuffer;
      track.duration = newBuffer.duration;
      const insertDuration = recordedBuffer.duration;
      if (track.segments) {
        track.segments.forEach(seg => {
          if (seg.start >= insertTime) {
            seg.start += insertDuration;
            seg.end += insertDuration;
          } else if (seg.end > insertTime) {
            seg.end += insertDuration;
          }
        });
      }
      if (track.markers) {
        track.markers.forEach(marker => {
          if (marker.time >= insertTime) {
            marker.time += insertDuration;
          }
        });
      }
      anchorTime = insertTime + insertDuration;
    }
    // ========== 설정 섹션 함수들 ==========
    // 설정 UI 초기화 (페이지 로드 시 호출)
    function initSettingsUI() {
      // 파형 색상
      if ($('selectWaveColor')) {
        $('selectWaveColor').value = waveColor;
      }
      // 선택 영역 색상
      if ($('selectSelectionColor')) {
        $('selectSelectionColor').value = selectionColor;
      }
      // 기본 재생 속도
      if ($('sliderDefaultSpeed')) {
        $('sliderDefaultSpeed').value = defaultPlaybackSpeed;
        $('labelDefaultSpeed').textContent = defaultPlaybackSpeed.toFixed(1) + 'x';
      }
    }
    // 설정 초기화
    function resetSettings() {
      if (!confirm("모든 설정을 기본값으로 초기화할까요?")) return;
      // 기본값으로 복원
      waveColor = '#4a90d9';
      selectionColor = 'rgba(0,123,255,0.25)';
      defaultPlaybackSpeed = 1.0;
      // localStorage 업데이트
      localStorage.setItem('waveColor', waveColor);
      localStorage.setItem('selectionColor', selectionColor);
      localStorage.setItem('defaultPlaybackSpeed', defaultPlaybackSpeed);
      // 다크모드 해제
      document.documentElement.classList.remove('dark-mode');
      if ($('chkDarkMode')) $('chkDarkMode').checked = false;
      localStorage.setItem('darkMode', 'false');
      // 오토스크롤 켜기
      if ($('chkAutoScroll')) $('chkAutoScroll').checked = true;
      // 파형 크기 초기화
      if ($('sliderWaveScale')) {
        $('sliderWaveScale').value = 90;
        $('sliderWaveScale').dispatchEvent(new Event('input'));
      }
      // UI 업데이트
      initSettingsUI();
      drawWaveform();
      showCenterToast("✅ 설정이 초기화되었습니다");
    }
    // 캐시 삭제
    function clearCache() {
      if (!confirm("모든 저장된 데이터를 삭제할까요?\n(설정, 히스토리 등)")) return;
      localStorage.clear();
      // 기본 설정 다시 적용
      resetSettings();
      showCenterToast("✅ 캐시가 삭제되었습니다");
    }

    // ==================== 문장별 녹음기 (Sentence Recorder) 모듈 ====================
    const SR = {
      sentences: [],
      currentIdx: 0,
      state: 'IDLE',      // IDLE | READY | RECORDING | DONE
      segStartSample: 0,
      recStartTime: 0,
      recElapsed: 0,
      timerInterval: null,
      levelRAF: null,
    };

    // 기존 녹음 시스템의 현재 총 샘플 수
    function srGetTotalSamples() {
      return flushedLength + liveRecordingData.length * LIVE_CHUNK_SIZE;
    }

    function srParseSentences(text, mode) {
      let lines = [];
      if (mode === 'newline') {
        lines = text.split(/\n+/);
      } else if (mode === 'sentence') {
        lines = text.split(/(?<=[.?!。？！])\s*/);
      } else {
        lines = text.split(/(?:\n+)|(?<=[\.\?!。？！])\s*/);
      }
      return lines.map(s => s.trim()).filter(s => s.length > 0);
    }

    function srRenderList() {
      const body = $('srListBody');
      body.innerHTML = '';
      SR.sentences.forEach((s, i) => {
        const item = document.createElement('div');
        item.className = 'sr-sentenceItem' + (i === SR.currentIdx ? ' active' : '') + (s.endSample > 0 ? ' recorded' : '');
        item.dataset.idx = i;
        const markHtml = s.mark ? `<span class="sr-sentenceMark sr-mark-${s.mark}">${s.mark}</span>` : '';
        item.innerHTML = `<span class="sr-sentenceIdx">${i+1}</span><span class="sr-sentenceText">${escHtml(s.text)}</span>${markHtml}`;
        item.addEventListener('click', () => srGoToSentence(i));
        body.appendChild(item);
      });
      srUpdateProgress();
    }

    function escHtml(s) {
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function srHighlightCurrent() {
      const items = $('srListBody').querySelectorAll('.sr-sentenceItem');
      items.forEach((el, i) => {
        el.classList.toggle('active', i === SR.currentIdx);
        el.classList.toggle('recorded', SR.sentences[i].endSample > 0);
        const mark = SR.sentences[i].mark;
        const markEl = el.querySelector('.sr-sentenceMark');
        if (mark && !markEl) {
          const sp = document.createElement('span');
          sp.className = 'sr-sentenceMark sr-mark-' + mark;
          sp.textContent = mark;
          el.appendChild(sp);
        } else if (mark && markEl) {
          markEl.className = 'sr-sentenceMark sr-mark-' + mark;
          markEl.textContent = mark;
        } else if (!mark && markEl) {
          markEl.remove();
        }
      });
      const activeEl = $('srListBody').querySelector('.sr-sentenceItem.active');
      if (activeEl) activeEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      if (SR.sentences.length > 0) {
        $('srCurrentSentence').textContent = SR.sentences[SR.currentIdx].text;
      }
      srUpdateProgress();
    }

    function srUpdateProgress() {
      const total = SR.sentences.length;
      const done = SR.sentences.filter(s => s.endSample > 0).length;
      const pct = total > 0 ? (done / total * 100) : 0;
      $('srProgressFill').style.width = pct + '%';
      const label = $('srProgressLabel');
      if (total > 0) {
        label.textContent = `${done}/${total} 완료`;
        $('srProgressBarWrap').style.display = '';
      }
      const hasData = srGetTotalSamples() > 0 && done > 0;
      $('srBtnDownloadAll').disabled = !hasData;
      $('srBtnDownloadSplit').disabled = !hasData;
    }

    function srGoToSentence(idx) {
      if (idx < 0 || idx >= SR.sentences.length) return;
      SR.currentIdx = idx;
      srHighlightCurrent();
    }

    function srLoadDocument(text, splitMode) {
      const parsed = srParseSentences(text, splitMode || 'newline');
      if (parsed.length === 0) {
        alert('문장을 찾을 수 없습니다. 텍스트를 확인해주세요.');
        return;
      }
      SR.sentences = parsed.map(t => ({ text: t, mark: '', startSample: -1, endSample: -1 }));
      SR.currentIdx = 0;
      SR.state = 'READY';
      SR.pcmChunks = [];
      SR.totalSamples = 0;
      $('srEmptyGuide').style.display = 'none';
      $('srRecordArea').style.display = 'flex';
      $('srBtnStartRec').disabled = false;
      srRenderList();
      $('srCurrentSentence').textContent = SR.sentences[0].text;
      $('srRecStatus').textContent = '🟢 준비됨';
      $('srRecStatus').style.color = '#52c41a';
      srUpdateControls();
      showCenterToast(`📝 ${parsed.length}개 문장 로드 완료`);
    }

    async function srStartRecording() {
      if (SR.state === 'RECORDING') return;
      try {
        // 마이크 권한 확보 + 장치 목록 갱신
        if (!mediaStream) {
          const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          tempStream.getTracks().forEach(t => t.stop());
          await populateAudioInputDevices(true);
        }
        // 기존 녹음 시스템으로 시작 (웨이브 + PCM 수집)
        if (!isRecording) await startRecording();
        // startRecording 실패 체크
        if (!isRecording) return;
        const totalNow = srGetTotalSamples();
        SR.segStartSample = totalNow;
        SR.sentences[SR.currentIdx].startSample = totalNow;
        SR.state = 'RECORDING';
        SR.recStartTime = performance.now() - SR.recElapsed;
        srStartTimer();
        srStartLevelMeter();
        $('srCurrentSentence').classList.add('recording');
        $('srRecStatus').innerHTML = '🔴 녹음 중';
        $('srRecStatus').style.color = '#f5222d';
        srUpdateControls();
      } catch (err) {
        console.error('녹음 시작 실패:', err);
        alert('녹음 시작에 실패했습니다.\n브라우저 설정에서 마이크 권한을 확인해주세요.');
      }
    }

    function srNextSentence() {
      if (SR.state !== 'RECORDING') return;
      const totalNow = srGetTotalSamples();
      SR.sentences[SR.currentIdx].endSample = totalNow;
      if (SR.currentIdx < SR.sentences.length - 1) {
        SR.currentIdx++;
        SR.segStartSample = totalNow;
        SR.sentences[SR.currentIdx].startSample = totalNow;
        SR.sentences[SR.currentIdx].endSample = -1;
        srHighlightCurrent();
      } else {
        srStopRecording();
      }
    }

    function srReRecord() {
      if (SR.state !== 'RECORDING') return;
      const totalNow = srGetTotalSamples();
      // 현재 위치를 새 시작점으로 (이전 데이터는 버퍼에 남지만 마커에서 제외)
      SR.sentences[SR.currentIdx].startSample = totalNow;
      SR.sentences[SR.currentIdx].endSample = -1;
      SR.segStartSample = totalNow;
      for (let i = SR.currentIdx + 1; i < SR.sentences.length; i++) {
        SR.sentences[i].startSample = -1; SR.sentences[i].endSample = -1;
      }
      srHighlightCurrent();
      showCenterToast('🔄 현재 문장 재녹음');
    }

    function srPauseRecording() {
      if (SR.state === 'RECORDING') {
        SR.state = 'PAUSED';
        SR.recElapsed = performance.now() - SR.recStartTime;
        srStopTimer();
        $('srCurrentSentence').classList.remove('recording');
        $('srRecStatus').innerHTML = '⏸ 일시정지';
        $('srRecStatus').style.color = '#faad14';
        srUpdateControls();
      } else if (SR.state === 'PAUSED') {
        SR.state = 'RECORDING';
        SR.recStartTime = performance.now() - SR.recElapsed;
        srStartTimer();
        $('srCurrentSentence').classList.add('recording');
        $('srRecStatus').innerHTML = '🔴 녹음 중';
        $('srRecStatus').style.color = '#f5222d';
        srUpdateControls();
      }
    }

    function srStopRecording() {
      if (SR.state !== 'RECORDING') return;
      const totalNow = srGetTotalSamples();
      if (SR.sentences[SR.currentIdx].endSample < 0 && SR.sentences[SR.currentIdx].startSample >= 0) {
        SR.sentences[SR.currentIdx].endSample = totalNow;
      }
      SR.state = 'DONE'; SR.recElapsed = 0;
      srStopTimer(); srStopLevelMeter();
      $('srCurrentSentence').classList.remove('recording');
      $('srRecStatus').innerHTML = '⬛ 완료';
      $('srRecStatus').style.color = '#52c41a';
      srHighlightCurrent(); srUpdateControls();
      // 기존 녹음 정지 (웨이브 저장)
      stopRecording();
      showCenterToast('✅ 녹음 완료!');
    }

    function srStartTimer() {
      srStopTimer();
      SR.timerInterval = setInterval(() => {
        const elapsed = performance.now() - SR.recStartTime;
        $('srRecTime').textContent = srFormatTime(elapsed);
        $('srRecTime').classList.toggle('rec', SR.state === 'RECORDING');
      }, 100);
    }
    function srStopTimer() { if (SR.timerInterval) { clearInterval(SR.timerInterval); SR.timerInterval = null; } }
    function srFormatTime(ms) {
      const sec = Math.floor(ms / 1000), m = Math.floor(sec / 60), s = sec % 60, d = Math.floor((ms % 1000) / 100);
      return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0') + '.' + d;
    }

    function srStartLevelMeter() {
      const update = () => {
        if (!inputAnalyser) return;
        const data = new Uint8Array(inputAnalyser.fftSize);
        inputAnalyser.getByteTimeDomainData(data);
        let sum = 0;
        for (let i = 0; i < data.length; i++) { const v = (data[i] - 128) / 128; sum += v * v; }
        $('srLevelFill').style.width = Math.min(100, Math.sqrt(sum / data.length) * 300) + '%';
        SR.levelRAF = requestAnimationFrame(update);
      };
      update();
    }
    function srStopLevelMeter() {
      if (SR.levelRAF) { cancelAnimationFrame(SR.levelRAF); SR.levelRAF = null; }
      $('srLevelFill').style.width = '0%';
    }

    function srSetMark(mark) {
      // 문장 미로드: R/P 차단, 안내 모달
      if (SR.sentences.length === 0) {
        if (e.key === 'r' || e.key === 'R') {
          e.preventDefault();
          e.stopImmediatePropagation();
          srShowLoadFirstModal();
        }
        return;
      }
      const cur = SR.sentences[SR.currentIdx];
      cur.mark = (cur.mark === mark) ? '' : mark;
      srHighlightCurrent();
    }

    function srUpdateControls() {
      const c = $('srControls');
      let html = '';
      switch (SR.state) {
        case 'READY': case 'DONE':
          html = '<button class="btn rec-start" onclick="srStartRecording()">🔴 녹음 (R)</button>';
          break;
        case 'RECORDING':
          html = '<button class="btn rec-next" onclick="srNextSentence()">⏭ 다음 (↓)</button>'
            + '<button class="btn" onclick="srReRecord()" style="height:30px;">🔄 (R)</button>'
            + '<button class="btn" onclick="srStopRecording()" style="height:30px; color:#f5222d;">⬛ (P)</button>';
          break;
      }
      c.innerHTML = html;
    }

    function srBuildPCM(startSample, endSample) {
      const total = srGetTotalSamples();
      startSample = Math.max(0, startSample || 0);
      endSample = Math.min(total, endSample || total);
      const length = endSample - startSample;
      if (length <= 0) return new Float32Array(0);
      const result = new Float32Array(length);
      for (let i = 0; i < length; i++) {
        result[i] = getLiveRecSample(startSample + i, 0);
      }
      return result;
    }

    function srFloat32ToWavBlob(pcm, sampleRate) {
      const bps = 16, dataSize = pcm.length * 2;
      const buf = new ArrayBuffer(44 + dataSize), v = new DataView(buf);
      srWriteStr(v, 0, 'RIFF'); v.setUint32(4, 36 + dataSize, true);
      srWriteStr(v, 8, 'WAVE'); srWriteStr(v, 12, 'fmt ');
      v.setUint32(16, 16, true); v.setUint16(20, 1, true); v.setUint16(22, 1, true);
      v.setUint32(24, sampleRate, true); v.setUint32(28, sampleRate * 2, true);
      v.setUint16(32, 2, true); v.setUint16(34, bps, true);
      srWriteStr(v, 36, 'data'); v.setUint32(40, dataSize, true);
      let off = 44;
      for (let i = 0; i < pcm.length; i++) {
        let s = Math.max(-1, Math.min(1, pcm[i]));
        v.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7FFF, true); off += 2;
      }
      return new Blob([buf], { type: 'audio/wav' });
    }
    function srWriteStr(v, o, s) { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)); }

    async function srDownloadAll() {
      const total = srGetTotalSamples();
      if (total === 0) return;
      showCenterToast('📦 통째로 저장 준비 중...');
      try {
        const pcm = srBuildPCM(0, total);
        const wavBlob = srFloat32ToWavBlob(pcm, recordSampleRate);
        const markers = { sampleRate: recordSampleRate, totalSamples: total,
          totalDuration: total / recordSampleRate,
          segments: SR.sentences.map((s, i) => ({ idx: i, text: s.text, mark: s.mark,
            startSample: s.startSample, endSample: s.endSample,
            startTime: s.startSample >= 0 ? s.startSample / recordSampleRate : -1,
            endTime: s.endSample >= 0 ? s.endSample / recordSampleRate : -1 }))
        };
        const zip = new JSZip();
        const ts = new Date().toISOString().slice(0,19).replace(/[:-]/g,'');
        zip.file(`recording_${ts}.wav`, wavBlob);
        zip.file(`markers_${ts}.json`, JSON.stringify(markers, null, 2));
        srDownloadBlob(await zip.generateAsync({ type: 'blob' }), `sentence_rec_full_${ts}.zip`);
        showCenterToast('✅ 통째로 저장 완료!');
      } catch (err) { console.error(err); alert('저장 오류: ' + err.message); }
    }

    async function srDownloadSplit() {
      if (srGetTotalSamples() === 0) return;
      const recorded = SR.sentences.filter(s => s.startSample >= 0 && s.endSample > 0);
      if (recorded.length === 0) { alert('녹음된 문장이 없습니다.'); return; }
      showCenterToast('📦 분할 저장 준비 중...');
      try {
        const zip = new JSZip();
        const ts = new Date().toISOString().slice(0,19).replace(/[:-]/g,'');
        const markers = { sampleRate: recordSampleRate, totalSamples: srGetTotalSamples(),
          segments: SR.sentences.map((s, i) => ({ idx: i, text: s.text, mark: s.mark,
            startSample: s.startSample, endSample: s.endSample,
            startTime: s.startSample >= 0 ? s.startSample / recordSampleRate : -1,
            endTime: s.endSample >= 0 ? s.endSample / recordSampleRate : -1 }))
        };
        zip.file(`markers_${ts}.json`, JSON.stringify(markers, null, 2));
        for (let i = 0; i < SR.sentences.length; i++) {
          const s = SR.sentences[i];
          if (s.startSample < 0 || s.endSample <= 0) continue;
          const pcm = srBuildPCM(s.startSample, s.endSample);
          if (pcm.length === 0) continue;
          const num = String(i + 1).padStart(3, '0');
          const safe = s.text.slice(0, 30).replace(/[\\/:*?"<>|]/g, '_');
          zip.file(`${num}_${safe}.wav`, srFloat32ToWavBlob(pcm, recordSampleRate));
        }
        srDownloadBlob(await zip.generateAsync({ type: 'blob' }), `sentence_rec_split_${ts}.zip`);
        showCenterToast('✅ 분할 저장 완료!');
      } catch (err) { console.error(err); alert('저장 오류: ' + err.message); }
    }

    function srDownloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob), a = document.createElement('a');
      a.href = url; a.download = filename; document.body.appendChild(a); a.click();
      setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
    }

    function srNewDocument() {
      if (SR.state === 'RECORDING' || SR.state === 'PAUSED') {
        if (!confirm('녹음 중입니다. 새 문서를 불러오면 현재 녹음이 삭제됩니다.')) return;
        srStopRecording();
      }
      if (SR.totalSamples > 0) {
        if (!confirm('현재 녹음 데이터가 삭제됩니다. 계속하시겠습니까?')) return;
      }
      SR.sentences = []; SR.currentIdx = 0; SR.state = 'IDLE';
      SR.recElapsed = 0;
      $('srEmptyGuide').style.display = '';
      $('srRecordArea').style.display = 'none';
      $('srRecTime').textContent = '00:00.0';
      $('srRecTime').classList.remove('rec');
      $('srBtnStartRec').disabled = true;
      $('srProgressLabel').textContent = '문서를 불러오세요';
      $('srProgressBarWrap').style.display = 'none';
      srUpdateProgress();
    }

    function srShowLoadFirstModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.style.display = 'flex';
      modal.innerHTML = `
        <div class="modal-box" style="width:380px;">
          <div class="modal-title">📝 문장을 먼저 불러와주세요</div>
          <div class="modal-desc" style="line-height:1.6;">
            녹음을 시작하려면 먼저 문장 파일을 불러와야 합니다.<br><br>
            하단 패널의 <strong>[📄 불러오기]</strong> 버튼을 클릭하거나<br>
            텍스트 파일을 드래그하여 불러와주세요.
          </div>
          <div class="modal-actions">
            <button class="btn primary" id="srModalLoadBtn">📄 불러오기</button>
            <button class="btn" id="srModalCloseBtn">닫기</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      modal.querySelector('#srModalCloseBtn').addEventListener('click', () => modal.remove());
      modal.querySelector('#srModalLoadBtn').addEventListener('click', () => {
        modal.remove();
        $('srFileInput').click();
      });
      modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
    }

    function srHandleKeydown(e) {
      if ($('pageEditor').style.display === 'none') return;
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
      if (SR.sentences.length === 0) return;

      const key = e.key;
      let handled = false;
      switch (key) {
        case ' ':
          if (SR.state === 'RECORDING') { e.preventDefault(); handled = true; }
          break;
        case 'r': case 'R':
          e.preventDefault();
          if (SR.state === 'READY' || SR.state === 'DONE') { srStartRecording(); handled = true; }
          else if (SR.state === 'RECORDING') { srReRecord(); handled = true; }
          break;
        case 'p': case 'P':
          e.preventDefault();
          if (SR.state === 'RECORDING') { srStopRecording(); handled = true; }
          break;
        case 'ArrowDown':
          e.preventDefault();
          if (SR.state === 'RECORDING') srNextSentence();
          else srGoToSentence(SR.currentIdx + 1);
          handled = true;
          break;
        case 'ArrowUp':
          e.preventDefault();
          if (SR.state !== 'RECORDING') srGoToSentence(SR.currentIdx - 1);
          handled = true;
          break;
        case '1': srSetMark('OK'); handled = true; break;
        case '2': srSetMark('REDO'); handled = true; break;
        case '3': srSetMark('SKIP'); handled = true; break;
        case '4': srSetMark('STAR'); handled = true; break;
      }
      if (handled) {
        e.stopImmediatePropagation();
      }
    }

    function initSentenceRecorder() {
      console.log('📝 문장별 녹음기 초기화');
      // 사이드바/하단 녹음 컨트롤 숨김 (SR 전용 프로그램)
      ['recordModeSelector','recordingTimer','recordingControls','btnStartRecord','backupStatusBar'].forEach(id => {
        const el = $(id); if (el) el.style.display = 'none';
      });
      // "녹음 모드" 라벨 숨김
      document.querySelectorAll('.subsectionLabel').forEach(el => {
        if (el.textContent.trim() === '녹음 모드') el.style.display = 'none';
      });

      const fileInput = $('srFileInput');
      $('srBtnLoadFile').addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', (e) => {
        if (e.target.files[0]) srReadFile(e.target.files[0]);
        e.target.value = '';
      });
      const dropZone = $('srDropZone');
      dropZone.addEventListener('click', () => fileInput.click());
      dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
      dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
      dropZone.addEventListener('drop', (e) => {
        e.preventDefault(); dropZone.classList.remove('dragover');
        if (e.dataTransfer.files[0]) srReadFile(e.dataTransfer.files[0]);
      });
      $('srBtnLoadPaste').addEventListener('click', () => {
        const text = $('srPasteText').value.trim();
        if (!text) { alert('텍스트를 입력해주세요.'); return; }
        srLoadDocument(text, $('srSplitMode').value);
      });
      $('srBtnDownloadAll').addEventListener('click', srDownloadAll);
      $('srBtnDownloadSplit').addEventListener('click', srDownloadSplit);
      // 리스트↔메인 리사이저
      const srResizer = $('srListResizer');
      const srList = $('srSentenceList');
      let srDragging = false;
      srResizer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        srDragging = true;
        srResizer.classList.add('dragging');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
      });
      document.addEventListener('mousemove', (e) => {
        if (!srDragging) return;
        const parent = srList.parentElement;
        const rect = parent.getBoundingClientRect();
        let newW = e.clientX - rect.left;
        newW = Math.max(120, Math.min(newW, rect.width - 200));
        srList.style.width = newW + 'px';
      });
      document.addEventListener('mouseup', () => {
        if (!srDragging) return;
        srDragging = false;
        srResizer.classList.remove('dragging');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
      });
      document.addEventListener('keydown', srHandleKeydown, true);
    }

    function srReadFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => srLoadDocument(e.target.result, $('srSplitMode').value);
      reader.readAsText(file, 'UTF-8');
    }


    // [IMPORTANT] Call init at the end, exactly like v0.81.0
    init();
  </script>
  <!-- 자동 세그먼트 모달 -->
          <div id="exportWavModal" class="modal-overlay">
            <div class="modal-box" style="width: 480px;">
              <div class="modal-title">🎵 WAV로 내보내기</div>
              <div class="modal-desc">
                <p style="margin-bottom: 12px; color: #666;">현재 트랙을 WAV 파일로 저장합니다.</p>
                <div style="padding: 12px; background: #e3f2fd; border-radius: 8px; margin-bottom: 12px; font-size: 12px;">
                  <strong>📖 WAV 포맷 특징</strong>
                  <p style="margin: 8px 0 0 0; line-height: 1.5;">
                  무손실 압축으로 원본 품질 그대로 저장됩니다.
                  파일 크기가 크지만 편집 작업에 최적화되어 있습니다.
                  </p>
                </div>
                <div class="sliderGroup">
                  <label class="sliderLabel">샘플 레이트</label>
                  <select id="selectWavSampleRate" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                  <option value="original">원본 유지</option>
                  <option value="48000">48000 Hz (고품질)</option>
                  <option value="44100">44100 Hz (CD 품질)</option>
                  <option value="22050">22050 Hz (중간)</option>
                  <option value="16000">16000 Hz (음성용)</option>
                  </select>
                </div>
                <div class="sliderGroup">
                  <label class="sliderLabel">비트 뎁스</label>
                  <select id="selectWavBitDepth" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                  <option value="16">16-bit (CD 품질, 권장)</option>
                  <option value="24">24-bit (스튜디오 품질)</option>
                  <option value="32">32-bit float (최고 품질)</option>
                  </select>
                </div>
                <div id="wavExportInfo" style="padding: 10px; background: #f5f5f5; border-radius: 8px; margin-top: 12px; font-size: 11px;">
                  <strong>📊 예상 파일 정보</strong>
                  <div id="wavExportDetails" style="margin-top: 6px; line-height: 1.6;"></div>
                </div>
              </div>
              <div class="modal-actions">
                <button class="btn primary" id="btnApplyExportWav">내보내기</button>
                <button class="btn" id="btnCancelExportWav">취소</button>
              </div>
            </div>
          </div>
          <!-- MP3 내보내기 모달 -->
          <div id="exportMp3Modal" class="modal-overlay">
            <div class="modal-box" style="width: 480px;">
              <div class="modal-title">🎵 MP3로 내보내기</div>
              <div class="modal-desc">
                <p style="margin-bottom: 12px; color: #666;">현재 트랙을 MP3 파일로 저장합니다.</p>
                <div style="padding: 12px; background: #fff3e0; border-radius: 8px; margin-bottom: 12px; font-size: 12px;">
                  <strong>📖 MP3 포맷 특징</strong>
                  <p style="margin: 8px 0 0 0; line-height: 1.5;">
                  손실 압축으로 파일 크기가 작습니다.
                  대부분의 기기와 호환되며 공유에 적합합니다.
                  </p>
                </div>
                <div class="sliderGroup">
                  <label class="sliderLabel">비트레이트</label>
                  <select id="selectMp3Bitrate" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                  <option value="320">320 kbps (최고 품질)</option>
                  <option value="256">256 kbps (고품질)</option>
                  <option value="192" selected>192 kbps (권장)</option>
                  <option value="128">128 kbps (표준)</option>
                  <option value="96">96 kbps (음성용)</option>
                  <option value="64">64 kbps (저용량)</option>
                  </select>
                </div>
                <div style="padding: 10px; background: #fff8e1; border-radius: 8px; margin-top: 12px; font-size: 11px;">
                  <strong>💡 비트레이트 가이드</strong>
                  <ul style="margin: 6px 0 0 0; padding-left: 16px; line-height: 1.6;">
                    <li><b>320 kbps:</b> 음악 아카이빙, 최고 품질</li>
                    <li><b>192 kbps:</b> 일반 음악 감상</li>
                    <li><b>128 kbps:</b> 팟캐스트, 음성</li>
                    <li><b>64 kbps:</b> 오디오북, 음성 메모</li>
                  </ul>
                </div>
                <div id="mp3ExportInfo" style="padding: 10px; background: #f5f5f5; border-radius: 8px; margin-top: 12px; font-size: 11px;">
                  <strong>📊 예상 파일 정보</strong>
                  <div id="mp3ExportDetails" style="margin-top: 6px; line-height: 1.6;"></div>
                </div>
              </div>
              <div class="modal-actions">
                <button class="btn primary" id="btnApplyExportMp3">내보내기</button>
                <button class="btn" id="btnCancelExportMp3">취소</button>
              </div>
            </div>
          </div>
          <!-- 선택 구간 내보내기 모달 -->
          <div id="exportSelectionModal" class="modal-overlay">
            <div class="modal-box" style="width: 480px;">
              <div class="modal-title">✂️ 선택 구간 내보내기</div>
              <div class="modal-desc">
                <p style="margin-bottom: 12px; color: #666;">선택된 구간만 별도 파일로 저장합니다.</p>
                <div id="selectionExportInfo" style="padding: 12px; background: #e8f5e9; border-radius: 8px; margin-bottom: 12px; font-size: 12px;">
                  <strong>📍 선택 구간 정보</strong>
                  <div id="selectionExportDetails" style="margin-top: 6px; line-height: 1.6;"></div>
                </div>
                <div class="sliderGroup">
                  <label class="sliderLabel">저장 포맷</label>
                  <select id="selectSelectionFormat" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                  <option value="wav">WAV (무손실)</option>
                  <option value="mp3">MP3 (압축)</option>
                  </select>
                </div>
              </div>
              <div class="modal-actions">
                <button class="btn primary" id="btnApplyExportSelection">내보내기</button>
                <button class="btn" id="btnCancelExportSelection">취소</button>
              </div>
            </div>
          </div>
          <!-- 세그먼트별 분할 저장 모달 -->
          <div id="exportSilenceModal" class="modal-overlay">
            <div class="modal-box" style="width: 500px;">
              <div class="modal-title">🔇 무음 기준 분할 저장</div>
              <div class="modal-desc">
                <p style="margin-bottom: 12px; color: #666;">무음 구간을 감지하여 자동으로 분할 저장합니다.</p>
                <div style="padding: 12px; background: #e8f5e9; border-radius: 8px; margin-bottom: 12px; font-size: 12px;">
                  <strong>📖 기능 설명</strong>
                  <p style="margin: 8px 0 0 0; line-height: 1.5;">
                  지정한 임계값보다 낮은 소리가 일정 시간 이상 지속되면 무음으로 판단하여 분할합니다.
                  </p>
                </div>
                <div class="sliderGroup">
                  <label class="sliderLabel">무음 임계값 (dB)</label>
                  <input type="range" id="sliderSilenceThreshold" min="-60" max="-20" step="1" value="-40">
                  <div class="sliderValue" id="labelSilenceThreshold">-40 dB</div>
                </div>
                <div class="sliderGroup">
                  <label class="sliderLabel">최소 무음 길이 (초)</label>
                  <input type="range" id="sliderSilenceMinDuration" min="0.1" max="3" step="0.1" value="0.5">
                  <div class="sliderValue" id="labelSilenceMinDuration">0.5 초</div>
                </div>
                <div class="sliderGroup">
                  <label class="sliderLabel">저장 포맷</label>
                  <select id="selectSilenceFormat" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                  <option value="wav">WAV (무손실)</option>
                  <option value="mp3">MP3 (압축)</option>
                  </select>
                </div>
                <div style="padding: 10px; background: #fff8e1; border-radius: 8px; margin-top: 12px; font-size: 11px;">
                  <strong>💡 파라미터 가이드</strong>
                  <ul style="margin: 6px 0 0 0; padding-left: 16px; line-height: 1.6;">
                    <li><b>-40 dB:</b> 일반적인 무음 감지</li>
                    <li><b>-50 dB:</b> 더 민감하게 감지</li>
                    <li><b>-30 dB:</b> 배경 노이즈 있을 때</li>
                  </ul>
                </div>
              </div>
              <div class="modal-actions">
                <button class="btn" id="btnPreviewSilenceSplit">🔍 미리보기</button>
                <button class="btn primary" id="btnApplyExportSilence">내보내기</button>
                <button class="btn" id="btnCancelExportSilence">취소</button>
              </div>
            </div>
          </div>
          <!-- 로우패스 필터 모달 -->
          <div id="repeatModal" class="modal-overlay">
            <div class="modal-box" style="width: 400px;">
              <div class="modal-title">🔁 선택 구간 반복</div>
              <div class="modal-desc">
                <p style="margin-bottom: 12px; color: #666;">선택한 구간을 지정한 횟수만큼 반복합니다.</p>
                <div style="padding: 12px; background: #e3f2fd; border-radius: 8px; margin-bottom: 12px; font-size: 12px;">
                  <strong>📖 기능 설명</strong>
                  <p style="margin: 8px 0 0 0; line-height: 1.5;">
                  선택 구간이 반복 횟수만큼 연속으로 이어집니다.<br>
                  예: 2회 반복 시 원본 구간이 2번 연속 재생됩니다.
                  </p>
                </div>
                <div class="sliderGroup">
                  <label class="sliderLabel">반복 횟수</label>
                  <input type="range" id="sliderRepeatCount" min="2" max="10" step="1" value="2">
                  <div class="sliderValue" id="labelRepeatCount">2회</div>
                </div>
                <div id="repeatPreviewInfo" style="padding: 10px; background: #f5f5f5; border-radius: 8px; margin-top: 12px; font-size: 12px;">
                </div>
                <div style="padding: 10px; background: #fff8e1; border-radius: 8px; margin-top: 12px; font-size: 11px;">
                  <strong>⚠️ 주의사항</strong>
                  <p style="margin: 6px 0 0 0; line-height: 1.5;">
                  반복 후 오디오 길이가 늘어납니다.<br>
                  선택 구간 내의 세그먼트는 보존되지 않습니다.
                  </p>
                </div>
              </div>
              <div class="modal-actions">
                <button class="btn" onclick="$('repeatModal').style.display='none'">취소</button>
                <button class="btn primary" onclick="doRepeatRegion()">반복 실행</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
        